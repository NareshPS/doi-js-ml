/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "BASE_TRANSITION": () => (/* binding */ BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* binding */ CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* binding */ CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* binding */ CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* binding */ CREATE_COMMENT),
/* harmony export */   "CREATE_SLOTS": () => (/* binding */ CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* binding */ CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* binding */ CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* binding */ CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* binding */ FRAGMENT),
/* harmony export */   "IS_REF": () => (/* binding */ IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* binding */ KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* binding */ MERGE_PROPS),
/* harmony export */   "OPEN_BLOCK": () => (/* binding */ OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* binding */ RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* binding */ RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* binding */ SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* binding */ TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* binding */ TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* binding */ UNREF),
/* harmony export */   "WITH_CTX": () => (/* binding */ WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   "WITH_SCOPE_ID": () => (/* binding */ WITH_SCOPE_ID),
/* harmony export */   "advancePositionWithClone": () => (/* binding */ advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* binding */ advancePositionWithMutation),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "baseCompile": () => (/* binding */ baseCompile),
/* harmony export */   "baseParse": () => (/* binding */ baseParse),
/* harmony export */   "buildProps": () => (/* binding */ buildProps),
/* harmony export */   "buildSlots": () => (/* binding */ buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* binding */ checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* binding */ createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* binding */ createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* binding */ createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* binding */ createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* binding */ createCallExpression),
/* harmony export */   "createCompilerError": () => (/* binding */ createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* binding */ createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* binding */ createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* binding */ createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* binding */ createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* binding */ createIfStatement),
/* harmony export */   "createInterpolation": () => (/* binding */ createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* binding */ createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* binding */ createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* binding */ createReturnStatement),
/* harmony export */   "createRoot": () => (/* binding */ createRoot),
/* harmony export */   "createSequenceExpression": () => (/* binding */ createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* binding */ createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* binding */ createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* binding */ createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* binding */ createVNodeCall),
/* harmony export */   "findDir": () => (/* binding */ findDir),
/* harmony export */   "findProp": () => (/* binding */ findProp),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "getBaseTransformPreset": () => (/* binding */ getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* binding */ getInnerRange),
/* harmony export */   "hasDynamicKeyVBind": () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* binding */ hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* binding */ helperNameMap),
/* harmony export */   "injectProp": () => (/* binding */ injectProp),
/* harmony export */   "isBindKey": () => (/* binding */ isBindKey),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* binding */ isCoreComponent),
/* harmony export */   "isMemberExpression": () => (/* binding */ isMemberExpression),
/* harmony export */   "isSimpleIdentifier": () => (/* binding */ isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* binding */ isSlotOutlet),
/* harmony export */   "isStaticExp": () => (/* binding */ isStaticExp),
/* harmony export */   "isTemplateNode": () => (/* binding */ isTemplateNode),
/* harmony export */   "isText": () => (/* binding */ isText),
/* harmony export */   "isVSlot": () => (/* binding */ isVSlot),
/* harmony export */   "locStub": () => (/* binding */ locStub),
/* harmony export */   "noopDirectiveTransform": () => (/* binding */ noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* binding */ processExpression),
/* harmony export */   "processFor": () => (/* binding */ processFor),
/* harmony export */   "processIf": () => (/* binding */ processIf),
/* harmony export */   "processSlotOutlet": () => (/* binding */ processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* binding */ resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* binding */ toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* binding */ trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* binding */ trackVForSlotScopes),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformBind": () => (/* binding */ transformBind),
/* harmony export */   "transformElement": () => (/* binding */ transformElement),
/* harmony export */   "transformExpression": () => (/* binding */ transformExpression),
/* harmony export */   "transformModel": () => (/* binding */ transformModel),
/* harmony export */   "transformOn": () => (/* binding */ transformOn),
/* harmony export */   "traverseNode": () => (/* binding */ traverseNode),
/* harmony export */   "warnDeprecation": () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _errorMessages, _helperNameMap, _deprecationData;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function defaultOnError(error) {
  throw error;
}

function defaultOnWarn(msg) {
   true && console.warn("[Vue warn] ".concat(msg.message));
}

function createCompilerError(code, loc, messages, additionalMessage) {
  var msg =  true ? (messages || errorMessages)[code] + (additionalMessage || "") : 0;
  var error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}

var errorMessages = (_errorMessages = {}, _defineProperty(_errorMessages, 0
/* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
, 'Illegal comment.'), _defineProperty(_errorMessages, 1
/* CDATA_IN_HTML_CONTENT */
, 'CDATA section is allowed only in XML context.'), _defineProperty(_errorMessages, 2
/* DUPLICATE_ATTRIBUTE */
, 'Duplicate attribute.'), _defineProperty(_errorMessages, 3
/* END_TAG_WITH_ATTRIBUTES */
, 'End tag cannot have attributes.'), _defineProperty(_errorMessages, 4
/* END_TAG_WITH_TRAILING_SOLIDUS */
, "Illegal '/' in tags."), _defineProperty(_errorMessages, 5
/* EOF_BEFORE_TAG_NAME */
, 'Unexpected EOF in tag.'), _defineProperty(_errorMessages, 6
/* EOF_IN_CDATA */
, 'Unexpected EOF in CDATA section.'), _defineProperty(_errorMessages, 7
/* EOF_IN_COMMENT */
, 'Unexpected EOF in comment.'), _defineProperty(_errorMessages, 8
/* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
, 'Unexpected EOF in script.'), _defineProperty(_errorMessages, 9
/* EOF_IN_TAG */
, 'Unexpected EOF in tag.'), _defineProperty(_errorMessages, 10
/* INCORRECTLY_CLOSED_COMMENT */
, 'Incorrectly closed comment.'), _defineProperty(_errorMessages, 11
/* INCORRECTLY_OPENED_COMMENT */
, 'Incorrectly opened comment.'), _defineProperty(_errorMessages, 12
/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
, "Illegal tag name. Use '&lt;' to print '<'."), _defineProperty(_errorMessages, 13
/* MISSING_ATTRIBUTE_VALUE */
, 'Attribute value was expected.'), _defineProperty(_errorMessages, 14
/* MISSING_END_TAG_NAME */
, 'End tag name was expected.'), _defineProperty(_errorMessages, 15
/* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
, 'Whitespace was expected.'), _defineProperty(_errorMessages, 16
/* NESTED_COMMENT */
, "Unexpected '<!--' in comment."), _defineProperty(_errorMessages, 17
/* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
, 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).'), _defineProperty(_errorMessages, 18
/* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
, 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).'), _defineProperty(_errorMessages, 19
/* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
, "Attribute name cannot start with '='."), _defineProperty(_errorMessages, 21
/* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
, "'<?' is allowed only in XML context."), _defineProperty(_errorMessages, 20
/* UNEXPECTED_NULL_CHARACTER */
, "Unexpected null cahracter."), _defineProperty(_errorMessages, 22
/* UNEXPECTED_SOLIDUS_IN_TAG */
, "Illegal '/' in tags."), _defineProperty(_errorMessages, 23
/* X_INVALID_END_TAG */
, 'Invalid end tag.'), _defineProperty(_errorMessages, 24
/* X_MISSING_END_TAG */
, 'Element is missing end tag.'), _defineProperty(_errorMessages, 25
/* X_MISSING_INTERPOLATION_END */
, 'Interpolation end sign was not found.'), _defineProperty(_errorMessages, 26
/* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
, 'End bracket for dynamic directive argument was not found. ' + 'Note that dynamic directive argument cannot contain spaces.'), _defineProperty(_errorMessages, 27
/* X_V_IF_NO_EXPRESSION */
, "v-if/v-else-if is missing expression."), _defineProperty(_errorMessages, 28
/* X_V_IF_SAME_KEY */
, "v-if/else branches must use unique keys."), _defineProperty(_errorMessages, 29
/* X_V_ELSE_NO_ADJACENT_IF */
, "v-else/v-else-if has no adjacent v-if."), _defineProperty(_errorMessages, 30
/* X_V_FOR_NO_EXPRESSION */
, "v-for is missing expression."), _defineProperty(_errorMessages, 31
/* X_V_FOR_MALFORMED_EXPRESSION */
, "v-for has invalid expression."), _defineProperty(_errorMessages, 32
/* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
, "<template v-for> key should be placed on the <template> tag."), _defineProperty(_errorMessages, 33
/* X_V_BIND_NO_EXPRESSION */
, "v-bind is missing expression."), _defineProperty(_errorMessages, 34
/* X_V_ON_NO_EXPRESSION */
, "v-on is missing expression."), _defineProperty(_errorMessages, 35
/* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
, "Unexpected custom directive on <slot> outlet."), _defineProperty(_errorMessages, 36
/* X_V_SLOT_MIXED_SLOT_USAGE */
, "Mixed v-slot usage on both the component and nested <template>." + "When there are multiple named slots, all slots should use <template> " + "syntax to avoid scope ambiguity."), _defineProperty(_errorMessages, 37
/* X_V_SLOT_DUPLICATE_SLOT_NAMES */
, "Duplicate slot names found. "), _defineProperty(_errorMessages, 38
/* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
, "Extraneous children found when component already has explicitly named " + "default slot. These children will be ignored."), _defineProperty(_errorMessages, 39
/* X_V_SLOT_MISPLACED */
, "v-slot can only be used on components or <template> tags."), _defineProperty(_errorMessages, 40
/* X_V_MODEL_NO_EXPRESSION */
, "v-model is missing expression."), _defineProperty(_errorMessages, 41
/* X_V_MODEL_MALFORMED_EXPRESSION */
, "v-model value must be a valid JavaScript member expression."), _defineProperty(_errorMessages, 42
/* X_V_MODEL_ON_SCOPE_VARIABLE */
, "v-model cannot be used on v-for or v-slot scope variables because they are not writable."), _defineProperty(_errorMessages, 43
/* X_INVALID_EXPRESSION */
, "Error parsing JavaScript expression: "), _defineProperty(_errorMessages, 44
/* X_KEEP_ALIVE_INVALID_CHILDREN */
, "<KeepAlive> expects exactly one child component."), _defineProperty(_errorMessages, 45
/* X_PREFIX_ID_NOT_SUPPORTED */
, "\"prefixIdentifiers\" option is not supported in this build of compiler."), _defineProperty(_errorMessages, 46
/* X_MODULE_MODE_NOT_SUPPORTED */
, "ES module mode is not supported in this build of compiler."), _defineProperty(_errorMessages, 47
/* X_CACHE_HANDLER_NOT_SUPPORTED */
, "\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled."), _defineProperty(_errorMessages, 48
/* X_SCOPE_ID_NOT_SUPPORTED */
, "\"scopeId\" option is only supported in module mode."), _defineProperty(_errorMessages, 49
/* __EXTEND_POINT__ */
, ""), _errorMessages);
var FRAGMENT = Symbol( true ? "Fragment" : 0);
var TELEPORT = Symbol( true ? "Teleport" : 0);
var SUSPENSE = Symbol( true ? "Suspense" : 0);
var KEEP_ALIVE = Symbol( true ? "KeepAlive" : 0);
var BASE_TRANSITION = Symbol( true ? "BaseTransition" : 0);
var OPEN_BLOCK = Symbol( true ? "openBlock" : 0);
var CREATE_BLOCK = Symbol( true ? "createBlock" : 0);
var CREATE_VNODE = Symbol( true ? "createVNode" : 0);
var CREATE_COMMENT = Symbol( true ? "createCommentVNode" : 0);
var CREATE_TEXT = Symbol( true ? "createTextVNode" : 0);
var CREATE_STATIC = Symbol( true ? "createStaticVNode" : 0);
var RESOLVE_COMPONENT = Symbol( true ? "resolveComponent" : 0);
var RESOLVE_DYNAMIC_COMPONENT = Symbol( true ? "resolveDynamicComponent" : 0);
var RESOLVE_DIRECTIVE = Symbol( true ? "resolveDirective" : 0);
var RESOLVE_FILTER = Symbol( true ? "resolveFilter" : 0);
var WITH_DIRECTIVES = Symbol( true ? "withDirectives" : 0);
var RENDER_LIST = Symbol( true ? "renderList" : 0);
var RENDER_SLOT = Symbol( true ? "renderSlot" : 0);
var CREATE_SLOTS = Symbol( true ? "createSlots" : 0);
var TO_DISPLAY_STRING = Symbol( true ? "toDisplayString" : 0);
var MERGE_PROPS = Symbol( true ? "mergeProps" : 0);
var TO_HANDLERS = Symbol( true ? "toHandlers" : 0);
var CAMELIZE = Symbol( true ? "camelize" : 0);
var CAPITALIZE = Symbol( true ? "capitalize" : 0);
var TO_HANDLER_KEY = Symbol( true ? "toHandlerKey" : 0);
var SET_BLOCK_TRACKING = Symbol( true ? "setBlockTracking" : 0);
var PUSH_SCOPE_ID = Symbol( true ? "pushScopeId" : 0);
var POP_SCOPE_ID = Symbol( true ? "popScopeId" : 0);
var WITH_SCOPE_ID = Symbol( true ? "withScopeId" : 0);
var WITH_CTX = Symbol( true ? "withCtx" : 0);
var UNREF = Symbol( true ? "unref" : 0);
var IS_REF = Symbol( true ? "isRef" : 0); // Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.

var helperNameMap = (_helperNameMap = {}, _defineProperty(_helperNameMap, FRAGMENT, "Fragment"), _defineProperty(_helperNameMap, TELEPORT, "Teleport"), _defineProperty(_helperNameMap, SUSPENSE, "Suspense"), _defineProperty(_helperNameMap, KEEP_ALIVE, "KeepAlive"), _defineProperty(_helperNameMap, BASE_TRANSITION, "BaseTransition"), _defineProperty(_helperNameMap, OPEN_BLOCK, "openBlock"), _defineProperty(_helperNameMap, CREATE_BLOCK, "createBlock"), _defineProperty(_helperNameMap, CREATE_VNODE, "createVNode"), _defineProperty(_helperNameMap, CREATE_COMMENT, "createCommentVNode"), _defineProperty(_helperNameMap, CREATE_TEXT, "createTextVNode"), _defineProperty(_helperNameMap, CREATE_STATIC, "createStaticVNode"), _defineProperty(_helperNameMap, RESOLVE_COMPONENT, "resolveComponent"), _defineProperty(_helperNameMap, RESOLVE_DYNAMIC_COMPONENT, "resolveDynamicComponent"), _defineProperty(_helperNameMap, RESOLVE_DIRECTIVE, "resolveDirective"), _defineProperty(_helperNameMap, RESOLVE_FILTER, "resolveFilter"), _defineProperty(_helperNameMap, WITH_DIRECTIVES, "withDirectives"), _defineProperty(_helperNameMap, RENDER_LIST, "renderList"), _defineProperty(_helperNameMap, RENDER_SLOT, "renderSlot"), _defineProperty(_helperNameMap, CREATE_SLOTS, "createSlots"), _defineProperty(_helperNameMap, TO_DISPLAY_STRING, "toDisplayString"), _defineProperty(_helperNameMap, MERGE_PROPS, "mergeProps"), _defineProperty(_helperNameMap, TO_HANDLERS, "toHandlers"), _defineProperty(_helperNameMap, CAMELIZE, "camelize"), _defineProperty(_helperNameMap, CAPITALIZE, "capitalize"), _defineProperty(_helperNameMap, TO_HANDLER_KEY, "toHandlerKey"), _defineProperty(_helperNameMap, SET_BLOCK_TRACKING, "setBlockTracking"), _defineProperty(_helperNameMap, PUSH_SCOPE_ID, "pushScopeId"), _defineProperty(_helperNameMap, POP_SCOPE_ID, "popScopeId"), _defineProperty(_helperNameMap, WITH_SCOPE_ID, "withScopeId"), _defineProperty(_helperNameMap, WITH_CTX, "withCtx"), _defineProperty(_helperNameMap, UNREF, "unref"), _defineProperty(_helperNameMap, IS_REF, "isRef"), _helperNameMap);

function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach(function (s) {
    helperNameMap[s] = helpers[s];
  });
} // AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.


var locStub = {
  source: '',
  start: {
    line: 1,
    column: 1,
    offset: 0
  },
  end: {
    line: 1,
    column: 1,
    offset: 0
  }
};

function createRoot(children) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 0
    /* ROOT */
    ,
    children: children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined,
    loc: loc
  };
}

function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives) {
  var isBlock = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var disableTracking = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var loc = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : locStub;

  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(CREATE_BLOCK);
    } else {
      context.helper(CREATE_VNODE);
    }

    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }

  return {
    type: 13
    /* VNODE_CALL */
    ,
    tag: tag,
    props: props,
    children: children,
    patchFlag: patchFlag,
    dynamicProps: dynamicProps,
    directives: directives,
    isBlock: isBlock,
    disableTracking: disableTracking,
    loc: loc
  };
}

function createArrayExpression(elements) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 17
    /* JS_ARRAY_EXPRESSION */
    ,
    loc: loc,
    elements: elements
  };
}

function createObjectExpression(properties) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 15
    /* JS_OBJECT_EXPRESSION */
    ,
    loc: loc,
    properties: properties
  };
}

function createObjectProperty(key, value) {
  return {
    type: 16
    /* JS_PROPERTY */
    ,
    loc: locStub,
    key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
    value: value
  };
}

function createSimpleExpression(content, isStatic)
/* NOT_CONSTANT */
{
  var loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;
  var constType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return {
    type: 4
    /* SIMPLE_EXPRESSION */
    ,
    loc: loc,
    content: content,
    isStatic: isStatic,
    constType: isStatic ? 3
    /* CAN_STRINGIFY */
    : constType
  };
}

function createInterpolation(content, loc) {
  return {
    type: 5
    /* INTERPOLATION */
    ,
    loc: loc,
    content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content) ? createSimpleExpression(content, false, loc) : content
  };
}

function createCompoundExpression(children) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 8
    /* COMPOUND_EXPRESSION */
    ,
    loc: loc,
    children: children
  };
}

function createCallExpression(callee) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;
  return {
    type: 14
    /* JS_CALL_EXPRESSION */
    ,
    loc: loc,
    callee: callee,
    arguments: args
  };
}

function createFunctionExpression(params) {
  var returns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var newline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSlot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var loc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : locStub;
  return {
    type: 18
    /* JS_FUNCTION_EXPRESSION */
    ,
    params: params,
    returns: returns,
    newline: newline,
    isSlot: isSlot,
    loc: loc
  };
}

function createConditionalExpression(test, consequent, alternate) {
  var newline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return {
    type: 19
    /* JS_CONDITIONAL_EXPRESSION */
    ,
    test: test,
    consequent: consequent,
    alternate: alternate,
    newline: newline,
    loc: locStub
  };
}

function createCacheExpression(index, value) {
  var isVNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    type: 20
    /* JS_CACHE_EXPRESSION */
    ,
    index: index,
    value: value,
    isVNode: isVNode,
    loc: locStub
  };
}

function createBlockStatement(body) {
  return {
    type: 21
    /* JS_BLOCK_STATEMENT */
    ,
    body: body,
    loc: locStub
  };
}

function createTemplateLiteral(elements) {
  return {
    type: 22
    /* JS_TEMPLATE_LITERAL */
    ,
    elements: elements,
    loc: locStub
  };
}

function createIfStatement(test, consequent, alternate) {
  return {
    type: 23
    /* JS_IF_STATEMENT */
    ,
    test: test,
    consequent: consequent,
    alternate: alternate,
    loc: locStub
  };
}

function createAssignmentExpression(left, right) {
  return {
    type: 24
    /* JS_ASSIGNMENT_EXPRESSION */
    ,
    left: left,
    right: right,
    loc: locStub
  };
}

function createSequenceExpression(expressions) {
  return {
    type: 25
    /* JS_SEQUENCE_EXPRESSION */
    ,
    expressions: expressions,
    loc: locStub
  };
}

function createReturnStatement(returns) {
  return {
    type: 26
    /* JS_RETURN_STATEMENT */
    ,
    returns: returns,
    loc: locStub
  };
}

var isStaticExp = function isStaticExp(p) {
  return p.type === 4
  /* SIMPLE_EXPRESSION */
  && p.isStatic;
};

var isBuiltInType = function isBuiltInType(tag, expected) {
  return tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
};

function isCoreComponent(tag) {
  if (isBuiltInType(tag, 'Teleport')) {
    return TELEPORT;
  } else if (isBuiltInType(tag, 'Suspense')) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, 'KeepAlive')) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, 'BaseTransition')) {
    return BASE_TRANSITION;
  }
}

var nonIdentifierRE = /^\d|[^\$\w]/;

var isSimpleIdentifier = function isSimpleIdentifier(name) {
  return !nonIdentifierRE.test(name);
};

var memberExpRE = /^[A-Za-z_$\xA0-\uFFFF][\w$\xA0-\uFFFF]*(?:\s*\.\s*[A-Za-z_$\xA0-\uFFFF][\w$\xA0-\uFFFF]*|\[(.+)\])*$/;

var isMemberExpression = function isMemberExpression(path) {
  if (!path) return false;
  var matched = memberExpRE.exec(path.trim());
  if (!matched) return false;
  if (!matched[1]) return true;
  if (!/[\[\]]/.test(matched[1])) return true;
  return isMemberExpression(matched[1].trim());
};

function getInnerRange(loc, offset, length) {
  var source = loc.source.substr(offset, length);
  var newLoc = {
    source: source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };

  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }

  return newLoc;
}

function advancePositionWithClone(pos, source) {
  var numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
} // advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser


function advancePositionWithMutation(pos, source) {
  var numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  var linesCount = 0;
  var lastNewLinePos = -1;

  for (var i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10
    /* newline char code */
    ) {
        linesCount++;
        lastNewLinePos = i;
      }
  }

  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}

function assert(condition, msg) {
  /* istanbul ignore if */
  if (!condition) {
    throw new Error(msg || "unexpected compiler condition");
  }
}

function findDir(node, name) {
  var allowEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 7
    /* DIRECTIVE */
    && (allowEmpty || p.exp) && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}

function findProp(node, name) {
  var dynamicOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 6
    /* ATTRIBUTE */
    ) {
        if (dynamicOnly) continue;

        if (p.name === name && (p.value || allowEmpty)) {
          return p;
        }
      } else if (p.name === 'bind' && (p.exp || allowEmpty) && isBindKey(p.arg, name)) {
      return p;
    }
  }
}

function isBindKey(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}

function hasDynamicKeyVBind(node) {
  return node.props.some(function (p) {
    return p.type === 7
    /* DIRECTIVE */
    && p.name === 'bind' && (!p.arg || // v-bind="obj"
    p.arg.type !== 4
    /* SIMPLE_EXPRESSION */
    || // v-bind:[_ctx.foo]
    !p.arg.isStatic);
  } // v-bind:[foo]
  );
}

function isText(node) {
  return node.type === 5
  /* INTERPOLATION */
  || node.type === 2
  /* TEXT */
  ;
}

function isVSlot(p) {
  return p.type === 7
  /* DIRECTIVE */
  && p.name === 'slot';
}

function isTemplateNode(node) {
  return node.type === 1
  /* ELEMENT */
  && node.tagType === 3
  /* TEMPLATE */
  ;
}

function isSlotOutlet(node) {
  return node.type === 1
  /* ELEMENT */
  && node.tagType === 2
  /* SLOT */
  ;
}

function injectProp(node, prop, context) {
  var propsWithInjection;
  var props = node.type === 13
  /* VNODE_CALL */
  ? node.props : node.arguments[2];

  if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14
  /* JS_CALL_EXPRESSION */
  ) {
      // merged props... add ours
      // only inject key to object literal if it's the first argument so that
      // if doesn't override user provided keys
      var first = props.arguments[0];

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15
      /* JS_OBJECT_EXPRESSION */
      ) {
          first.properties.unshift(prop);
        } else {
        if (props.callee === TO_HANDLERS) {
          // #2366
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
        } else {
          props.arguments.unshift(createObjectExpression([prop]));
        }
      }

      !propsWithInjection && (propsWithInjection = props);
    } else if (props.type === 15
  /* JS_OBJECT_EXPRESSION */
  ) {
      var alreadyExists = false; // check existing key to avoid overriding user provided keys

      if (prop.key.type === 4
      /* SIMPLE_EXPRESSION */
      ) {
          var propKeyName = prop.key.content;
          alreadyExists = props.properties.some(function (p) {
            return p.key.type === 4
            /* SIMPLE_EXPRESSION */
            && p.key.content === propKeyName;
          });
        }

      if (!alreadyExists) {
        props.properties.unshift(prop);
      }

      propsWithInjection = props;
    } else {
    // single v-bind with expression, return a merged replacement
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
  }

  if (node.type === 13
  /* VNODE_CALL */
  ) {
      node.props = propsWithInjection;
    } else {
    node.arguments[2] = propsWithInjection;
  }
}

function toValidAssetId(name, type) {
  return "_".concat(type, "_").concat(name.replace(/[^\w]/g, '_'));
} // Check if a node contains expressions that reference current context scope ids


function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
      for (var i = 0; i < node.props.length; i++) {
        var p = node.props[i];

        if (p.type === 7
        /* DIRECTIVE */
        && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 11
    /* FOR */
    :
      if (hasScopeRef(node.source, ids)) {
        return true;
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 9
    /* IF */
    :
      return node.branches.some(function (b) {
        return hasScopeRef(b, ids);
      });

    case 10
    /* IF_BRANCH */
    :
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 4
    /* SIMPLE_EXPRESSION */
    :
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];

    case 8
    /* COMPOUND_EXPRESSION */
    :
      return node.children.some(function (c) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids);
      });

    case 5
    /* INTERPOLATION */
    :
    case 12
    /* TEXT_CALL */
    :
      return hasScopeRef(node.content, ids);

    case 2
    /* TEXT */
    :
    case 3
    /* COMMENT */
    :
      return false;

    default:
      if (true) ;
      return false;
  }
}

var deprecationData = (_deprecationData = {}, _defineProperty(_deprecationData, "COMPILER_IS_ON_ELEMENT"
/* COMPILER_IS_ON_ELEMENT */
, {
  message: "Platform-native elements with \"is\" prop will no longer be " + "treated as components in Vue 3 unless the \"is\" value is explicitly " + "prefixed with \"vue:\".",
  link: "https://v3.vuejs.org/guide/migration/custom-elements-interop.html"
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_SYNC"
/* COMPILER_V_BIND_SYNC */
, {
  message: function message(key) {
    return ".sync modifier for v-bind has been removed. Use v-model with " + "argument instead. `v-bind:".concat(key, ".sync` should be changed to ") + "`v-model:".concat(key, "`.");
  },
  link: "https://v3.vuejs.org/guide/migration/v-model.html"
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_PROP"
/* COMPILER_V_BIND_PROP */
, {
  message: ".prop modifier for v-bind has been removed and no longer necessary. " + "Vue 3 will automatically set a binding as DOM property when appropriate."
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_OBJECT_ORDER"
/* COMPILER_V_BIND_OBJECT_ORDER */
, {
  message: "v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript " + "object spread: it will now overwrite an existing non-mergeable attribute " + "that appears before v-bind in the case of conflict. " + "To retain 2.x behavior, move v-bind to make it the first attribute. " + "You can also suppress this warning if the usage is intended.",
  link: "https://v3.vuejs.org/guide/migration/v-bind.html"
}), _defineProperty(_deprecationData, "COMPILER_V_ON_NATIVE"
/* COMPILER_V_ON_NATIVE */
, {
  message: ".native modifier for v-on has been removed as is no longer necessary.",
  link: "https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html"
}), _defineProperty(_deprecationData, "COMPILER_V_IF_V_FOR_PRECEDENCE"
/* COMPILER_V_IF_V_FOR_PRECEDENCE */
, {
  message: "v-if / v-for precedence when used on the same element has changed " + "in Vue 3: v-if now takes higher precedence and will no longer have " + "access to v-for scope variables. It is best to avoid the ambiguity " + "with <template> tags or use a computed property that filters v-for " + "data source.",
  link: "https://v3.vuejs.org/guide/migration/v-if-v-for.html"
}), _defineProperty(_deprecationData, "COMPILER_V_FOR_REF"
/* COMPILER_V_FOR_REF */
, {
  message: "Ref usage on v-for no longer creates array ref values in Vue 3. " + "Consider using function refs or refactor to avoid ref usage altogether.",
  link: "https://v3.vuejs.org/guide/migration/array-refs.html"
}), _defineProperty(_deprecationData, "COMPILER_NATIVE_TEMPLATE"
/* COMPILER_NATIVE_TEMPLATE */
, {
  message: "<template> with no special directives will render as a native template " + "element instead of its inner content in Vue 3."
}), _defineProperty(_deprecationData, "COMPILER_INLINE_TEMPLATE"
/* COMPILER_INLINE_TEMPLATE */
, {
  message: "\"inline-template\" has been removed in Vue 3.",
  link: "https://v3.vuejs.org/guide/migration/inline-template-attribute.html"
}), _defineProperty(_deprecationData, "COMPILER_FILTER"
/* COMPILER_FILTERS */
, {
  message: "filters have been removed in Vue 3. " + "The \"|\" symbol will be treated as native JavaScript bitwise OR operator. " + "Use method calls or computed properties instead.",
  link: "https://v3.vuejs.org/guide/migration/filters.html"
}), _deprecationData);

function getCompatValue(key, context) {
  var config = context.options ? context.options.compatConfig : context.compatConfig;
  var value = config && config[key];

  if (key === 'MODE') {
    return value || 3; // compiler defaults to v3 behavior
  } else {
    return value;
  }
}

function isCompatEnabled(key, context) {
  var mode = getCompatValue('MODE', context);
  var value = getCompatValue(key, context); // in v3 mode, only enable if explicitly set to true
  // otherwise enable for any non-false value

  return mode === 3 ? value === true : value !== false;
}

function checkCompatEnabled(key, context, loc) {
  var enabled = isCompatEnabled(key, context);

  if ( true && enabled) {
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    warnDeprecation.apply(void 0, [key, context, loc].concat(args));
  }

  return enabled;
}

function warnDeprecation(key, context, loc) {
  var val = getCompatValue(key, context);

  if (val === 'suppress-warning') {
    return;
  }

  var _deprecationData$key = deprecationData[key],
      message = _deprecationData$key.message,
      link = _deprecationData$key.link;

  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  var msg = "(deprecation ".concat(key, ") ").concat(typeof message === 'function' ? message.apply(void 0, args) : message).concat(link ? "\n  Details: ".concat(link) : "");
  var err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
} // The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.


var decodeRE = /&(gt|lt|amp|apos|quot);/g;
var decodeMap = {
  gt: '>',
  lt: '<',
  amp: '&',
  apos: "'",
  quot: '"'
};
var defaultParserOptions = {
  delimiters: ["{{", "}}"],
  getNamespace: function getNamespace() {
    return 0;
  }
  /* HTML */
  ,
  getTextMode: function getTextMode() {
    return 0;
  }
  /* DATA */
  ,
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  decodeEntities: function decodeEntities(rawText) {
    return rawText.replace(decodeRE, function (_, p1) {
      return decodeMap[p1];
    });
  },
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: false
};

function baseParse(content) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = createParserContext(content, options);
  var start = getCursor(context);
  return createRoot(parseChildren(context, 0
  /* DATA */
  , []), getSelection(context, start));
}

function createParserContext(content, rawOptions) {
  var options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);

  for (var key in rawOptions) {
    // @ts-ignore
    options[key] = rawOptions[key] || defaultParserOptions[key];
  }

  return {
    options: options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}

function parseChildren(context, mode, ancestors) {
  var parent = last(ancestors);
  var ns = parent ? parent.ns : 0
  /* HTML */
  ;
  var nodes = [];

  while (!isEnd(context, mode, ancestors)) {
    var s = context.source;
    var node = undefined;

    if (mode === 0
    /* DATA */
    || mode === 1
    /* RCDATA */
    ) {
        if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
          // '{{'
          node = parseInterpolation(context, mode);
        } else if (mode === 0
        /* DATA */
        && s[0] === '<') {
          // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
          if (s.length === 1) {
            emitError(context, 5
            /* EOF_BEFORE_TAG_NAME */
            , 1);
          } else if (s[1] === '!') {
            // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
            if (startsWith(s, '<!--')) {
              node = parseComment(context);
            } else if (startsWith(s, '<!DOCTYPE')) {
              // Ignore DOCTYPE by a limitation.
              node = parseBogusComment(context);
            } else if (startsWith(s, '<![CDATA[')) {
              if (ns !== 0
              /* HTML */
              ) {
                  node = parseCDATA(context, ancestors);
                } else {
                emitError(context, 1
                /* CDATA_IN_HTML_CONTENT */
                );
                node = parseBogusComment(context);
              }
            } else {
              emitError(context, 11
              /* INCORRECTLY_OPENED_COMMENT */
              );
              node = parseBogusComment(context);
            }
          } else if (s[1] === '/') {
            // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
            if (s.length === 2) {
              emitError(context, 5
              /* EOF_BEFORE_TAG_NAME */
              , 2);
            } else if (s[2] === '>') {
              emitError(context, 14
              /* MISSING_END_TAG_NAME */
              , 2);
              advanceBy(context, 3);
              continue;
            } else if (/[a-z]/i.test(s[2])) {
              emitError(context, 23
              /* X_INVALID_END_TAG */
              );
              parseTag(context, 1
              /* End */
              , parent);
              continue;
            } else {
              emitError(context, 12
              /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
              , 2);
              node = parseBogusComment(context);
            }
          } else if (/[a-z]/i.test(s[1])) {
            node = parseElement(context, ancestors); // 2.x <template> with no directive compat

            if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE"
            /* COMPILER_NATIVE_TEMPLATE */
            , context) && node && node.tag === 'template' && !node.props.some(function (p) {
              return p.type === 7
              /* DIRECTIVE */
              && isSpecialTemplateDirective(p.name);
            })) {
               true && warnDeprecation("COMPILER_NATIVE_TEMPLATE"
              /* COMPILER_NATIVE_TEMPLATE */
              , context, node.loc);
              node = node.children;
            }
          } else if (s[1] === '?') {
            emitError(context, 21
            /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
            , 1);
            node = parseBogusComment(context);
          } else {
            emitError(context, 12
            /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
            , 1);
          }
        }
      }

    if (!node) {
      node = parseText(context, mode);
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      for (var i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  } // Whitespace handling strategy like v2


  var removedWhitespace = false;

  if (mode !== 2
  /* RAWTEXT */
  && mode !== 1
  /* RCDATA */
  ) {
      var preserve = context.options.whitespace === 'preserve';

      for (var _i = 0; _i < nodes.length; _i++) {
        var _node2 = nodes[_i];

        if (!context.inPre && _node2.type === 2
        /* TEXT */
        ) {
            if (!/[^\t\r\n\f ]/.test(_node2.content)) {
              var prev = nodes[_i - 1];
              var next = nodes[_i + 1]; // Remove if:
              // - the whitespace is the first or last node, or:
              // - (condense mode) the whitespace is adjacent to a comment, or:
              // - (condense mode) the whitespace is between two elements AND contains newline

              if (!prev || !next || !preserve && (prev.type === 3
              /* COMMENT */
              || next.type === 3
              /* COMMENT */
              || prev.type === 1
              /* ELEMENT */
              && next.type === 1
              /* ELEMENT */
              && /[\r\n]/.test(_node2.content))) {
                removedWhitespace = true;
                nodes[_i] = null;
              } else {
                // Otherwise, the whitespace is condensed into a single space
                _node2.content = ' ';
              }
            } else if (!preserve) {
              // in condense mode, consecutive whitespaces in text are condensed
              // down to a single space.
              _node2.content = _node2.content.replace(/[\t\r\n\f ]+/g, ' ');
            }
          } // also remove comment nodes in prod by default


        if (false) {}
      }

      if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
        // remove leading newline per html spec
        // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
        var first = nodes[0];

        if (first && first.type === 2
        /* TEXT */
        ) {
            first.content = first.content.replace(/^\r?\n/, '');
          }
      }
    }

  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}

function pushNode(nodes, node) {
  if (node.type === 2
  /* TEXT */
  ) {
      var prev = last(nodes); // Merge if both this and the previous node are text and those are
      // consecutive. This happens for cases like "a < b".

      if (prev && prev.type === 2
      /* TEXT */
      && prev.loc.end.offset === node.loc.start.offset) {
        prev.content += node.content;
        prev.loc.end = node.loc.end;
        prev.loc.source += node.loc.source;
        return;
      }
    }

  nodes.push(node);
}

function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  var nodes = parseChildren(context, 3
  /* CDATA */
  , ancestors);

  if (context.source.length === 0) {
    emitError(context, 6
    /* EOF_IN_CDATA */
    );
  } else {
    advanceBy(context, 3);
  }

  return nodes;
}

function parseComment(context) {
  var start = getCursor(context);
  var content; // Regular comment.

  var match = /--(\!)?>/.exec(context.source);

  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7
    /* EOF_IN_COMMENT */
    );
  } else {
    if (match.index <= 3) {
      emitError(context, 0
      /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
      );
    }

    if (match[1]) {
      emitError(context, 10
      /* INCORRECTLY_CLOSED_COMMENT */
      );
    }

    content = context.source.slice(4, match.index); // Advancing with reporting nested comments.

    var s = context.source.slice(0, match.index);
    var prevIndex = 1,
        nestedIndex = 0;

    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);

      if (nestedIndex + 4 < s.length) {
        emitError(context, 16
        /* NESTED_COMMENT */
        );
      }

      prevIndex = nestedIndex + 1;
    }

    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }

  return {
    type: 3
    /* COMMENT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}

function parseBogusComment(context) {
  var start = getCursor(context);
  var contentStart = context.source[1] === '?' ? 1 : 2;
  var content;
  var closeIndex = context.source.indexOf('>');

  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }

  return {
    type: 3
    /* COMMENT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}

function parseElement(context, ancestors) {
  // Start tag.
  var wasInPre = context.inPre;
  var wasInVPre = context.inVPre;
  var parent = last(ancestors);
  var element = parseTag(context, 0
  /* Start */
  , parent);
  var isPreBoundary = context.inPre && !wasInPre;
  var isVPreBoundary = context.inVPre && !wasInVPre;

  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    return element;
  } // Children.


  ancestors.push(element);
  var mode = context.options.getTextMode(element, parent);
  var children = parseChildren(context, mode, ancestors);
  ancestors.pop(); // 2.x inline-template compat

  {
    var inlineTemplateProp = element.props.find(function (p) {
      return p.type === 6
      /* ATTRIBUTE */
      && p.name === 'inline-template';
    });

    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE"
    /* COMPILER_INLINE_TEMPLATE */
    , context, inlineTemplateProp.loc)) {
      var loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2
        /* TEXT */
        ,
        content: loc.source,
        loc: loc
      };
    }
  }
  element.children = children; // End tag.

  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1
    /* End */
    , parent);
  } else {
    emitError(context, 24
    /* X_MISSING_END_TAG */
    , 0, element.loc.start);

    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
      var first = children[0];

      if (first && startsWith(first.loc.source, '<!--')) {
        emitError(context, 8
        /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
        );
      }
    }
  }

  element.loc = getSelection(context, element.loc.start);

  if (isPreBoundary) {
    context.inPre = false;
  }

  if (isVPreBoundary) {
    context.inVPre = false;
  }

  return element;
}

var isSpecialTemplateDirective = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)("if,else,else-if,for,slot");

function parseTag(context, type, parent) {
  // Tag open.
  var start = getCursor(context);
  var match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  var tag = match[1];
  var ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context); // save current state in case we need to re-parse attributes with v-pre

  var cursor = getCursor(context);
  var currentSource = context.source; // Attributes.

  var props = parseAttributes(context, type); // check <pre> tag

  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  } // check v-pre


  if (type === 0
  /* Start */
  && !context.inVPre && props.some(function (p) {
    return p.type === 7
    /* DIRECTIVE */
    && p.name === 'pre';
  })) {
    context.inVPre = true; // reset context

    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
    context.source = currentSource; // re-parse attrs and filter out v-pre itself

    props = parseAttributes(context, type).filter(function (p) {
      return p.name !== 'v-pre';
    });
  } // Tag close.


  var isSelfClosing = false;

  if (context.source.length === 0) {
    emitError(context, 9
    /* EOF_IN_TAG */
    );
  } else {
    isSelfClosing = startsWith(context.source, '/>');

    if (type === 1
    /* End */
    && isSelfClosing) {
      emitError(context, 4
      /* END_TAG_WITH_TRAILING_SOLIDUS */
      );
    }

    advanceBy(context, isSelfClosing ? 2 : 1);
  }

  if (type === 1
  /* End */
  ) {
      return;
    } // 2.x deprecation checks


  if ( true && isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE"
  /* COMPILER_V_IF_V_FOR_PRECEDENCE */
  , context)) {
    var hasIf = false;
    var hasFor = false;

    for (var i = 0; i < props.length; i++) {
      var p = props[i];

      if (p.type === 7
      /* DIRECTIVE */
      ) {
          if (p.name === 'if') {
            hasIf = true;
          } else if (p.name === 'for') {
            hasFor = true;
          }
        }

      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE"
        /* COMPILER_V_IF_V_FOR_PRECEDENCE */
        , context, getSelection(context, start));
      }
    }
  }

  var tagType = 0
  /* ELEMENT */
  ;
  var options = context.options;

  if (!context.inVPre && !options.isCustomElement(tag)) {
    var hasVIs = props.some(function (p) {
      if (p.name !== 'is') return; // v-is="xxx" (TODO: deprecate)

      if (p.type === 7
      /* DIRECTIVE */
      ) {
          return true;
        } // is="vue:xxx"


      if (p.value && p.value.content.startsWith('vue:')) {
        return true;
      } // in compat mode, any is usage is considered a component


      if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT"
      /* COMPILER_IS_ON_ELEMENT */
      , context, p.loc)) {
        return true;
      }
    });

    if (options.isNativeTag && !hasVIs) {
      if (!options.isNativeTag(tag)) tagType = 1
      /* COMPONENT */
      ;
    } else if (hasVIs || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || /^[A-Z]/.test(tag) || tag === 'component') {
      tagType = 1
      /* COMPONENT */
      ;
    }

    if (tag === 'slot') {
      tagType = 2
      /* SLOT */
      ;
    } else if (tag === 'template' && props.some(function (p) {
      return p.type === 7
      /* DIRECTIVE */
      && isSpecialTemplateDirective(p.name);
    })) {
      tagType = 3
      /* TEMPLATE */
      ;
    }
  }

  return {
    type: 1
    /* ELEMENT */
    ,
    ns: ns,
    tag: tag,
    tagType: tagType,
    props: props,
    isSelfClosing: isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined // to be created during transform phase

  };
}

function parseAttributes(context, type) {
  var props = [];
  var attributeNames = new Set();

  while (context.source.length > 0 && !startsWith(context.source, '>') && !startsWith(context.source, '/>')) {
    if (startsWith(context.source, '/')) {
      emitError(context, 22
      /* UNEXPECTED_SOLIDUS_IN_TAG */
      );
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }

    if (type === 1
    /* End */
    ) {
        emitError(context, 3
        /* END_TAG_WITH_ATTRIBUTES */
        );
      }

    var attr = parseAttribute(context, attributeNames);

    if (type === 0
    /* Start */
    ) {
        props.push(attr);
      }

    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15
      /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
      );
    }

    advanceSpaces(context);
  }

  return props;
}

function parseAttribute(context, nameSet) {
  // Name.
  var start = getCursor(context);
  var match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  var name = match[0];

  if (nameSet.has(name)) {
    emitError(context, 2
    /* DUPLICATE_ATTRIBUTE */
    );
  }

  nameSet.add(name);

  if (name[0] === '=') {
    emitError(context, 19
    /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
    );
  }

  {
    var pattern = /["'<]/g;
    var m;

    while (m = pattern.exec(name)) {
      emitError(context, 17
      /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
      , m.index);
    }
  }
  advanceBy(context, name.length); // Value

  var value = undefined;

  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);

    if (!value) {
      emitError(context, 13
      /* MISSING_ATTRIBUTE_VALUE */
      );
    }
  }

  var loc = getSelection(context, start);

  if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
    var _match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);

    var dirName = _match[1] || (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');
    var arg;

    if (_match[2]) {
      var isSlot = dirName === 'slot';
      var startOffset = name.lastIndexOf(_match[2]);

      var _loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + _match[2].length + (isSlot && _match[3] || '').length));

      var content = _match[2];
      var isStatic = true;

      if (content.startsWith('[')) {
        isStatic = false;

        if (!content.endsWith(']')) {
          emitError(context, 26
          /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
          );
        }

        content = content.substr(1, content.length - 2);
      } else if (isSlot) {
        // #1241 special case for v-slot: vuetify relies extensively on slot
        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
        // supports such usage so we are keeping it consistent with 2.x.
        content += _match[3] || '';
      }

      arg = {
        type: 4
        /* SIMPLE_EXPRESSION */
        ,
        content: content,
        isStatic: isStatic,
        constType: isStatic ? 3
        /* CAN_STRINGIFY */
        : 0
        /* NOT_CONSTANT */
        ,
        loc: _loc
      };
    }

    if (value && value.isQuoted) {
      var valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }

    var modifiers = _match[3] ? _match[3].substr(1).split('.') : []; // 2.x compat v-bind:foo.sync -> v-model:foo

    if (dirName === 'bind' && arg) {
      if (modifiers.includes('sync') && checkCompatEnabled("COMPILER_V_BIND_SYNC"
      /* COMPILER_V_BIND_SYNC */
      , context, loc, arg.loc.source)) {
        dirName = 'model';
        modifiers.splice(modifiers.indexOf('sync'), 1);
      }

      if ( true && modifiers.includes('prop')) {
        checkCompatEnabled("COMPILER_V_BIND_PROP"
        /* COMPILER_V_BIND_PROP */
        , context, loc);
      }
    }

    return {
      type: 7
      /* DIRECTIVE */
      ,
      name: dirName,
      exp: value && {
        type: 4
        /* SIMPLE_EXPRESSION */
        ,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0
        /* NOT_CONSTANT */
        ,
        loc: value.loc
      },
      arg: arg,
      modifiers: modifiers,
      loc: loc
    };
  }

  return {
    type: 6
    /* ATTRIBUTE */
    ,
    name: name,
    value: value && {
      type: 2
      /* TEXT */
      ,
      content: value.content,
      loc: value.loc
    },
    loc: loc
  };
}

function parseAttributeValue(context) {
  var start = getCursor(context);
  var content;
  var quote = context.source[0];
  var isQuoted = quote === "\"" || quote === "'";

  if (isQuoted) {
    // Quoted value.
    advanceBy(context, 1);
    var endIndex = context.source.indexOf(quote);

    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4
      /* ATTRIBUTE_VALUE */
      );
    } else {
      content = parseTextData(context, endIndex, 4
      /* ATTRIBUTE_VALUE */
      );
      advanceBy(context, 1);
    }
  } else {
    // Unquoted
    var match = /^[^\t\r\n\f >]+/.exec(context.source);

    if (!match) {
      return undefined;
    }

    var unexpectedChars = /["'<=`]/g;
    var m;

    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18
      /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
      , m.index);
    }

    content = parseTextData(context, match[0].length, 4
    /* ATTRIBUTE_VALUE */
    );
  }

  return {
    content: content,
    isQuoted: isQuoted,
    loc: getSelection(context, start)
  };
}

function parseInterpolation(context, mode) {
  var _context$options$deli = _slicedToArray(context.options.delimiters, 2),
      open = _context$options$deli[0],
      close = _context$options$deli[1];

  var closeIndex = context.source.indexOf(close, open.length);

  if (closeIndex === -1) {
    emitError(context, 25
    /* X_MISSING_INTERPOLATION_END */
    );
    return undefined;
  }

  var start = getCursor(context);
  advanceBy(context, open.length);
  var innerStart = getCursor(context);
  var innerEnd = getCursor(context);
  var rawContentLength = closeIndex - open.length;
  var rawContent = context.source.slice(0, rawContentLength);
  var preTrimContent = parseTextData(context, rawContentLength, mode);
  var content = preTrimContent.trim();
  var startOffset = preTrimContent.indexOf(content);

  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }

  var endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5
    /* INTERPOLATION */
    ,
    content: {
      type: 4
      /* SIMPLE_EXPRESSION */
      ,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0
      /* NOT_CONSTANT */
      ,
      content: content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}

function parseText(context, mode) {
  var endTokens = ['<', context.options.delimiters[0]];

  if (mode === 3
  /* CDATA */
  ) {
      endTokens.push(']]>');
    }

  var endIndex = context.source.length;

  for (var i = 0; i < endTokens.length; i++) {
    var index = context.source.indexOf(endTokens[i], 1);

    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }

  var start = getCursor(context);
  var content = parseTextData(context, endIndex, mode);
  return {
    type: 2
    /* TEXT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */


function parseTextData(context, length, mode) {
  var rawText = context.source.slice(0, length);
  advanceBy(context, length);

  if (mode === 2
  /* RAWTEXT */
  || mode === 3
  /* CDATA */
  || rawText.indexOf('&') === -1) {
    return rawText;
  } else {
    // DATA or RCDATA containing "&"". Entity decoding required.
    return context.options.decodeEntities(rawText, mode === 4
    /* ATTRIBUTE_VALUE */
    );
  }
}

function getCursor(context) {
  var column = context.column,
      line = context.line,
      offset = context.offset;
  return {
    column: column,
    line: line,
    offset: offset
  };
}

function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start: start,
    end: end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}

function last(xs) {
  return xs[xs.length - 1];
}

function startsWith(source, searchString) {
  return source.startsWith(searchString);
}

function advanceBy(context, numberOfCharacters) {
  var source = context.source;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}

function advanceSpaces(context) {
  var match = /^[\t\r\n\f ]+/.exec(context.source);

  if (match) {
    advanceBy(context, match[0].length);
  }
}

function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}

function emitError(context, code, offset) {
  var loc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCursor(context);

  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }

  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ''
  }));
}

function isEnd(context, mode, ancestors) {
  var s = context.source;

  switch (mode) {
    case 0
    /* DATA */
    :
      if (startsWith(s, '</')) {
        // TODO: probably bad performance
        for (var i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }

      break;

    case 1
    /* RCDATA */
    :
    case 2
    /* RAWTEXT */
    :
      {
        var parent = last(ancestors);

        if (parent && startsWithEndTagOpen(s, parent.tag)) {
          return true;
        }

        break;
      }

    case 3
    /* CDATA */
    :
      if (startsWith(s, ']]>')) {
        return true;
      }

      break;
  }

  return !s;
}

function startsWithEndTagOpen(source, tag) {
  return startsWith(source, '</') && source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || '>');
}

function hoistStatic(root, context) {
  walk(root, context, // Root node is unfortunately non-hoistable due to potential parent
  // fallthrough attributes.
  isSingleElementRoot(root, root.children[0]));
}

function isSingleElementRoot(root, child) {
  var children = root.children;
  return children.length === 1 && child.type === 1
  /* ELEMENT */
  && !isSlotOutlet(child);
}

function walk(node, context) {
  var doNotHoistNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var hasHoistedNode = false; // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces
  // static bindings with expressions. These expressions are guaranteed to be
  // constant so they are still eligible for hoisting, but they are only
  // available at runtime and therefore cannot be evaluated ahead of time.
  // This is only a concern for pre-stringification (via transformHoist by
  // @vue/compiler-dom), but doing it here allows us to perform only one full
  // walk of the AST and allow `stringifyStatic` to stop walking as soon as its
  // stringficiation threshold is met.

  var canStringify = true;
  var children = node.children;

  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // only plain elements & text calls are eligible for hoisting.

    if (child.type === 1
    /* ELEMENT */
    && child.tagType === 0
    /* ELEMENT */
    ) {
        var constantType = doNotHoistNode ? 0
        /* NOT_CONSTANT */
        : getConstantType(child, context);

        if (constantType > 0
        /* NOT_CONSTANT */
        ) {
            if (constantType < 3
            /* CAN_STRINGIFY */
            ) {
                canStringify = false;
              }

            if (constantType >= 2
            /* CAN_HOIST */
            ) {
                child.codegenNode.patchFlag = -1
                /* HOISTED */
                + ( true ? " /* HOISTED */" : 0);
                child.codegenNode = context.hoist(child.codegenNode);
                hasHoistedNode = true;
                continue;
              }
          } else {
          // node may contain dynamic children, but its props may be eligible for
          // hoisting.
          var codegenNode = child.codegenNode;

          if (codegenNode.type === 13
          /* VNODE_CALL */
          ) {
              var flag = getPatchFlag(codegenNode);

              if ((!flag || flag === 512
              /* NEED_PATCH */
              || flag === 1
              /* TEXT */
              ) && getGeneratedPropsConstantType(child, context) >= 2
              /* CAN_HOIST */
              ) {
                  var props = getNodeProps(child);

                  if (props) {
                    codegenNode.props = context.hoist(props);
                  }
                }
            }
        }
      } else if (child.type === 12
    /* TEXT_CALL */
    ) {
        var contentType = getConstantType(child.content, context);

        if (contentType > 0) {
          if (contentType < 3
          /* CAN_STRINGIFY */
          ) {
              canStringify = false;
            }

          if (contentType >= 2
          /* CAN_HOIST */
          ) {
              child.codegenNode = context.hoist(child.codegenNode);
              hasHoistedNode = true;
            }
        }
      } // walk further


    if (child.type === 1
    /* ELEMENT */
    ) {
        var isComponent = child.tagType === 1
        /* COMPONENT */
        ;

        if (isComponent) {
          context.scopes.vSlot++;
        }

        walk(child, context);

        if (isComponent) {
          context.scopes.vSlot--;
        }
      } else if (child.type === 11
    /* FOR */
    ) {
        // Do not hoist v-for single child because it has to be a block
        walk(child, context, child.children.length === 1);
      } else if (child.type === 9
    /* IF */
    ) {
        for (var _i2 = 0; _i2 < child.branches.length; _i2++) {
          // Do not hoist v-if single child because it has to be a block
          walk(child.branches[_i2], context, child.branches[_i2].children.length === 1);
        }
      }
  }

  if (canStringify && hasHoistedNode && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}

function getConstantType(node, context) {
  var constantCache = context.constantCache;

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
      if (node.tagType !== 0
      /* ELEMENT */
      ) {
          return 0
          /* NOT_CONSTANT */
          ;
        }

      var cached = constantCache.get(node);

      if (cached !== undefined) {
        return cached;
      }

      var codegenNode = node.codegenNode;

      if (codegenNode.type !== 13
      /* VNODE_CALL */
      ) {
          return 0
          /* NOT_CONSTANT */
          ;
        }

      var flag = getPatchFlag(codegenNode);

      if (!flag) {
        var _returnType = 3
        /* CAN_STRINGIFY */
        ; // Element itself has no patch flag. However we still need to check:
        // 1. Even for a node with no patch flag, it is possible for it to contain
        // non-hoistable expressions that refers to scope variables, e.g. compiler
        // injected keys or cached event handlers. Therefore we need to always
        // check the codegenNode's props to be sure.

        var generatedPropsType = getGeneratedPropsConstantType(node, context);

        if (generatedPropsType === 0
        /* NOT_CONSTANT */
        ) {
            constantCache.set(node, 0
            /* NOT_CONSTANT */
            );
            return 0
            /* NOT_CONSTANT */
            ;
          }

        if (generatedPropsType < _returnType) {
          _returnType = generatedPropsType;
        } // 2. its children.


        for (var i = 0; i < node.children.length; i++) {
          var childType = getConstantType(node.children[i], context);

          if (childType === 0
          /* NOT_CONSTANT */
          ) {
              constantCache.set(node, 0
              /* NOT_CONSTANT */
              );
              return 0
              /* NOT_CONSTANT */
              ;
            }

          if (childType < _returnType) {
            _returnType = childType;
          }
        } // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
        // type, check if any of the props can cause the type to be lowered
        // we can skip can_patch because it's guaranteed by the absence of a
        // patchFlag.


        if (_returnType > 1
        /* CAN_SKIP_PATCH */
        ) {
            for (var _i3 = 0; _i3 < node.props.length; _i3++) {
              var p = node.props[_i3];

              if (p.type === 7
              /* DIRECTIVE */
              && p.name === 'bind' && p.exp) {
                var expType = getConstantType(p.exp, context);

                if (expType === 0
                /* NOT_CONSTANT */
                ) {
                    constantCache.set(node, 0
                    /* NOT_CONSTANT */
                    );
                    return 0
                    /* NOT_CONSTANT */
                    ;
                  }

                if (expType < _returnType) {
                  _returnType = expType;
                }
              }
            }
          } // only svg/foreignObject could be block here, however if they are
        // static then they don't need to be blocks since there will be no
        // nested updates.


        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(CREATE_BLOCK);
          codegenNode.isBlock = false;
          context.helper(CREATE_VNODE);
        }

        constantCache.set(node, _returnType);
        return _returnType;
      } else {
        constantCache.set(node, 0
        /* NOT_CONSTANT */
        );
        return 0
        /* NOT_CONSTANT */
        ;
      }

    case 2
    /* TEXT */
    :
    case 3
    /* COMMENT */
    :
      return 3
      /* CAN_STRINGIFY */
      ;

    case 9
    /* IF */
    :
    case 11
    /* FOR */
    :
    case 10
    /* IF_BRANCH */
    :
      return 0
      /* NOT_CONSTANT */
      ;

    case 5
    /* INTERPOLATION */
    :
    case 12
    /* TEXT_CALL */
    :
      return getConstantType(node.content, context);

    case 4
    /* SIMPLE_EXPRESSION */
    :
      return node.constType;

    case 8
    /* COMPOUND_EXPRESSION */
    :
      var returnType = 3
      /* CAN_STRINGIFY */
      ;

      for (var _i4 = 0; _i4 < node.children.length; _i4++) {
        var child = node.children[_i4];

        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
          continue;
        }

        var _childType = getConstantType(child, context);

        if (_childType === 0
        /* NOT_CONSTANT */
        ) {
            return 0
            /* NOT_CONSTANT */
            ;
          } else if (_childType < returnType) {
          returnType = _childType;
        }
      }

      return returnType;

    default:
      if (true) ;
      return 0
      /* NOT_CONSTANT */
      ;
  }
}

function getGeneratedPropsConstantType(node, context) {
  var returnType = 3
  /* CAN_STRINGIFY */
  ;
  var props = getNodeProps(node);

  if (props && props.type === 15
  /* JS_OBJECT_EXPRESSION */
  ) {
      var properties = props.properties;

      for (var i = 0; i < properties.length; i++) {
        var _properties$i = properties[i],
            key = _properties$i.key,
            value = _properties$i.value;
        var keyType = getConstantType(key, context);

        if (keyType === 0
        /* NOT_CONSTANT */
        ) {
            return keyType;
          }

        if (keyType < returnType) {
          returnType = keyType;
        }

        if (value.type !== 4
        /* SIMPLE_EXPRESSION */
        ) {
            return 0
            /* NOT_CONSTANT */
            ;
          }

        var valueType = getConstantType(value, context);

        if (valueType === 0
        /* NOT_CONSTANT */
        ) {
            return valueType;
          }

        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }

  return returnType;
}

function getNodeProps(node) {
  var codegenNode = node.codegenNode;

  if (codegenNode.type === 13
  /* VNODE_CALL */
  ) {
      return codegenNode.props;
    }
}

function getPatchFlag(node) {
  var flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, _ref) {
  var _ref$filename = _ref.filename,
      filename = _ref$filename === void 0 ? '' : _ref$filename,
      _ref$prefixIdentifier = _ref.prefixIdentifiers,
      prefixIdentifiers = _ref$prefixIdentifier === void 0 ? false : _ref$prefixIdentifier,
      _ref$hoistStatic = _ref.hoistStatic,
      hoistStatic = _ref$hoistStatic === void 0 ? false : _ref$hoistStatic,
      _ref$cacheHandlers = _ref.cacheHandlers,
      cacheHandlers = _ref$cacheHandlers === void 0 ? false : _ref$cacheHandlers,
      _ref$nodeTransforms = _ref.nodeTransforms,
      nodeTransforms = _ref$nodeTransforms === void 0 ? [] : _ref$nodeTransforms,
      _ref$directiveTransfo = _ref.directiveTransforms,
      directiveTransforms = _ref$directiveTransfo === void 0 ? {} : _ref$directiveTransfo,
      _ref$transformHoist = _ref.transformHoist,
      transformHoist = _ref$transformHoist === void 0 ? null : _ref$transformHoist,
      _ref$isBuiltInCompone = _ref.isBuiltInComponent,
      isBuiltInComponent = _ref$isBuiltInCompone === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP : _ref$isBuiltInCompone,
      _ref$isCustomElement = _ref.isCustomElement,
      isCustomElement = _ref$isCustomElement === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP : _ref$isCustomElement,
      _ref$expressionPlugin = _ref.expressionPlugins,
      expressionPlugins = _ref$expressionPlugin === void 0 ? [] : _ref$expressionPlugin,
      _ref$scopeId = _ref.scopeId,
      scopeId = _ref$scopeId === void 0 ? null : _ref$scopeId,
      _ref$slotted = _ref.slotted,
      slotted = _ref$slotted === void 0 ? true : _ref$slotted,
      _ref$ssr = _ref.ssr,
      ssr = _ref$ssr === void 0 ? false : _ref$ssr,
      _ref$ssrCssVars = _ref.ssrCssVars,
      ssrCssVars = _ref$ssrCssVars === void 0 ? "" : _ref$ssrCssVars,
      _ref$bindingMetadata = _ref.bindingMetadata,
      bindingMetadata = _ref$bindingMetadata === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ : _ref$bindingMetadata,
      _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      _ref$isTS = _ref.isTS,
      isTS = _ref$isTS === void 0 ? false : _ref$isTS,
      _ref$onError = _ref.onError,
      onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,
      _ref$onWarn = _ref.onWarn,
      onWarn = _ref$onWarn === void 0 ? defaultOnWarn : _ref$onWarn,
      compatConfig = _ref.compatConfig;
  var nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
  var context = {
    // options
    selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
    prefixIdentifiers: prefixIdentifiers,
    hoistStatic: hoistStatic,
    cacheHandlers: cacheHandlers,
    nodeTransforms: nodeTransforms,
    directiveTransforms: directiveTransforms,
    transformHoist: transformHoist,
    isBuiltInComponent: isBuiltInComponent,
    isCustomElement: isCustomElement,
    expressionPlugins: expressionPlugins,
    scopeId: scopeId,
    slotted: slotted,
    ssr: ssr,
    ssrCssVars: ssrCssVars,
    bindingMetadata: bindingMetadata,
    inline: inline,
    isTS: isTS,
    onError: onError,
    onWarn: onWarn,
    compatConfig: compatConfig,
    // state
    root: root,
    helpers: new Map(),
    components: new Set(),
    directives: new Set(),
    hoists: [],
    imports: [],
    constantCache: new Map(),
    temps: 0,
    cached: 0,
    identifiers: Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    // methods
    helper: function helper(name) {
      var count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper: function removeHelper(name) {
      var count = context.helpers.get(name);

      if (count) {
        var currentCount = count - 1;

        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString: function helperString(name) {
      return "_".concat(helperNameMap[context.helper(name)]);
    },
    replaceNode: function replaceNode(node) {
      /* istanbul ignore if */
      if (true) {
        if (!context.currentNode) {
          throw new Error("Node being replaced is already removed.");
        }

        if (!context.parent) {
          throw new Error("Cannot replace root node.");
        }
      }

      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode: function removeNode(node) {
      if ( true && !context.parent) {
        throw new Error("Cannot remove root node.");
      }

      var list = context.parent.children;
      var removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      /* istanbul ignore if */

      if ( true && removalIndex < 0) {
        throw new Error("node being removed is not a child of current parent");
      }

      if (!node || node === context.currentNode) {
        // current node removed
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        // sibling node removed
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }

      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: function onNodeRemoved() {},
    addIdentifiers: function addIdentifiers(exp) {},
    removeIdentifiers: function removeIdentifiers(exp) {},
    hoist: function hoist(exp) {
      context.hoists.push(exp);
      var identifier = createSimpleExpression("_hoisted_".concat(context.hoists.length), false, exp.loc, 2
      /* CAN_HOIST */
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache: function cache(exp) {
      var isVNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return createCacheExpression(++context.cached, exp, isVNode);
    }
  };
  {
    context.filters = new Set();
  }
  return context;
}

function transform(root, options) {
  var context = createTransformContext(root, options);
  traverseNode(root, context);

  if (options.hoistStatic) {
    hoistStatic(root, context);
  }

  if (!options.ssr) {
    createRootCodegen(root, context);
  } // finalize meta information


  root.helpers = _toConsumableArray(context.helpers.keys());
  root.components = _toConsumableArray(context.components);
  root.directives = _toConsumableArray(context.directives);
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = _toConsumableArray(context.filters);
  }
}

function createRootCodegen(root, context) {
  var helper = context.helper,
      removeHelper = context.removeHelper;
  var children = root.children;

  if (children.length === 1) {
    var child = children[0]; // if the single child is an element, turn it into a block.

    if (isSingleElementRoot(root, child) && child.codegenNode) {
      // single element root is never hoisted so codegenNode will never be
      // SimpleExpressionNode
      var codegenNode = child.codegenNode;

      if (codegenNode.type === 13
      /* VNODE_CALL */
      ) {
          if (!codegenNode.isBlock) {
            removeHelper(CREATE_VNODE);
            codegenNode.isBlock = true;
            helper(OPEN_BLOCK);
            helper(CREATE_BLOCK);
          }
        }

      root.codegenNode = codegenNode;
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    // root has multiple nodes - return a fragment block.
    var patchFlag = 64
    /* STABLE_FRAGMENT */
    ;
    var patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]; // check if the fragment actually contains a single valid child with
    // the rest being comments

    if ( true && children.filter(function (c) {
      return c.type !== 3;
    }
    /* COMMENT */
    ).length === 1) {
      patchFlag |= 2048
      /* DEV_ROOT_FRAGMENT */
      ;
      patchFlagText += ", ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]);
    }

    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + ( true ? " /* ".concat(patchFlagText, " */") : 0), undefined, undefined, true);
  } else ;
}

function traverseChildren(parent, context) {
  var i = 0;

  var nodeRemoved = function nodeRemoved() {
    i--;
  };

  for (; i < parent.children.length; i++) {
    var child = parent.children[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}

function traverseNode(node, context) {
  context.currentNode = node; // apply transform plugins

  var nodeTransforms = context.nodeTransforms;
  var exitFns = [];

  for (var _i5 = 0; _i5 < nodeTransforms.length; _i5++) {
    var onExit = nodeTransforms[_i5](node, context);

    if (onExit) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
        exitFns.push.apply(exitFns, _toConsumableArray(onExit));
      } else {
        exitFns.push(onExit);
      }
    }

    if (!context.currentNode) {
      // node was removed
      return;
    } else {
      // node may have been replaced
      node = context.currentNode;
    }
  }

  switch (node.type) {
    case 3
    /* COMMENT */
    :
      if (!context.ssr) {
        // inject import for the Comment symbol, which is needed for creating
        // comment nodes with `createVNode`
        context.helper(CREATE_COMMENT);
      }

      break;

    case 5
    /* INTERPOLATION */
    :
      // no need to traverse, but we need to inject toString helper
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }

      break;
    // for container types, further traverse downwards

    case 9
    /* IF */
    :
      for (var _i6 = 0; _i6 < node.branches.length; _i6++) {
        traverseNode(node.branches[_i6], context);
      }

      break;

    case 10
    /* IF_BRANCH */
    :
    case 11
    /* FOR */
    :
    case 1
    /* ELEMENT */
    :
    case 0
    /* ROOT */
    :
      traverseChildren(node, context);
      break;
  } // exit transforms


  context.currentNode = node;
  var i = exitFns.length;

  while (i--) {
    exitFns[i]();
  }
}

function createStructuralDirectiveTransform(name, fn) {
  var matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? function (n) {
    return n === name;
  } : function (n) {
    return name.test(n);
  };
  return function (node, context) {
    if (node.type === 1
    /* ELEMENT */
    ) {
        var props = node.props; // structural directive transforms are not concerned with slots
        // as they are handled separately in vSlot.ts

        if (node.tagType === 3
        /* TEMPLATE */
        && props.some(isVSlot)) {
          return;
        }

        var exitFns = [];

        for (var i = 0; i < props.length; i++) {
          var prop = props[i];

          if (prop.type === 7
          /* DIRECTIVE */
          && matches(prop.name)) {
            // structural directives are removed to avoid infinite recursion
            // also we remove them *before* applying so that it can further
            // traverse itself in case it moves the node around
            props.splice(i, 1);
            i--;
            var onExit = fn(node, prop, context);
            if (onExit) exitFns.push(onExit);
          }
        }

        return exitFns;
      }
  };
}

var PURE_ANNOTATION = "/*#__PURE__*/";

function createCodegenContext(ast, _ref2) {
  var _ref2$mode = _ref2.mode,
      mode = _ref2$mode === void 0 ? 'function' : _ref2$mode,
      _ref2$prefixIdentifie = _ref2.prefixIdentifiers,
      prefixIdentifiers = _ref2$prefixIdentifie === void 0 ? mode === 'module' : _ref2$prefixIdentifie,
      _ref2$sourceMap = _ref2.sourceMap,
      sourceMap = _ref2$sourceMap === void 0 ? false : _ref2$sourceMap,
      _ref2$filename = _ref2.filename,
      filename = _ref2$filename === void 0 ? "template.vue.html" : _ref2$filename,
      _ref2$scopeId = _ref2.scopeId,
      scopeId = _ref2$scopeId === void 0 ? null : _ref2$scopeId,
      _ref2$optimizeImports = _ref2.optimizeImports,
      optimizeImports = _ref2$optimizeImports === void 0 ? false : _ref2$optimizeImports,
      _ref2$runtimeGlobalNa = _ref2.runtimeGlobalName,
      runtimeGlobalName = _ref2$runtimeGlobalNa === void 0 ? "Vue" : _ref2$runtimeGlobalNa,
      _ref2$runtimeModuleNa = _ref2.runtimeModuleName,
      runtimeModuleName = _ref2$runtimeModuleNa === void 0 ? "vue" : _ref2$runtimeModuleNa,
      _ref2$ssr = _ref2.ssr,
      ssr = _ref2$ssr === void 0 ? false : _ref2$ssr;
  var context = {
    mode: mode,
    prefixIdentifiers: prefixIdentifiers,
    sourceMap: sourceMap,
    filename: filename,
    scopeId: scopeId,
    optimizeImports: optimizeImports,
    runtimeGlobalName: runtimeGlobalName,
    runtimeModuleName: runtimeModuleName,
    ssr: ssr,
    source: ast.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: undefined,
    helper: function helper(key) {
      return "_".concat(helperNameMap[key]);
    },
    push: function push(code, node) {
      context.code += code;
    },
    indent: function indent() {
      _newline(++context.indentLevel);
    },
    deindent: function deindent() {
      var withoutNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        _newline(--context.indentLevel);
      }
    },
    newline: function newline() {
      _newline(context.indentLevel);
    }
  };

  function _newline(n) {
    context.push('\n' + "  ".repeat(n));
  }

  return context;
}

function generate(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  var mode = context.mode,
      push = context.push,
      prefixIdentifiers = context.prefixIdentifiers,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline,
      scopeId = context.scopeId,
      ssr = context.ssr;
  var hasHelpers = ast.helpers.length > 0;
  var useWithBlock = !prefixIdentifiers && mode !== 'module'; // preambles
  // in setup() inline mode, the preamble is generated in a sub context
  // and returned separately.

  var preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  } // enter render function

  var functionName = ssr ? "ssrRender" : "render";
  var args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
  var signature = args.join(', ');
  {
    push("function ".concat(functionName, "(").concat(signature, ") {"));
  }
  indent();

  if (useWithBlock) {
    push("with (_ctx) {");
    indent(); // function mode const declarations should be inside with block
    // also they should be renamed to avoid collision with user properties

    if (hasHelpers) {
      push("const { ".concat(ast.helpers.map(function (s) {
        return "".concat(helperNameMap[s], ": _").concat(helperNameMap[s]);
      }).join(', '), " } = _Vue"));
      push("\n");
      newline();
    }
  } // generate asset resolution statements


  if (ast.components.length) {
    genAssets(ast.components, 'component', context);

    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }

  if (ast.directives.length) {
    genAssets(ast.directives, 'directive', context);

    if (ast.temps > 0) {
      newline();
    }
  }

  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, 'filter', context);
    newline();
  }

  if (ast.temps > 0) {
    push("let ");

    for (var i = 0; i < ast.temps; i++) {
      push("".concat(i > 0 ? ", " : "", "_temp").concat(i));
    }
  }

  if (ast.components.length || ast.directives.length || ast.temps) {
    push("\n");
    newline();
  } // generate the VNode tree expression


  if (!ssr) {
    push("return ");
  }

  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push("null");
  }

  if (useWithBlock) {
    deindent();
    push("}");
  }

  deindent();
  push("}");
  return {
    ast: ast,
    code: context.code,
    preamble: "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : undefined
  };
}

function genFunctionPreamble(ast, context) {
  var ssr = context.ssr,
      prefixIdentifiers = context.prefixIdentifiers,
      push = context.push,
      newline = context.newline,
      runtimeModuleName = context.runtimeModuleName,
      runtimeGlobalName = context.runtimeGlobalName;
  var VueBinding = runtimeGlobalName;

  var aliasHelper = function aliasHelper(s) {
    return "".concat(helperNameMap[s], ": _").concat(helperNameMap[s]);
  }; // Generate const declaration for helpers
  // In prefix mode, we place the const declaration at top so it's done
  // only once; But if we not prefixing, we place the declaration inside the
  // with block so it doesn't incur the `in` check cost for every helper access.


  if (ast.helpers.length > 0) {
    {
      // "with" mode.
      // save Vue in a separate variable to avoid collision
      push("const _Vue = ".concat(VueBinding, "\n")); // in "with" mode, helpers are declared inside the with block to avoid
      // has check cost, but hoists are lifted out of the function - we need
      // to provide the helper here.

      if (ast.hoists.length) {
        var staticHelpers = [CREATE_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC].filter(function (helper) {
          return ast.helpers.includes(helper);
        }).map(aliasHelper).join(', ');
        push("const { ".concat(staticHelpers, " } = _Vue\n"));
      }
    }
  }

  genHoists(ast.hoists, context);
  newline();
  push("return ");
}

function genAssets(assets, type, _ref3) {
  var helper = _ref3.helper,
      push = _ref3.push,
      newline = _ref3.newline;
  var resolver = helper(type === 'filter' ? RESOLVE_FILTER : type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);

  for (var i = 0; i < assets.length; i++) {
    var id = assets[i]; // potential component implicit self-reference inferred from SFC filename

    var maybeSelfReference = id.endsWith('__self');

    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }

    push("const ".concat(toValidAssetId(id, type), " = ").concat(resolver, "(").concat(JSON.stringify(id)).concat(maybeSelfReference ? ", true" : "", ")"));

    if (i < assets.length - 1) {
      newline();
    }
  }
}

function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }

  context.pure = true;
  var push = context.push,
      newline = context.newline,
      helper = context.helper,
      scopeId = context.scopeId,
      mode = context.mode;
  newline();
  hoists.forEach(function (exp, i) {
    if (exp) {
      push("const _hoisted_".concat(i + 1, " = "));
      genNode(exp, context);
      newline();
    }
  });
  context.pure = false;
}

function isText$1(n) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) || n.type === 4
  /* SIMPLE_EXPRESSION */
  || n.type === 2
  /* TEXT */
  || n.type === 5
  /* INTERPOLATION */
  || n.type === 8
  /* COMPOUND_EXPRESSION */
  ;
}

function genNodeListAsArray(nodes, context) {
  var multilines = nodes.length > 3 ||  true && nodes.some(function (n) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n);
  });
  context.push("[");
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push("]");
}

function genNodeList(nodes, context) {
  var multilines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var comma = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var push = context.push,
      newline = context.newline;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
      push(node);
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }

    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(',');
        newline();
      } else {
        comma && push(', ');
      }
    }
  }
}

function genNode(node, context) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
    context.push(node);
    return;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
    context.push(context.helper(node));
    return;
  }

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
    case 9
    /* IF */
    :
    case 11
    /* FOR */
    :
       true && assert(node.codegenNode != null, "Codegen node is missing for element/if/for node. " + "Apply appropriate transforms first.");
      genNode(node.codegenNode, context);
      break;

    case 2
    /* TEXT */
    :
      genText(node, context);
      break;

    case 4
    /* SIMPLE_EXPRESSION */
    :
      genExpression(node, context);
      break;

    case 5
    /* INTERPOLATION */
    :
      genInterpolation(node, context);
      break;

    case 12
    /* TEXT_CALL */
    :
      genNode(node.codegenNode, context);
      break;

    case 8
    /* COMPOUND_EXPRESSION */
    :
      genCompoundExpression(node, context);
      break;

    case 3
    /* COMMENT */
    :
      genComment(node, context);
      break;

    case 13
    /* VNODE_CALL */
    :
      genVNodeCall(node, context);
      break;

    case 14
    /* JS_CALL_EXPRESSION */
    :
      genCallExpression(node, context);
      break;

    case 15
    /* JS_OBJECT_EXPRESSION */
    :
      genObjectExpression(node, context);
      break;

    case 17
    /* JS_ARRAY_EXPRESSION */
    :
      genArrayExpression(node, context);
      break;

    case 18
    /* JS_FUNCTION_EXPRESSION */
    :
      genFunctionExpression(node, context);
      break;

    case 19
    /* JS_CONDITIONAL_EXPRESSION */
    :
      genConditionalExpression(node, context);
      break;

    case 20
    /* JS_CACHE_EXPRESSION */
    :
      genCacheExpression(node, context);
      break;
    // SSR only types

    case 21
    /* JS_BLOCK_STATEMENT */
    :
      break;

    case 22
    /* JS_TEMPLATE_LITERAL */
    :
      break;

    case 23
    /* JS_IF_STATEMENT */
    :
      break;

    case 24
    /* JS_ASSIGNMENT_EXPRESSION */
    :
      break;

    case 25
    /* JS_SEQUENCE_EXPRESSION */
    :
      break;

    case 26
    /* JS_RETURN_STATEMENT */
    :
      break;

    /* istanbul ignore next */

    case 10
    /* IF_BRANCH */
    :
      // noop
      break;

    default:
      if (true) {
        assert(false, "unhandled codegen node type: ".concat(node.type)); // make sure we exhaust all possible types

        var exhaustiveCheck = node;
        return exhaustiveCheck;
      }

  }
}

function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}

function genExpression(node, context) {
  var content = node.content,
      isStatic = node.isStatic;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}

function genInterpolation(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  if (pure) push(PURE_ANNOTATION);
  push("".concat(helper(TO_DISPLAY_STRING), "("));
  genNode(node.content, context);
  push(")");
}

function genCompoundExpression(node, context) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}

function genExpressionAsPropertyKey(node, context) {
  var push = context.push;

  if (node.type === 8
  /* COMPOUND_EXPRESSION */
  ) {
      push("[");
      genCompoundExpression(node, context);
      push("]");
    } else if (node.isStatic) {
    // only quote keys if necessary
    var text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push("[".concat(node.content, "]"), node);
  }
}

function genComment(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push("".concat(helper(CREATE_COMMENT), "(").concat(JSON.stringify(node.content), ")"), node);
}

function genVNodeCall(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  var tag = node.tag,
      props = node.props,
      children = node.children,
      patchFlag = node.patchFlag,
      dynamicProps = node.dynamicProps,
      directives = node.directives,
      isBlock = node.isBlock,
      disableTracking = node.disableTracking;

  if (directives) {
    push(helper(WITH_DIRECTIVES) + "(");
  }

  if (isBlock) {
    push("(".concat(helper(OPEN_BLOCK), "(").concat(disableTracking ? "true" : "", "), "));
  }

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + "(", node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(")");

  if (isBlock) {
    push(")");
  }

  if (directives) {
    push(", ");
    genNode(directives, context);
    push(")");
  }
}

function genNullableArgs(args) {
  var i = args.length;

  while (i--) {
    if (args[i] != null) break;
  }

  return args.slice(0, i + 1).map(function (arg) {
    return arg || "null";
  });
} // JavaScript


function genCallExpression(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  var callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push(callee + "(", node);
  genNodeList(node.arguments, context);
  push(")");
}

function genObjectExpression(node, context) {
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;
  var properties = node.properties;

  if (!properties.length) {
    push("{}", node);
    return;
  }

  var multilines = properties.length > 1 ||  true && properties.some(function (p) {
    return p.value.type !== 4;
  }
  /* SIMPLE_EXPRESSION */
  );
  push(multilines ? "{" : "{ ");
  multilines && indent();

  for (var i = 0; i < properties.length; i++) {
    var _properties$i2 = properties[i],
        key = _properties$i2.key,
        value = _properties$i2.value; // key

    genExpressionAsPropertyKey(key, context);
    push(": "); // value

    genNode(value, context);

    if (i < properties.length - 1) {
      // will only reach this if it's multilines
      push(",");
      newline();
    }
  }

  multilines && deindent();
  push(multilines ? "}" : " }");
}

function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}

function genFunctionExpression(node, context) {
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      scopeId = context.scopeId,
      mode = context.mode;
  var params = node.params,
      returns = node.returns,
      body = node.body,
      newline = node.newline,
      isSlot = node.isSlot;

  if (isSlot) {
    // wrap slot functions with owner context
    push("_".concat(helperNameMap[WITH_CTX], "("));
  }

  push("(", node);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }

  push(") => ");

  if (newline || body) {
    push("{");
    indent();
  }

  if (returns) {
    if (newline) {
      push("return ");
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }

  if (newline || body) {
    deindent();
    push("}");
  }

  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(", undefined, true");
    }

    push(")");
  }
}

function genConditionalExpression(node, context) {
  var test = node.test,
      consequent = node.consequent,
      alternate = node.alternate,
      needNewline = node.newline;
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;

  if (test.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
      var needsParens = !isSimpleIdentifier(test.content);
      needsParens && push("(");
      genExpression(test, context);
      needsParens && push(")");
    } else {
    push("(");
    genNode(test, context);
    push(")");
  }

  needNewline && indent();
  context.indentLevel++;
  needNewline || push(" ");
  push("? ");
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(" ");
  push(": ");
  var isNested = alternate.type === 19
  /* JS_CONDITIONAL_EXPRESSION */
  ;

  if (!isNested) {
    context.indentLevel++;
  }

  genNode(alternate, context);

  if (!isNested) {
    context.indentLevel--;
  }

  needNewline && deindent(true
  /* without newline */
  );
}

function genCacheExpression(node, context) {
  var push = context.push,
      helper = context.helper,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;
  push("_cache[".concat(node.index, "] || ("));

  if (node.isVNode) {
    indent();
    push("".concat(helper(SET_BLOCK_TRACKING), "(-1),"));
    newline();
  }

  push("_cache[".concat(node.index, "] = "));
  genNode(node.value, context);

  if (node.isVNode) {
    push(",");
    newline();
    push("".concat(helper(SET_BLOCK_TRACKING), "(1),"));
    newline();
    push("_cache[".concat(node.index, "]"));
    deindent();
  }

  push(")");
} // these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments,typeof,void').split(',').join('\\b|\\b') + '\\b'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */

function validateBrowserExpression(node, context) {
  var asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var exp = node.content; // empty expressions are validated per-directive since some directives
  // do allow empty expressions.

  if (!exp.trim()) {
    return;
  }

  try {
    new Function(asRawStatements ? " ".concat(exp, " ") : "return ".concat(asParams ? "(".concat(exp, ") => {}") : "(".concat(exp, ")")));
  } catch (e) {
    var message = e.message;
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      message = "avoid using JavaScript keyword as property name: \"".concat(keywordMatch[0], "\"");
    }

    context.onError(createCompilerError(43
    /* X_INVALID_EXPRESSION */
    , node.loc, undefined, message));
  }
}

var transformExpression = function transformExpression(node, context) {
  if (node.type === 5
  /* INTERPOLATION */
  ) {
      node.content = processExpression(node.content, context);
    } else if (node.type === 1
  /* ELEMENT */
  ) {
      // handle directives on element
      for (var i = 0; i < node.props.length; i++) {
        var dir = node.props[i]; // do not process for v-on & v-for since they are special handled

        if (dir.type === 7
        /* DIRECTIVE */
        && dir.name !== 'for') {
          var exp = dir.exp;
          var arg = dir.arg; // do not process exp if this is v-on:arg - we need special handling
          // for wrapping inline statements.

          if (exp && exp.type === 4
          /* SIMPLE_EXPRESSION */
          && !(dir.name === 'on' && arg)) {
            dir.exp = processExpression(exp, context, // slot args must be processed as function params
            dir.name === 'slot');
          }

          if (arg && arg.type === 4
          /* SIMPLE_EXPRESSION */
          && !arg.isStatic) {
            dir.arg = processExpression(arg, context);
          }
        }
      }
    }
}; // Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.


function processExpression(node, context) {
  var asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  {
    if (true) {
      // simple in-browser validation (same logic in 2.x)
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }

    return node;
  }
}

var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, function (node, dir, context) {
  return processIf(node, dir, context, function (ifNode, branch, isRoot) {
    // #1587: We need to dynamically increment the key based on the current
    // node's sibling nodes, since chained v-if/else branches are
    // rendered at the same depth
    var siblings = context.parent.children;
    var i = siblings.indexOf(ifNode);
    var key = 0;

    while (i-- >= 0) {
      var sibling = siblings[i];

      if (sibling && sibling.type === 9
      /* IF */
      ) {
          key += sibling.branches.length;
        }
    } // Exit callback. Complete the codegenNode when all children have been
    // transformed.


    return function () {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
      } else {
        // attach this branch's codegen node to the v-if root.
        var parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
      }
    };
  });
}); // target-agnostic transform used for both Client and SSR

function processIf(node, dir, context, processCodegen) {
  if (dir.name !== 'else' && (!dir.exp || !dir.exp.content.trim())) {
    var loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(27
    /* X_V_IF_NO_EXPRESSION */
    , dir.loc));
    dir.exp = createSimpleExpression("true", false, loc);
  }

  if ( true && dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }

  if (dir.name === 'if') {
    var branch = createIfBranch(node, dir);
    var ifNode = {
      type: 9
      /* IF */
      ,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);

    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    // locate the adjacent v-if
    var siblings = context.parent.children;
    var comments = [];
    var i = siblings.indexOf(node);

    while (i-- >= -1) {
      var sibling = siblings[i];

      if ( true && sibling && sibling.type === 3
      /* COMMENT */
      ) {
          context.removeNode(sibling);
          comments.unshift(sibling);
          continue;
        }

      if (sibling && sibling.type === 2
      /* TEXT */
      && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }

      if (sibling && sibling.type === 9
      /* IF */
      ) {
          (function () {
            // move the node to the if node's branches
            context.removeNode();
            var branch = createIfBranch(node, dir);

            if ( true && comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
            !(context.parent && context.parent.type === 1
            /* ELEMENT */
            && isBuiltInType(context.parent.tag, 'transition'))) {
              branch.children = [].concat(comments, _toConsumableArray(branch.children));
            } // check if user is forcing same key on different branches


            if (true) {
              var key = branch.userKey;

              if (key) {
                sibling.branches.forEach(function (_ref4) {
                  var userKey = _ref4.userKey;

                  if (isSameKey(userKey, key)) {
                    context.onError(createCompilerError(28
                    /* X_V_IF_SAME_KEY */
                    , branch.userKey.loc));
                  }
                });
              }
            }

            sibling.branches.push(branch);
            var onExit = processCodegen && processCodegen(sibling, branch, false); // since the branch was removed, it will not be traversed.
            // make sure to traverse here.

            traverseNode(branch, context); // call on exit

            if (onExit) onExit(); // make sure to reset currentNode after traversal to indicate this
            // node has been removed.

            context.currentNode = null;
          })();
        } else {
        context.onError(createCompilerError(29
        /* X_V_ELSE_NO_ADJACENT_IF */
        , node.loc));
      }

      break;
    }
  }
}

function createIfBranch(node, dir) {
  return {
    type: 10
    /* IF_BRANCH */
    ,
    loc: node.loc,
    condition: dir.name === 'else' ? undefined : dir.exp,
    children: node.tagType === 3
    /* TEMPLATE */
    && !findDir(node, 'for') ? node.children : [node],
    userKey: findProp(node, "key")
  };
}

function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    createCallExpression(context.helper(CREATE_COMMENT), [ true ? '"v-if"' : 0, 'true']));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}

function createChildrenCodegenNode(branch, keyIndex, context) {
  var helper = context.helper,
      removeHelper = context.removeHelper;
  var keyProperty = createObjectProperty("key", createSimpleExpression("".concat(keyIndex), false, locStub, 2
  /* CAN_HOIST */
  ));
  var children = branch.children;
  var firstChild = children[0];
  var needFragmentWrapper = children.length !== 1 || firstChild.type !== 1
  /* ELEMENT */
  ;

  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11
    /* FOR */
    ) {
        // optimize away nested fragments when child is a ForNode
        var vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
      } else {
      var patchFlag = 64
      /* STABLE_FRAGMENT */
      ;
      var patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]; // check if the fragment actually contains a single valid child with
      // the rest being comments

      if ( true && children.filter(function (c) {
        return c.type !== 3;
      }
      /* COMMENT */
      ).length === 1) {
        patchFlag |= 2048
        /* DEV_ROOT_FRAGMENT */
        ;
        patchFlagText += ", ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]);
      }

      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ( true ? " /* ".concat(patchFlagText, " */") : 0), undefined, undefined, true, false, branch.loc);
    }
  } else {
    var _vnodeCall = firstChild.codegenNode; // Change createVNode to createBlock.

    if (_vnodeCall.type === 13
    /* VNODE_CALL */
    && !_vnodeCall.isBlock) {
      removeHelper(CREATE_VNODE);
      _vnodeCall.isBlock = true;
      helper(OPEN_BLOCK);
      helper(CREATE_BLOCK);
    } // inject branch key


    injectProp(_vnodeCall, keyProperty, context);
    return _vnodeCall;
  }
}

function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }

  if (a.type === 6
  /* ATTRIBUTE */
  ) {
      if (a.value.content !== b.value.content) {
        return false;
      }
    } else {
    // directive
    var exp = a.exp;
    var branchExp = b.exp;

    if (exp.type !== branchExp.type) {
      return false;
    }

    if (exp.type !== 4
    /* SIMPLE_EXPRESSION */
    || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }

  return true;
}

function getParentCondition(node) {
  while (true) {
    if (node.type === 19
    /* JS_CONDITIONAL_EXPRESSION */
    ) {
        if (node.alternate.type === 19
        /* JS_CONDITIONAL_EXPRESSION */
        ) {
            node = node.alternate;
          } else {
          return node;
        }
      } else if (node.type === 20
    /* JS_CACHE_EXPRESSION */
    ) {
        node = node.value;
      }
  }
}

var transformFor = createStructuralDirectiveTransform('for', function (node, dir, context) {
  var helper = context.helper,
      removeHelper = context.removeHelper;
  return processFor(node, dir, context, function (forNode) {
    // create the loop render function expression now, and add the
    // iterator on exit after all children have been traversed
    var renderExp = createCallExpression(helper(RENDER_LIST), [forNode.source]);
    var keyProp = findProp(node, "key");
    var keyProperty = keyProp ? createObjectProperty("key", keyProp.type === 6
    /* ATTRIBUTE */
    ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp) : null;
    var isStableFragment = forNode.source.type === 4
    /* SIMPLE_EXPRESSION */
    && forNode.source.constType > 0
    /* NOT_CONSTANT */
    ;
    var fragmentFlag = isStableFragment ? 64
    /* STABLE_FRAGMENT */
    : keyProp ? 128
    /* KEYED_FRAGMENT */
    : 256
    /* UNKEYED_FRAGMENT */
    ;
    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag], " */") : 0), undefined, undefined, true
    /* isBlock */
    , !isStableFragment
    /* disableTracking */
    , node.loc);
    return function () {
      // finish the codegen now that all children have been traversed
      var childBlock;
      var isTemplate = isTemplateNode(node);
      var children = forNode.children; // check <template v-for> key placement

      if (( true) && isTemplate) {
        node.children.some(function (c) {
          if (c.type === 1
          /* ELEMENT */
          ) {
              var key = findProp(c, 'key');

              if (key) {
                context.onError(createCompilerError(32
                /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
                , key.loc));
                return true;
              }
            }
        });
      }

      var needFragmentWrapper = children.length !== 1 || children[0].type !== 1
      /* ELEMENT */
      ;
      var slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] // api-extractor somehow fails to infer this
      : null;

      if (slotOutlet) {
        // <slot v-for="..."> or <template v-for="..."><slot/></template>
        childBlock = slotOutlet.codegenNode;

        if (isTemplate && keyProperty) {
          // <template v-for="..." :key="..."><slot/></template>
          // we need to inject the key to the renderSlot() call.
          // the props for renderSlot is passed as the 3rd argument.
          injectProp(childBlock, keyProperty, context);
        }
      } else if (needFragmentWrapper) {
        // <template v-for="..."> with text or multi-elements
        // should generate a fragment block for each loop
        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64
        /* STABLE_FRAGMENT */
        + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64], " */") : 0), undefined, undefined, true);
      } else {
        // Normal element v-for. Directly use the child's codegenNode
        // but mark it as a block.
        childBlock = children[0].codegenNode;

        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }

        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            // switch from block to vnode
            removeHelper(OPEN_BLOCK);
            removeHelper(CREATE_BLOCK);
          } else {
            // switch from vnode to block
            removeHelper(CREATE_VNODE);
          }
        }

        childBlock.isBlock = !isStableFragment;

        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(CREATE_BLOCK);
        } else {
          helper(CREATE_VNODE);
        }
      }

      renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true
      /* force newline */
      ));
    };
  });
}); // target-agnostic transform used for both Client and SSR

function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(30
    /* X_V_FOR_NO_EXPRESSION */
    , dir.loc));
    return;
  }

  var parseResult = parseForExpression( // can only be simple expression because vFor transform is applied
  // before expression transform.
  dir.exp, context);

  if (!parseResult) {
    context.onError(createCompilerError(31
    /* X_V_FOR_MALFORMED_EXPRESSION */
    , dir.loc));
    return;
  }

  var addIdentifiers = context.addIdentifiers,
      removeIdentifiers = context.removeIdentifiers,
      scopes = context.scopes;
  var source = parseResult.source,
      value = parseResult.value,
      key = parseResult.key,
      index = parseResult.index;
  var forNode = {
    type: 11
    /* FOR */
    ,
    loc: dir.loc,
    source: source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult: parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode); // bookkeeping

  scopes.vFor++;
  var onExit = processCodegen && processCodegen(forNode);
  return function () {
    scopes.vFor--;
    if (onExit) onExit();
  };
}

var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/; // This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.

var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;

function parseForExpression(input, context) {
  var loc = input.loc;
  var exp = input.content;
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) return;

  var _inMatch = _slicedToArray(inMatch, 3),
      LHS = _inMatch[1],
      RHS = _inMatch[2];

  var result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: undefined,
    key: undefined,
    index: undefined
  };

  if (true) {
    validateBrowserExpression(result.source, context);
  }

  var valueContent = LHS.trim().replace(stripParensRE, '').trim();
  var trimmedOffset = LHS.indexOf(valueContent);
  var iteratorMatch = valueContent.match(forIteratorRE);

  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, '').trim();
    var keyContent = iteratorMatch[1].trim();
    var keyOffset;

    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);

      if (true) {
        validateBrowserExpression(result.key, context, true);
      }
    }

    if (iteratorMatch[2]) {
      var indexContent = iteratorMatch[2].trim();

      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));

        if (true) {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }

  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);

    if (true) {
      validateBrowserExpression(result.value, context, true);
    }
  }

  return result;
}

function createAliasExpression(range, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}

function createForLoopParams(_ref5) {
  var value = _ref5.value,
      key = _ref5.key,
      index = _ref5.index;
  var params = [];

  if (value) {
    params.push(value);
  }

  if (key) {
    if (!value) {
      params.push(createSimpleExpression("_", false));
    }

    params.push(key);
  }

  if (index) {
    if (!key) {
      if (!value) {
        params.push(createSimpleExpression("_", false));
      }

      params.push(createSimpleExpression("__", false));
    }

    params.push(index);
  }

  return params;
}

var defaultFallback = createSimpleExpression("undefined", false); // A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.

var trackSlotScopes = function trackSlotScopes(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && (node.tagType === 1
  /* COMPONENT */
  || node.tagType === 3
  /* TEMPLATE */
  )) {
    // We are only checking non-empty v-slot here
    // since we only care about slots that introduce scope variables.
    var vSlot = findDir(node, 'slot');

    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return function () {
        context.scopes.vSlot--;
      };
    }
  }
}; // A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }


var trackVForSlotScopes = function trackVForSlotScopes(node, context) {
  var vFor;

  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, 'for'))) {
    var result = vFor.parseResult = parseForExpression(vFor.exp, context);

    if (result) {
      var value = result.value,
          key = result.key,
          index = result.index;
      var addIdentifiers = context.addIdentifiers,
          removeIdentifiers = context.removeIdentifiers;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return function () {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};

var buildClientSlotFn = function buildClientSlotFn(props, children, loc) {
  return createFunctionExpression(props, children, false
  /* newline */
  , true
  /* isSlot */
  , children.length ? children[0].loc : loc);
}; // Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.


function buildSlots(node, context) {
  var buildSlotFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : buildClientSlotFn;
  context.helper(WITH_CTX);
  var children = node.children,
      loc = node.loc;
  var slotsProperties = [];
  var dynamicSlots = []; // If the slot is inside a v-for or another v-slot, force it to be dynamic
  // since it likely uses a scope variable.

  var hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0; // 1. Check for slot with slotProps on component itself.
  //    <Comp v-slot="{ prop }"/>

  var onComponentSlot = findDir(node, 'slot', true);

  if (onComponentSlot) {
    var arg = onComponentSlot.arg,
        exp = onComponentSlot.exp;

    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }

    slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
  } // 2. Iterate through children and check for template slots
  //    <template v-slot:foo="{ prop }">


  var hasTemplateSlots = false;
  var hasNamedDefaultSlot = false;
  var implicitDefaultChildren = [];
  var seenSlotNames = new Set();

  for (var i = 0; i < children.length; i++) {
    var slotElement = children[i];
    var slotDir = void 0;

    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, 'slot', true))) {
      // not a <template v-slot>, skip.
      if (slotElement.type !== 3
      /* COMMENT */
      ) {
          implicitDefaultChildren.push(slotElement);
        }

      continue;
    }

    if (onComponentSlot) {
      // already has on-component slot - this is incorrect usage.
      context.onError(createCompilerError(36
      /* X_V_SLOT_MIXED_SLOT_USAGE */
      , slotDir.loc));
      break;
    }

    hasTemplateSlots = true;
    var slotChildren = slotElement.children,
        slotLoc = slotElement.loc;
    var _slotDir = slotDir,
        _slotDir$arg = _slotDir.arg,
        slotName = _slotDir$arg === void 0 ? createSimpleExpression("default", true) : _slotDir$arg,
        slotProps = _slotDir.exp,
        dirLoc = _slotDir.loc; // check if name is dynamic.

    var staticSlotName = void 0;

    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : "default";
    } else {
      hasDynamicSlots = true;
    }

    var slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc); // check if this slot is conditional (v-if/v-for)

    var vIf = void 0;
    var vElse = void 0;
    var vFor = void 0;

    if (vIf = findDir(slotElement, 'if')) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true
    /* allowEmpty */
    )) {
      // find adjacent v-if
      var j = i;
      var prev = void 0;

      while (j--) {
        prev = children[j];

        if (prev.type !== 3
        /* COMMENT */
        ) {
            break;
          }
      }

      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
        // remove node
        children.splice(i, 1);
        i--; // attach this slot to previous conditional

        var conditional = dynamicSlots[dynamicSlots.length - 1];

        while (conditional.alternate.type === 19
        /* JS_CONDITIONAL_EXPRESSION */
        ) {
          conditional = conditional.alternate;
        }

        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(29
        /* X_V_ELSE_NO_ADJACENT_IF */
        , vElse.loc));
      }
    } else if (vFor = findDir(slotElement, 'for')) {
      hasDynamicSlots = true;
      var parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);

      if (parseResult) {
        // Render the dynamic slots as an array and add it to the createSlot()
        // args. The runtime knows how to handle it appropriately.
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [parseResult.source, createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true
        /* force newline */
        )]));
      } else {
        context.onError(createCompilerError(31
        /* X_V_FOR_MALFORMED_EXPRESSION */
        , vFor.loc));
      }
    } else {
      // check duplicate static names
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(37
          /* X_V_SLOT_DUPLICATE_SLOT_NAMES */
          , dirLoc));
          continue;
        }

        seenSlotNames.add(staticSlotName);

        if (staticSlotName === 'default') {
          hasNamedDefaultSlot = true;
        }
      }

      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }

  if (!onComponentSlot) {
    var buildDefaultSlotProperty = function buildDefaultSlotProperty(props, children) {
      var fn = buildSlotFn(props, children, loc);

      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }

      return createObjectProperty("default", fn);
    };

    if (!hasTemplateSlots) {
      // implicit default slot (on component)
      slotsProperties.push(buildDefaultSlotProperty(undefined, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some(function (node) {
      return isNonWhitespaceContent(node);
    })) {
      // implicit default slot (mixed with named slots)
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(38
        /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
        , implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
      }
    }
  }

  var slotFlag = hasDynamicSlots ? 2
  /* DYNAMIC */
  : hasForwardedSlots(node.children) ? 3
  /* FORWARDED */
  : 1
  /* STABLE */
  ;
  var slots = createObjectExpression(slotsProperties.concat(createObjectProperty("_", // 2 = compiled but dynamic = can skip normalization, but must run diff
  // 1 = compiled and static = can skip normalization AND diff as optimized
  createSimpleExpression(slotFlag + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag], " */") : 0), false))), loc);

  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [slots, createArrayExpression(dynamicSlots)]);
  }

  return {
    slots: slots,
    hasDynamicSlots: hasDynamicSlots
  };
}

function buildDynamicSlot(name, fn) {
  return createObjectExpression([createObjectProperty("name", name), createObjectProperty("fn", fn)]);
}

function hasForwardedSlots(children) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    switch (child.type) {
      case 1
      /* ELEMENT */
      :
        if (child.tagType === 2
        /* SLOT */
        || child.tagType === 0
        /* ELEMENT */
        && hasForwardedSlots(child.children)) {
          return true;
        }

        break;

      case 9
      /* IF */
      :
        if (hasForwardedSlots(child.branches)) return true;
        break;

      case 10
      /* IF_BRANCH */
      :
      case 11
      /* FOR */
      :
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }

  return false;
}

function isNonWhitespaceContent(node) {
  if (node.type !== 2
  /* TEXT */
  && node.type !== 12
  /* TEXT_CALL */
  ) return true;
  return node.type === 2
  /* TEXT */
  ? !!node.content.trim() : isNonWhitespaceContent(node.content);
} // some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.


var directiveImportMap = new WeakMap(); // generate a JavaScript AST for this element's codegen

var transformElement = function transformElement(node, context) {
  // perform the work on exit, after all child expressions have been
  // processed and merged.
  return function postTransformElement() {
    node = context.currentNode;

    if (!(node.type === 1
    /* ELEMENT */
    && (node.tagType === 0
    /* ELEMENT */
    || node.tagType === 1
    /* COMPONENT */
    ))) {
      return;
    }

    var _node3 = node,
        tag = _node3.tag,
        props = _node3.props;
    var isComponent = node.tagType === 1
    /* COMPONENT */
    ; // The goal of the transform is to create a codegenNode implementing the
    // VNodeCall interface.

    var vnodeTag = isComponent ? resolveComponentType(node, context) : "\"".concat(tag, "\"");
    var isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    var vnodeProps;
    var vnodeChildren;
    var vnodePatchFlag;
    var patchFlag = 0;
    var vnodeDynamicProps;
    var dynamicPropNames;
    var vnodeDirectives;
    var shouldUseBlock = // dynamic component may resolve to plain elements
    isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && ( // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    tag === 'svg' || tag === 'foreignObject' || // #938: elements with dynamic keys should be forced into blocks
    findProp(node, 'key', true)); // props

    if (props.length > 0) {
      var propsBuildResult = buildProps(node, context);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      var directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map(function (dir) {
        return buildDirectiveArgs(dir, context);
      })) : undefined;
    } // children


    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        // Although a built-in component, we compile KeepAlive with raw children
        // instead of slot functions so that it can be used inside Transition
        // or other Transition-wrapping HOCs.
        // To ensure correct updates with block optimizations, we need to:
        // 1. Force keep-alive into a block. This avoids its children being
        //    collected by a parent block.
        shouldUseBlock = true; // 2. Force keep-alive to always be updated, since it uses raw children.

        patchFlag |= 1024
        /* DYNAMIC_SLOTS */
        ;

        if ( true && node.children.length > 1) {
          context.onError(createCompilerError(44
          /* X_KEEP_ALIVE_INVALID_CHILDREN */
          , {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ''
          }));
        }
      }

      var shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;

      if (shouldBuildAsSlots) {
        var _buildSlots = buildSlots(node, context),
            slots = _buildSlots.slots,
            hasDynamicSlots = _buildSlots.hasDynamicSlots;

        vnodeChildren = slots;

        if (hasDynamicSlots) {
          patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        var child = node.children[0];
        var type = child.type; // check for dynamic text children

        var hasDynamicTextChild = type === 5
        /* INTERPOLATION */
        || type === 8
        /* COMPOUND_EXPRESSION */
        ;

        if (hasDynamicTextChild && getConstantType(child, context) === 0
        /* NOT_CONSTANT */
        ) {
            patchFlag |= 1
            /* TEXT */
            ;
          } // pass directly if the only child is a text node
        // (plain / interpolation / expression)


        if (hasDynamicTextChild || type === 2
        /* TEXT */
        ) {
            vnodeChildren = child;
          } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    } // patchFlag & dynamicPropNames


    if (patchFlag !== 0) {
      if (true) {
        if (patchFlag < 0) {
          // special flags (negative and mutually exclusive)
          vnodePatchFlag = patchFlag + " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag], " */");
        } else {
          // bitwise flags
          var flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames).map(Number).filter(function (n) {
            return n > 0 && patchFlag & n;
          }).map(function (n) {
            return _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n];
          }).join(", ");
          vnodePatchFlag = patchFlag + " /* ".concat(flagNames, " */");
        }
      } else {}

      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }

    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false
    /* disableTracking */
    , node.loc);
  };
};

function resolveComponentType(node, context) {
  var ssr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var tag = node.tag; // 1. dynamic component

  var isExplicitDynamic = isComponentTag(tag);
  var isProp = findProp(node, 'is') || !isExplicitDynamic && findDir(node, 'is');

  if (isProp) {
    if (!isExplicitDynamic && isProp.type === 6
    /* ATTRIBUTE */
    ) {
        // <button is="vue:xxx">
        // if not <component>, only is value that starts with "vue:" will be
        // treated as component by the parse phase and reach here, unless it's
        // compat mode where all is values are considered components
        tag = isProp.value.content.replace(/^vue:/, '');
      } else {
      var exp = isProp.type === 6
      /* ATTRIBUTE */
      ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;

      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [exp]);
      }
    }
  } // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)


  var builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);

  if (builtIn) {
    // built-ins are simply fallthroughs / have special handling during ssr
    // so we don't need to import their runtime equivalents
    if (!ssr) context.helper(builtIn);
    return builtIn;
  } // 5. user component (resolve)


  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, "component");
}

function buildProps(node, context) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.props;
  var ssr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var tag = node.tag,
      elementLoc = node.loc;
  var isComponent = node.tagType === 1
  /* COMPONENT */
  ;
  var properties = [];
  var mergeArgs = [];
  var runtimeDirectives = []; // patchFlag analysis

  var patchFlag = 0;
  var hasRef = false;
  var hasClassBinding = false;
  var hasStyleBinding = false;
  var hasHydrationEventBinding = false;
  var hasDynamicKeys = false;
  var hasVnodeHook = false;
  var dynamicPropNames = [];

  var analyzePatchFlag = function analyzePatchFlag(_ref6) {
    var key = _ref6.key,
        value = _ref6.value;

    if (isStaticExp(key)) {
      var name = key.content;
      var isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);

      if (!isComponent && isEventHandler && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== 'onclick' && // omit v-model handlers
      name !== 'onUpdate:modelValue' && // omit onVnodeXXX hooks
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasHydrationEventBinding = true;
      }

      if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasVnodeHook = true;
      }

      if (value.type === 20
      /* JS_CACHE_EXPRESSION */
      || (value.type === 4
      /* SIMPLE_EXPRESSION */
      || value.type === 8
      /* COMPOUND_EXPRESSION */
      ) && getConstantType(value, context) > 0) {
        // skip if the prop is a cached handler or has constant value
        return;
      }

      if (name === 'ref') {
        hasRef = true;
      } else if (name === 'class' && !isComponent) {
        hasClassBinding = true;
      } else if (name === 'style' && !isComponent) {
        hasStyleBinding = true;
      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };

  for (var i = 0; i < props.length; i++) {
    // static attribute
    var prop = props[i];

    if (prop.type === 6
    /* ATTRIBUTE */
    ) {
        var loc = prop.loc,
            name = prop.name,
            value = prop.value;
        var isStatic = true;

        if (name === 'ref') {
          hasRef = true;
        } // skip is on <component>, or is="vue:xxx"


        if (name === 'is' && (isComponentTag(tag) || value && value.content.startsWith('vue:'))) {
          continue;
        }

        properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
      } else {
      // directives
      var _name = prop.name,
          arg = prop.arg,
          exp = prop.exp,
          _loc2 = prop.loc;
      var isVBind = _name === 'bind';
      var isVOn = _name === 'on'; // skip v-slot - it is handled by its dedicated transform.

      if (_name === 'slot') {
        if (!isComponent) {
          context.onError(createCompilerError(39
          /* X_V_SLOT_MISPLACED */
          , _loc2));
        }

        continue;
      } // skip v-once - it is handled by its dedicated transform.


      if (_name === 'once') {
        continue;
      } // skip v-is and :is on <component>


      if (_name === 'is' || isVBind && isComponentTag(tag) && isBindKey(arg, 'is')) {
        continue;
      } // skip v-on in SSR compilation


      if (isVOn && ssr) {
        continue;
      } // special case for v-bind and v-on with no argument


      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;

        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }

          if (isVBind) {
            {
              // 2.x v-bind object order compat
              if (true) {
                var hasOverridableKeys = mergeArgs.some(function (arg) {
                  if (arg.type === 15
                  /* JS_OBJECT_EXPRESSION */
                  ) {
                      return arg.properties.some(function (_ref7) {
                        var key = _ref7.key;

                        if (key.type !== 4
                        /* SIMPLE_EXPRESSION */
                        || !key.isStatic) {
                          return true;
                        }

                        return key.content !== 'class' && key.content !== 'style' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content);
                      });
                    } else {
                    // dynamic expression
                    return true;
                  }
                });

                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER"
                  /* COMPILER_V_BIND_OBJECT_ORDER */
                  , context, _loc2);
                }
              }

              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER"
              /* COMPILER_V_BIND_OBJECT_ORDER */
              , context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            // v-on="obj" -> toHandlers(obj)
            mergeArgs.push({
              type: 14
              /* JS_CALL_EXPRESSION */
              ,
              loc: _loc2,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 33
          /* X_V_BIND_NO_EXPRESSION */
          : 34
          /* X_V_ON_NO_EXPRESSION */
          , _loc2));
        }

        continue;
      }

      var directiveTransform = context.directiveTransforms[_name];

      if (directiveTransform) {
        var _properties;

        // has built-in directive transform.
        var _directiveTransform = directiveTransform(prop, node, context),
            _props = _directiveTransform.props,
            needRuntime = _directiveTransform.needRuntime;

        !ssr && _props.forEach(analyzePatchFlag);

        (_properties = properties).push.apply(_properties, _toConsumableArray(_props));

        if (needRuntime) {
          runtimeDirectives.push(prop);

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else {
        // no built-in transform, this is a user custom directive.
        runtimeDirectives.push(prop);
      }
    }

    if (prop.type === 6
    /* ATTRIBUTE */
    && prop.name === 'ref' && context.scopes.vFor > 0 && checkCompatEnabled("COMPILER_V_FOR_REF"
    /* COMPILER_V_FOR_REF */
    , context, prop.loc)) {
      properties.push(createObjectProperty(createSimpleExpression('refInFor', true), createSimpleExpression('true', false)));
    }
  }

  var propsExpression = undefined; // has v-bind="object" or v-on="object", wrap with mergeProps

  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }

    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      // single v-bind with nothing else - no need for a mergeProps call
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  } // patchFlag analysis


  if (hasDynamicKeys) {
    patchFlag |= 16
    /* FULL_PROPS */
    ;
  } else {
    if (hasClassBinding) {
      patchFlag |= 2
      /* CLASS */
      ;
    }

    if (hasStyleBinding) {
      patchFlag |= 4
      /* STYLE */
      ;
    }

    if (dynamicPropNames.length) {
      patchFlag |= 8
      /* PROPS */
      ;
    }

    if (hasHydrationEventBinding) {
      patchFlag |= 32
      /* HYDRATE_EVENTS */
      ;
    }
  }

  if ((patchFlag === 0 || patchFlag === 32
  /* HYDRATE_EVENTS */
  ) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512
    /* NEED_PATCH */
    ;
  }

  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag: patchFlag,
    dynamicPropNames: dynamicPropNames
  };
} // Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation


function dedupeProperties(properties) {
  var knownProps = new Map();
  var deduped = [];

  for (var i = 0; i < properties.length; i++) {
    var prop = properties[i]; // dynamic keys are always allowed

    if (prop.key.type === 8
    /* COMPOUND_EXPRESSION */
    || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }

    var name = prop.key.content;
    var existing = knownProps.get(name);

    if (existing) {
      if (name === 'style' || name === 'class' || name.startsWith('on')) {
        mergeAsArray(existing, prop);
      } // unexpected duplicate, should have emitted error during parse

    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }

  return deduped;
}

function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17
  /* JS_ARRAY_EXPRESSION */
  ) {
      existing.value.elements.push(incoming.value);
    } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}

function buildDirectiveArgs(dir, context) {
  var dirArgs = [];
  var runtime = directiveImportMap.get(dir);

  if (runtime) {
    // built-in directive with runtime
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      // inject statement for resolving directive
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, "directive"));
    }
  }

  var loc = dir.loc;
  if (dir.exp) dirArgs.push(dir.exp);

  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push("void 0");
    }

    dirArgs.push(dir.arg);
  }

  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push("void 0");
      }

      dirArgs.push("void 0");
    }

    var trueExpression = createSimpleExpression("true", false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map(function (modifier) {
      return createObjectProperty(modifier, trueExpression);
    }), loc));
  }

  return createArrayExpression(dirArgs, dir.loc);
}

function stringifyDynamicPropNames(props) {
  var propsNamesString = "[";

  for (var i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ', ';
  }

  return propsNamesString + "]";
}

function isComponentTag(tag) {
  return tag[0].toLowerCase() + tag.slice(1) === 'component';
}

 true ? Object.freeze({}) : 0;
 true ? Object.freeze([]) : 0;

var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

var camelizeRE = /-(\w)/g;
/**
 * @private
 */

var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

var transformSlotOutlet = function transformSlotOutlet(node, context) {
  if (isSlotOutlet(node)) {
    var children = node.children,
        loc = node.loc;

    var _processSlotOutlet = processSlotOutlet(node, context),
        slotName = _processSlotOutlet.slotName,
        slotProps = _processSlotOutlet.slotProps;

    var slotArgs = [context.prefixIdentifiers ? "_ctx.$slots" : "$slots", slotName];

    if (slotProps) {
      slotArgs.push(slotProps);
    }

    if (children.length) {
      if (!slotProps) {
        slotArgs.push("{}");
      }

      slotArgs.push(createFunctionExpression([], children, false, false, loc));
    }

    if (context.scopeId && !context.slotted) {
      if (!slotProps) {
        slotArgs.push("{}");
      }

      if (!children.length) {
        slotArgs.push("undefined");
      }

      slotArgs.push("true");
    }

    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
  }
};

function processSlotOutlet(node, context) {
  var slotName = "\"default\"";
  var slotProps = undefined;
  var nonNameProps = [];

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 6
    /* ATTRIBUTE */
    ) {
        if (p.value) {
          if (p.name === 'name') {
            slotName = JSON.stringify(p.value.content);
          } else {
            p.name = camelize(p.name);
            nonNameProps.push(p);
          }
        }
      } else {
      if (p.name === 'bind' && isBindKey(p.arg, 'name')) {
        if (p.exp) slotName = p.exp;
      } else {
        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }

        nonNameProps.push(p);
      }
    }
  }

  if (nonNameProps.length > 0) {
    var _buildProps = buildProps(node, context, nonNameProps),
        props = _buildProps.props,
        directives = _buildProps.directives;

    slotProps = props;

    if (directives.length) {
      context.onError(createCompilerError(35
      /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
      , directives[0].loc));
    }
  }

  return {
    slotName: slotName,
    slotProps: slotProps
  };
}

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;

var transformOn = function transformOn(dir, node, context, augmentor) {
  var loc = dir.loc,
      modifiers = dir.modifiers,
      arg = dir.arg;

  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(34
    /* X_V_ON_NO_EXPRESSION */
    , loc));
  }

  var eventName;

  if (arg.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
      if (arg.isStatic) {
        var rawName = arg.content; // for all event listeners, auto convert it to camelCase. See issue #2249

        eventName = createSimpleExpression((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)), true, arg.loc);
      } else {
        // #2388
        eventName = createCompoundExpression(["".concat(context.helperString(TO_HANDLER_KEY), "("), arg, ")"]);
      }
    } else {
    // already a compound expression.
    eventName = arg;
    eventName.children.unshift("".concat(context.helperString(TO_HANDLER_KEY), "("));
    eventName.children.push(")");
  } // handler processing


  var exp = dir.exp;

  if (exp && !exp.content.trim()) {
    exp = undefined;
  }

  var shouldCache = context.cacheHandlers && !exp;

  if (exp) {
    var isMemberExp = isMemberExpression(exp.content);
    var isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    var hasMultipleStatements = exp.content.includes(";");

    if (true) {
      validateBrowserExpression(exp, context, false, hasMultipleStatements);
    }

    if (isInlineStatement || shouldCache && isMemberExp) {
      // wrap inline statement in a function expression
      exp = createCompoundExpression(["".concat(isInlineStatement ? "$event" : "".concat("", "(...args)"), " => ").concat(hasMultipleStatements ? "{" : "("), exp, hasMultipleStatements ? "}" : ")"]);
    }
  }

  var ret = {
    props: [createObjectProperty(eventName, exp || createSimpleExpression("() => {}", false, loc))]
  }; // apply extended compiler augmentor

  if (augmentor) {
    ret = augmentor(ret);
  }

  if (shouldCache) {
    // cache handlers so that it's always the same handler being passed down.
    // this avoids unnecessary re-renders when users use inline handlers on
    // components.
    ret.props[0].value = context.cache(ret.props[0].value);
  }

  return ret;
}; // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.


var transformBind = function transformBind(dir, _node, context) {
  var exp = dir.exp,
      modifiers = dir.modifiers,
      loc = dir.loc;
  var arg = dir.arg;

  if (arg.type !== 4
  /* SIMPLE_EXPRESSION */
  ) {
      arg.children.unshift("(");
      arg.children.push(") || \"\"");
    } else if (!arg.isStatic) {
    arg.content = "".concat(arg.content, " || \"\"");
  } // .prop is no longer necessary due to new patch behavior
  // .sync is replaced by v-model:arg


  if (modifiers.includes('camel')) {
    if (arg.type === 4
    /* SIMPLE_EXPRESSION */
    ) {
        if (arg.isStatic) {
          arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
        } else {
          arg.content = "".concat(context.helperString(CAMELIZE), "(").concat(arg.content, ")");
        }
      } else {
      arg.children.unshift("".concat(context.helperString(CAMELIZE), "("));
      arg.children.push(")");
    }
  }

  if (!exp || exp.type === 4
  /* SIMPLE_EXPRESSION */
  && !exp.content.trim()) {
    context.onError(createCompilerError(33
    /* X_V_BIND_NO_EXPRESSION */
    , loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
    };
  }

  return {
    props: [createObjectProperty(arg, exp)]
  };
}; // Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.


var transformText = function transformText(node, context) {
  if (node.type === 0
  /* ROOT */
  || node.type === 1
  /* ELEMENT */
  || node.type === 11
  /* FOR */
  || node.type === 10
  /* IF_BRANCH */
  ) {
      // perform the transform on node exit so that all expressions have already
      // been processed.
      return function () {
        var children = node.children;
        var currentContainer = undefined;
        var hasText = false;

        for (var i = 0; i < children.length; i++) {
          var child = children[i];

          if (isText(child)) {
            hasText = true;

            for (var j = i + 1; j < children.length; j++) {
              var next = children[j];

              if (isText(next)) {
                if (!currentContainer) {
                  currentContainer = children[i] = {
                    type: 8
                    /* COMPOUND_EXPRESSION */
                    ,
                    loc: child.loc,
                    children: [child]
                  };
                } // merge adjacent text node into current


                currentContainer.children.push(" + ", next);
                children.splice(j, 1);
                j--;
              } else {
                currentContainer = undefined;
                break;
              }
            }
          }
        }

        if (!hasText || // if this is a plain element with a single text child, leave it
        // as-is since the runtime has dedicated fast path for this by directly
        // setting textContent of the element.
        // for component root it's always normalized anyway.
        children.length === 1 && (node.type === 0
        /* ROOT */
        || node.type === 1
        /* ELEMENT */
        && node.tagType === 0
        /* ELEMENT */
        && // #3756
        // custom directives can potentially add DOM elements arbitrarily,
        // we need to avoid setting textContent of the element at runtime
        // to avoid accidentally overwriting the DOM elements added
        // by the user through custom directives.
        !node.props.find(function (p) {
          return p.type === 7
          /* DIRECTIVE */
          && !context.directiveTransforms[p.name];
        }) && // in compat mode, <template> tags with no special directives
        // will be rendered as a fragment so its children must be
        // converted into vnodes.
        !(node.tag === 'template'))) {
          return;
        } // pre-convert text nodes into createTextVNode(text) calls to avoid
        // runtime normalization.


        for (var _i7 = 0; _i7 < children.length; _i7++) {
          var _child = children[_i7];

          if (isText(_child) || _child.type === 8
          /* COMPOUND_EXPRESSION */
          ) {
              var callArgs = []; // createTextVNode defaults to single whitespace, so if it is a
              // single space the code could be an empty call to save bytes.

              if (_child.type !== 2
              /* TEXT */
              || _child.content !== ' ') {
                callArgs.push(_child);
              } // mark dynamic text with flag so it gets patched inside a block


              if (!context.ssr && getConstantType(_child, context) === 0
              /* NOT_CONSTANT */
              ) {
                  callArgs.push(1
                  /* TEXT */
                  + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1], " */") : 0));
                }

              children[_i7] = {
                type: 12
                /* TEXT_CALL */
                ,
                content: _child,
                loc: _child.loc,
                codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
              };
            }
        }
      };
    }
};

var seen = new WeakSet();

var transformOnce = function transformOnce(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && findDir(node, 'once', true)) {
    if (seen.has(node)) {
      return;
    }

    seen.add(node);
    context.helper(SET_BLOCK_TRACKING);
    return function () {
      var cur = context.currentNode;

      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true
        /* isVNode */
        );
      }
    };
  }
};

var transformModel = function transformModel(dir, node, context) {
  var exp = dir.exp,
      arg = dir.arg;

  if (!exp) {
    context.onError(createCompilerError(40
    /* X_V_MODEL_NO_EXPRESSION */
    , dir.loc));
    return createTransformProps();
  }

  var rawExp = exp.loc.source;
  var expString = exp.type === 4
  /* SIMPLE_EXPRESSION */
  ? exp.content : rawExp; // im SFC <script setup> inline mode, the exp may have been transformed into
  // _unref(exp)

  context.bindingMetadata[rawExp];
  var maybeRef = !true
  /* SETUP_CONST */
  ;

  if (!isMemberExpression(expString) && !maybeRef) {
    context.onError(createCompilerError(41
    /* X_V_MODEL_MALFORMED_EXPRESSION */
    , exp.loc));
    return createTransformProps();
  }

  var propName = arg ? arg : createSimpleExpression('modelValue', true);
  var eventName = arg ? isStaticExp(arg) ? "onUpdate:".concat(arg.content) : createCompoundExpression(['"onUpdate:" + ', arg]) : "onUpdate:modelValue";
  var assignmentExp;
  var eventArg = context.isTS ? "($event: any)" : "$event";
  {
    assignmentExp = createCompoundExpression(["".concat(eventArg, " => ("), exp, " = $event)"]);
  }
  var props = [// modelValue: foo
  createObjectProperty(propName, dir.exp), // "onUpdate:modelValue": $event => (foo = $event)
  createObjectProperty(eventName, assignmentExp)]; // modelModifiers: { foo: true, "bar-baz": true }

  if (dir.modifiers.length && node.tagType === 1
  /* COMPONENT */
  ) {
      var modifiers = dir.modifiers.map(function (m) {
        return (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + ": true";
      }).join(", ");
      var modifiersKey = arg ? isStaticExp(arg) ? "".concat(arg.content, "Modifiers") : createCompoundExpression([arg, ' + "Modifiers"']) : "modelModifiers";
      props.push(createObjectProperty(modifiersKey, createSimpleExpression("{ ".concat(modifiers, " }"), false, dir.loc, 2
      /* CAN_HOIST */
      )));
    }

  return createTransformProps(props);
};

function createTransformProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return {
    props: props
  };
}

var validDivisionCharRE = /[\w).+\-_$\]]/;

var transformFilter = function transformFilter(node, context) {
  if (!isCompatEnabled("COMPILER_FILTER"
  /* COMPILER_FILTERS */
  , context)) {
    return;
  }

  if (node.type === 5
  /* INTERPOLATION */
  ) {
      // filter rewrite is applied before expression transform so only
      // simple expressions are possible at this stage
      rewriteFilter(node.content, context);
    }

  if (node.type === 1
  /* ELEMENT */
  ) {
      node.props.forEach(function (prop) {
        if (prop.type === 7
        /* DIRECTIVE */
        && prop.name !== 'for' && prop.exp) {
          rewriteFilter(prop.exp, context);
        }
      });
    }
};

function rewriteFilter(node, context) {
  if (node.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
      parseFilter(node, context);
    } else {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if (_typeof(child) !== 'object') continue;

      if (child.type === 4
      /* SIMPLE_EXPRESSION */
      ) {
          parseFilter(child, context);
        } else if (child.type === 8
      /* COMPOUND_EXPRESSION */
      ) {
          rewriteFilter(node, context);
        } else if (child.type === 5
      /* INTERPOLATION */
      ) {
          rewriteFilter(child.content, context);
        }
    }
  }
}

function parseFilter(node, context) {
  var exp = node.content;
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c,
      prev,
      i,
      expression,
      filters = [];

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5c) inSingle = false;
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5c) inDouble = false;
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5c) inTemplateString = false;
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5c) inRegex = false;
    } else if (c === 0x7c && // pipe
    exp.charCodeAt(i + 1) !== 0x7c && exp.charCodeAt(i - 1) !== 0x7c && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5b:
          square++;
          break;
        // [

        case 0x5d:
          square--;
          break;
        // ]

        case 0x7b:
          curly++;
          break;
        // {

        case 0x7d:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') break;
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters.length) {
     true && warnDeprecation("COMPILER_FILTER"
    /* COMPILER_FILTERS */
    , context, node.loc);

    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }

    node.content = expression;
  }
}

function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  var i = filter.indexOf('(');

  if (i < 0) {
    context.filters.add(filter);
    return "".concat(toValidAssetId(filter, 'filter'), "(").concat(exp, ")");
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    context.filters.add(name);
    return "".concat(toValidAssetId(name, 'filter'), "(").concat(exp).concat(args !== ')' ? ',' + args : args);
  }
}

function getBaseTransformPreset(prefixIdentifiers) {
  return [[transformOnce, transformIf, transformFor].concat([transformFilter], _toConsumableArray( true ? [transformExpression] : 0), [transformSlotOutlet, transformElement, trackSlotScopes, transformText]), {
    on: transformOn,
    bind: transformBind,
    model: transformModel
  }];
} // we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.


function baseCompile(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var onError = options.onError || defaultOnError;
  var isModuleMode = options.mode === 'module';
  /* istanbul ignore if */

  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(45
      /* X_PREFIX_ID_NOT_SUPPORTED */
      ));
    } else if (isModuleMode) {
      onError(createCompilerError(46
      /* X_MODULE_MODE_NOT_SUPPORTED */
      ));
    }
  }
  var prefixIdentifiers = !true;

  if (options.cacheHandlers) {
    onError(createCompilerError(47
    /* X_CACHE_HANDLER_NOT_SUPPORTED */
    ));
  }

  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(48
    /* X_SCOPE_ID_NOT_SUPPORTED */
    ));
  }

  var ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;

  var _getBaseTransformPres = getBaseTransformPreset(),
      _getBaseTransformPres2 = _slicedToArray(_getBaseTransformPres, 2),
      nodeTransforms = _getBaseTransformPres2[0],
      directiveTransforms = _getBaseTransformPres2[1];

  transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers: prefixIdentifiers,
    nodeTransforms: [].concat(_toConsumableArray(nodeTransforms), _toConsumableArray(options.nodeTransforms || [])),
    directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
    )
  }));
  return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers: prefixIdentifiers
  }));
}

var noopDirectiveTransform = function noopDirectiveTransform() {
  return {
    props: []
  };
};



/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   "CREATE_SLOTS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   "IS_REF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   "OPEN_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   "WITH_CTX": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   "WITH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_SCOPE_ID),
/* harmony export */   "advancePositionWithClone": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   "assert": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   "baseCompile": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   "baseParse": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   "buildProps": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   "buildSlots": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   "createCompilerError": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   "createInterpolation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   "createRoot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   "createSequenceExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   "findDir": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   "findProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   "generate": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),
/* harmony export */   "hasDynamicKeyVBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   "injectProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   "isBindKey": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBindKey),
/* harmony export */   "isBuiltInType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   "isMemberExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   "isSimpleIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   "isStaticExp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   "isTemplateNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   "isText": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   "isVSlot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   "locStub": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   "noopDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   "processFor": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   "processIf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   "processSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   "transform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   "transformElement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   "transformExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   "transformModel": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   "transformOn": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   "traverseNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   "warnDeprecation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation),
/* harmony export */   "DOMDirectiveTransforms": () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   "DOMNodeTransforms": () => (/* binding */ DOMNodeTransforms),
/* harmony export */   "TRANSITION": () => (/* binding */ TRANSITION),
/* harmony export */   "TRANSITION_GROUP": () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   "V_MODEL_CHECKBOX": () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   "V_MODEL_DYNAMIC": () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   "V_MODEL_RADIO": () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   "V_MODEL_SELECT": () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   "V_MODEL_TEXT": () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   "V_ON_WITH_KEYS": () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   "V_ON_WITH_MODIFIERS": () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   "V_SHOW": () => (/* binding */ V_SHOW),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "createDOMCompilerError": () => (/* binding */ createDOMCompilerError),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parserOptions": () => (/* binding */ parserOptions),
/* harmony export */   "transformStyle": () => (/* binding */ transformStyle)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _registerRuntimeHelpe, _DOMErrorMessages;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var V_MODEL_RADIO = Symbol( true ? "vModelRadio" : 0);
var V_MODEL_CHECKBOX = Symbol( true ? "vModelCheckbox" : 0);
var V_MODEL_TEXT = Symbol( true ? "vModelText" : 0);
var V_MODEL_SELECT = Symbol( true ? "vModelSelect" : 0);
var V_MODEL_DYNAMIC = Symbol( true ? "vModelDynamic" : 0);
var V_ON_WITH_MODIFIERS = Symbol( true ? "vOnModifiersGuard" : 0);
var V_ON_WITH_KEYS = Symbol( true ? "vOnKeysGuard" : 0);
var V_SHOW = Symbol( true ? "vShow" : 0);
var TRANSITION = Symbol( true ? "Transition" : 0);
var TRANSITION_GROUP = Symbol( true ? "TransitionGroup" : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)((_registerRuntimeHelpe = {}, _defineProperty(_registerRuntimeHelpe, V_MODEL_RADIO, "vModelRadio"), _defineProperty(_registerRuntimeHelpe, V_MODEL_CHECKBOX, "vModelCheckbox"), _defineProperty(_registerRuntimeHelpe, V_MODEL_TEXT, "vModelText"), _defineProperty(_registerRuntimeHelpe, V_MODEL_SELECT, "vModelSelect"), _defineProperty(_registerRuntimeHelpe, V_MODEL_DYNAMIC, "vModelDynamic"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_MODIFIERS, "withModifiers"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_KEYS, "withKeys"), _defineProperty(_registerRuntimeHelpe, V_SHOW, "vShow"), _defineProperty(_registerRuntimeHelpe, TRANSITION, "Transition"), _defineProperty(_registerRuntimeHelpe, TRANSITION_GROUP, "TransitionGroup"), _registerRuntimeHelpe));
/* eslint-disable no-restricted-globals */

var decoder;

function decodeHtmlBrowser(raw) {
  var asAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!decoder) {
    decoder = document.createElement('div');
  }

  if (asAttr) {
    decoder.innerHTML = "<div foo=\"".concat(raw.replace(/"/g, '&quot;'), "\">");
    return decoder.children[0].getAttribute('foo');
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}

var isRawTextContainer = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
var parserOptions = {
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
  isNativeTag: function isNativeTag(tag) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag);
  },
  isPreTag: function isPreTag(tag) {
    return tag === 'pre';
  },
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: function isBuiltInComponent(tag) {
    if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, "Transition")) {
      return TRANSITION;
    } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, "TransitionGroup")) {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace: function getNamespace(tag, parent) {
    var ns = parent ? parent.ns : 0
    /* HTML */
    ;

    if (parent && ns === 2
    /* MATH_ML */
    ) {
        if (parent.tag === 'annotation-xml') {
          if (tag === 'svg') {
            return 1
            /* SVG */
            ;
          }

          if (parent.props.some(function (a) {
            return a.type === 6
            /* ATTRIBUTE */
            && a.name === 'encoding' && a.value != null && (a.value.content === 'text/html' || a.value.content === 'application/xhtml+xml');
          })) {
            ns = 0
            /* HTML */
            ;
          }
        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== 'mglyph' && tag !== 'malignmark') {
          ns = 0
          /* HTML */
          ;
        }
      } else if (parent && ns === 1
    /* SVG */
    ) {
        if (parent.tag === 'foreignObject' || parent.tag === 'desc' || parent.tag === 'title') {
          ns = 0
          /* HTML */
          ;
        }
      }

    if (ns === 0
    /* HTML */
    ) {
        if (tag === 'svg') {
          return 1
          /* SVG */
          ;
        }

        if (tag === 'math') {
          return 2
          /* MATH_ML */
          ;
        }
      }

    return ns;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode: function getTextMode(_ref) {
    var tag = _ref.tag,
        ns = _ref.ns;

    if (ns === 0
    /* HTML */
    ) {
        if (tag === 'textarea' || tag === 'title') {
          return 1
          /* RCDATA */
          ;
        }

        if (isRawTextContainer(tag)) {
          return 2
          /* RAWTEXT */
          ;
        }
      }

    return 0
    /* DATA */
    ;
  }
}; // Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.

var transformStyle = function transformStyle(node) {
  if (node.type === 1
  /* ELEMENT */
  ) {
      node.props.forEach(function (p, i) {
        if (p.type === 6
        /* ATTRIBUTE */
        && p.name === 'style' && p.value) {
          // replace p with an expression node
          node.props[i] = {
            type: 7
            /* DIRECTIVE */
            ,
            name: "bind",
            arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("style", true, p.loc),
            exp: parseInlineCSS(p.value.content, p.loc),
            modifiers: [],
            loc: p.loc
          };
        }
      });
    }
};

var parseInlineCSS = function parseInlineCSS(cssText, loc) {
  var normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3
  /* CAN_STRINGIFY */
  );
};

function createDOMCompilerError(code, loc) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}

var DOMErrorMessages = (_DOMErrorMessages = {}, _defineProperty(_DOMErrorMessages, 49
/* X_V_HTML_NO_EXPRESSION */
, "v-html is missing expression."), _defineProperty(_DOMErrorMessages, 50
/* X_V_HTML_WITH_CHILDREN */
, "v-html will override element children."), _defineProperty(_DOMErrorMessages, 51
/* X_V_TEXT_NO_EXPRESSION */
, "v-text is missing expression."), _defineProperty(_DOMErrorMessages, 52
/* X_V_TEXT_WITH_CHILDREN */
, "v-text will override element children."), _defineProperty(_DOMErrorMessages, 53
/* X_V_MODEL_ON_INVALID_ELEMENT */
, "v-model can only be used on <input>, <textarea> and <select> elements."), _defineProperty(_DOMErrorMessages, 54
/* X_V_MODEL_ARG_ON_ELEMENT */
, "v-model argument is not supported on plain elements."), _defineProperty(_DOMErrorMessages, 55
/* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
, "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead."), _defineProperty(_DOMErrorMessages, 56
/* X_V_MODEL_UNNECESSARY_VALUE */
, "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior."), _defineProperty(_DOMErrorMessages, 57
/* X_V_SHOW_NO_EXPRESSION */
, "v-show is missing expression."), _defineProperty(_DOMErrorMessages, 58
/* X_TRANSITION_INVALID_CHILDREN */
, "<Transition> expects exactly one child element or component."), _defineProperty(_DOMErrorMessages, 59
/* X_IGNORED_SIDE_EFFECT_TAG */
, "Tags with side effect (<script> and <style>) are ignored in client component templates."), _DOMErrorMessages);

var transformVHtml = function transformVHtml(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(49
    /* X_V_HTML_NO_EXPRESSION */
    , loc));
  }

  if (node.children.length) {
    context.onError(createDOMCompilerError(50
    /* X_V_HTML_WITH_CHILDREN */
    , loc));
    node.children.length = 0;
  }

  return {
    props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("innerHTML", true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))]
  };
};

var transformVText = function transformVText(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(51
    /* X_V_TEXT_NO_EXPRESSION */
    , loc));
  }

  if (node.children.length) {
    context.onError(createDOMCompilerError(52
    /* X_V_TEXT_WITH_CHILDREN */
    , loc));
    node.children.length = 0;
  }

  return {
    props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("textContent", true), exp ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))]
  };
};

var transformModel = function transformModel(dir, node, context) {
  var baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context); // base transform has errors OR component v-model (only need props)

  if (!baseResult.props.length || node.tagType === 1
  /* COMPONENT */
  ) {
      return baseResult;
    }

  if (dir.arg) {
    context.onError(createDOMCompilerError(54
    /* X_V_MODEL_ARG_ON_ELEMENT */
    , dir.arg.loc));
  }

  function checkDuplicatedValue() {
    var value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');

    if (value) {
      context.onError(createDOMCompilerError(56
      /* X_V_MODEL_UNNECESSARY_VALUE */
      , value.loc));
    }
  }

  var tag = node.tag;
  var isCustomElement = context.isCustomElement(tag);

  if (tag === 'input' || tag === 'textarea' || tag === 'select' || isCustomElement) {
    var directiveToUse = V_MODEL_TEXT;
    var isInvalidType = false;

    if (tag === 'input' || isCustomElement) {
      var type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, "type");

      if (type) {
        if (type.type === 7
        /* DIRECTIVE */
        ) {
            // :type="foo"
            directiveToUse = V_MODEL_DYNAMIC;
          } else if (type.value) {
          switch (type.value.content) {
            case 'radio':
              directiveToUse = V_MODEL_RADIO;
              break;

            case 'checkbox':
              directiveToUse = V_MODEL_CHECKBOX;
              break;

            case 'file':
              isInvalidType = true;
              context.onError(createDOMCompilerError(55
              /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
              , dir.loc));
              break;

            default:
              // text type
               true && checkDuplicatedValue();
              break;
          }
        }
      } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
        // element has bindings with dynamic keys, which can possibly contain
        // "type".
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
        // text type
         true && checkDuplicatedValue();
      }
    } else if (tag === 'select') {
      directiveToUse = V_MODEL_SELECT;
    } else {
      // textarea
       true && checkDuplicatedValue();
    } // inject runtime directive
    // by returning the helper symbol via needRuntime
    // the import will replaced a resolveDirective call.


    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(createDOMCompilerError(53
    /* X_V_MODEL_ON_INVALID_ELEMENT */
    , dir.loc));
  } // native vmodel doesn't need the `modelValue` props since they are also
  // passed to the runtime as `binding.value`. removing it reduces code size.


  baseResult.props = baseResult.props.filter(function (p) {
    return !(p.key.type === 4
    /* SIMPLE_EXPRESSION */
    && p.key.content === 'modelValue');
  });
  return baseResult;
};

var isEventOptionModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("passive,once,capture");
var isNonKeyModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)( // event propagation management
"stop,prevent,self," + // system modifiers + exact
"ctrl,shift,alt,meta,exact," + // mouse
"middle"); // left & right could be mouse or key modifiers based on event type

var maybeKeyModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
var isKeyboardEvent = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("onkeyup,onkeydown,onkeypress", true);

var resolveModifiers = function resolveModifiers(key, modifiers, context, loc) {
  var keyModifiers = [];
  var nonKeyModifiers = [];
  var eventOptionModifiers = [];

  for (var i = 0; i < modifiers.length; i++) {
    var modifier = modifiers[i];

    if (modifier === 'native' && (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)("COMPILER_V_ON_NATIVE"
    /* COMPILER_V_ON_NATIVE */
    , context, loc)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      // eventOptionModifiers: modifiers for addEventListener() options,
      // e.g. .passive & .capture
      eventOptionModifiers.push(modifier);
    } else {
      // runtimeModifiers: modifiers that needs runtime guards
      if (maybeKeyModifier(modifier)) {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }

  return {
    keyModifiers: keyModifiers,
    nonKeyModifiers: nonKeyModifiers,
    eventOptionModifiers: eventOptionModifiers
  };
};

var transformClick = function transformClick(key, event) {
  var isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
  return isStaticClick ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true) : key.type !== 4
  /* SIMPLE_EXPRESSION */
  ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(["(", key, ") === \"onClick\" ? \"".concat(event, "\" : ("), key, ")"]) : key;
};

var transformOn = function transformOn(dir, node, context) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, function (baseResult) {
    var modifiers = dir.modifiers;
    if (!modifiers.length) return baseResult;
    var _baseResult$props$ = baseResult.props[0],
        key = _baseResult$props$.key,
        handlerExp = _baseResult$props$.value;

    var _resolveModifiers = resolveModifiers(key, modifiers, context, dir.loc),
        keyModifiers = _resolveModifiers.keyModifiers,
        nonKeyModifiers = _resolveModifiers.nonKeyModifiers,
        eventOptionModifiers = _resolveModifiers.eventOptionModifiers; // normalize click.right and click.middle since they don't actually fire


    if (nonKeyModifiers.includes('right')) {
      key = transformClick(key, "onContextmenu");
    }

    if (nonKeyModifiers.includes('middle')) {
      key = transformClick(key, "onMouseup");
    }

    if (nonKeyModifiers.length) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);
    }

    if (keyModifiers.length && ( // if event name is dynamic, always wrap with keys guard
    !(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);
    }

    if (eventOptionModifiers.length) {
      var modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
      key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("".concat(key.content).concat(modifierPostfix), true) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(["(", key, ") + \"".concat(modifierPostfix, "\"")]);
    }

    return {
      props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
    };
  });
};

var transformShow = function transformShow(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(57
    /* X_V_SHOW_NO_EXPRESSION */
    , loc));
  }

  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

var warnTransitionChildren = function warnTransitionChildren(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && node.tagType === 1
  /* COMPONENT */
  ) {
      var component = context.isBuiltInComponent(node.tag);

      if (component === TRANSITION) {
        return function () {
          if (node.children.length && hasMultipleChildren(node)) {
            context.onError(createDOMCompilerError(58
            /* X_TRANSITION_INVALID_CHILDREN */
            , {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ''
            }));
          }
        };
      }
    }
};

function hasMultipleChildren(node) {
  // #1352 filter out potential comment nodes.
  var children = node.children = node.children.filter(function (c) {
    return c.type !== 3;
  }
  /* COMMENT */
  );
  var child = children[0];
  return children.length !== 1 || child.type === 11
  /* FOR */
  || child.type === 9
  /* IF */
  && child.branches.some(hasMultipleChildren);
}

var ignoreSideEffectTags = function ignoreSideEffectTags(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && node.tagType === 0
  /* ELEMENT */
  && (node.tag === 'script' || node.tag === 'style')) {
    context.onError(createDOMCompilerError(59
    /* X_IGNORED_SIDE_EFFECT_TAG */
    , node.loc));
    context.removeNode();
  }
};

var DOMNodeTransforms = [transformStyle].concat(_toConsumableArray( true ? [warnTransitionChildren] : 0));
var DOMDirectiveTransforms = {
  cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  on: transformOn,
  show: transformShow
};

function compile(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
    nodeTransforms: [// ignore <script> and <tag>
    // this is not put inside DOMNodeTransforms because that list is used
    // by compiler-ssr to generate vnode fallback branches
    ignoreSideEffectTags].concat(_toConsumableArray(DOMNodeTransforms), _toConsumableArray(options.nodeTransforms || [])),
    directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}

function parse(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}



/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var targetMap = new WeakMap();
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol( true ? 'iterate' : 0);
var MAP_KEY_ITERATE_KEY = Symbol( true ? 'Map key iterate' : 0);

function isEffect(fn) {
  return fn && fn._isEffect === true;
}

function effect(fn) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ;

  if (isEffect(fn)) {
    fn = fn.raw;
  }

  var effect = createReactiveEffect(fn, options);

  if (!options.lazy) {
    effect();
  }

  return effect;
}

function stop(effect) {
  if (effect.active) {
    cleanup(effect);

    if (effect.options.onStop) {
      effect.options.onStop();
    }

    effect.active = false;
  }
}

var uid = 0;

function createReactiveEffect(fn, options) {
  var effect = function reactiveEffect() {
    if (!effect.active) {
      return fn();
    }

    if (!effectStack.includes(effect)) {
      cleanup(effect);

      try {
        enableTracking();
        effectStack.push(effect);
        activeEffect = effect;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };

  effect.id = uid++;
  effect.allowRecurse = !!options.allowRecurse;
  effect._isEffect = true;
  effect.active = true;
  effect.raw = fn;
  effect.deps = [];
  effect.options = options;
  return effect;
}

function cleanup(effect) {
  var deps = effect.deps;

  if (deps.length) {
    for (var i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }

    deps.length = 0;
  }
}

var shouldTrack = true;
var trackStack = [];

function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}

function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}

function resetTracking() {
  var last = trackStack.pop();
  shouldTrack = last === undefined ? true : last;
}

function track(target, type, key) {
  if (!shouldTrack || activeEffect === undefined) {
    return;
  }

  var depsMap = targetMap.get(target);

  if (!depsMap) {
    targetMap.set(target, depsMap = new Map());
  }

  var dep = depsMap.get(key);

  if (!dep) {
    depsMap.set(key, dep = new Set());
  }

  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);

    if ( true && activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target: target,
        type: type,
        key: key
      });
    }
  }
}

function trigger(target, type, key, newValue, oldValue, oldTarget) {
  var depsMap = targetMap.get(target);

  if (!depsMap) {
    // never been tracked
    return;
  }

  var effects = new Set();

  var add = function add(effectsToAdd) {
    if (effectsToAdd) {
      effectsToAdd.forEach(function (effect) {
        if (effect !== activeEffect || effect.allowRecurse) {
          effects.add(effect);
        }
      });
    }
  };

  if (type === "clear"
  /* CLEAR */
  ) {
      // collection being cleared
      // trigger all effects for target
      depsMap.forEach(add);
    } else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
    depsMap.forEach(function (dep, key) {
      if (key === 'length' || key >= newValue) {
        add(dep);
      }
    });
  } else {
    // schedule runs for SET | ADD | DELETE
    if (key !== void 0) {
      add(depsMap.get(key));
    } // also run for iteration key on ADD | DELETE | Map.SET


    switch (type) {
      case "add"
      /* ADD */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          add(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
          // new index added to array -> length changes
          add(depsMap.get('length'));
        }

        break;

      case "delete"
      /* DELETE */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          add(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }

        break;

      case "set"
      /* SET */
      :
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
          add(depsMap.get(ITERATE_KEY));
        }

        break;
    }
  }

  var run = function run(effect) {
    if ( true && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect: effect,
        target: target,
        key: key,
        type: type,
        newValue: newValue,
        oldValue: oldValue,
        oldTarget: oldTarget
      });
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect);
    } else {
      effect();
    }
  };

  effects.forEach(run);
}

var isNonTrackableKeys = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)("__proto__,__v_isRef,__isVue");
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function (key) {
  return Symbol[key];
}).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
var get = /*#__PURE__*/createGetter();
var shallowGet = /*#__PURE__*/createGetter(false, true);
var readonlyGet = /*#__PURE__*/createGetter(true);
var shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);
var arrayInstrumentations = {};
['includes', 'indexOf', 'lastIndexOf'].forEach(function (key) {
  var method = Array.prototype[key];

  arrayInstrumentations[key] = function () {
    var arr = toRaw(this);

    for (var i = 0, l = this.length; i < l; i++) {
      track(arr, "get"
      /* GET */
      , i + '');
    } // we run the method using the original args first (which may be reactive)


    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var res = method.apply(arr, args);

    if (res === -1 || res === false) {
      // if that didn't work, run it again using raw values.
      return method.apply(arr, args.map(toRaw));
    } else {
      return res;
    }
  };
});
['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (key) {
  var method = Array.prototype[key];

  arrayInstrumentations[key] = function () {
    pauseTracking();

    for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var res = method.apply(this, args);
    resetTracking();
    return res;
  };
});

function createGetter() {
  var isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return function get(target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
        return !isReadonly;
      } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
        return isReadonly;
      } else if (key === "__v_raw"
    /* RAW */
    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }

    var targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);

    if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }

    var res = Reflect.get(target, key, receiver);

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }

    if (!isReadonly) {
      track(target, "get"
      /* GET */
      , key);
    }

    if (shallow) {
      return res;
    }

    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      var shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
      return shouldUnwrap ? res.value : res;
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      return isReadonly ? readonly(res) : reactive(res);
    }

    return res;
  };
}

var set = /*#__PURE__*/createSetter();
var shallowSet = /*#__PURE__*/createSetter(true);

function createSetter() {
  var shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }

    var hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    var result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add"
        /* ADD */
        , key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set"
        /* SET */
        , key, value, oldValue);
      }
    }

    return result;
  };
}

function deleteProperty(target, key) {
  var hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
  var oldValue = target[key];
  var result = Reflect.deleteProperty(target, key);

  if (result && hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function has(target, key) {
  var result = Reflect.has(target, key);

  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
    track(target, "has"
    /* HAS */
    , key);
  }

  return result;
}

function ownKeys(target) {
  track(target, "iterate"
  /* ITERATE */
  , (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
  return Reflect.ownKeys(target);
}

var mutableHandlers = {
  get: get,
  set: set,
  deleteProperty: deleteProperty,
  has: has,
  ownKeys: ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set: function set(target, key) {
    if (true) {
      console.warn("Set operation on key \"".concat(String(key), "\" failed: target is readonly."), target);
    }

    return true;
  },
  deleteProperty: function deleteProperty(target, key) {
    if (true) {
      console.warn("Delete operation on key \"".concat(String(key), "\" failed: target is readonly."), target);
    }

    return true;
  }
};
var shallowReactiveHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
}); // Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.

var shallowReadonlyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
  get: shallowReadonlyGet
});

var toReactive = function toReactive(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
};

var toReadonly = function toReadonly(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;
};

var toShallow = function toShallow(value) {
  return value;
};

var getProto = function getProto(v) {
  return Reflect.getPrototypeOf(v);
};

function get$1(target, key) {
  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // #1772: readonly(reactive(Map)) should return readonly + reactive version
  // of the value
  target = target["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get"
    /* GET */
    , key);
  }

  !isReadonly && track(rawTarget, "get"
  /* GET */
  , rawKey);

  var _getProto = getProto(rawTarget),
      has = _getProto.has;

  var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;

  if (has.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    // #3602 readonly(reactive(Map))
    // ensure that the nested reactive `Map` can do tracking for itself
    target.get(key);
  }
}

function has$1(key) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var target = this["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has"
    /* HAS */
    , key);
  }

  !isReadonly && track(rawTarget, "has"
  /* HAS */
  , rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}

function size(target) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  target = target["__v_raw"
  /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate"
  /* ITERATE */
  , ITERATE_KEY);
  return Reflect.get(target, 'size', target);
}

function add(value) {
  value = toRaw(value);
  var target = toRaw(this);
  var proto = getProto(target);
  var hadKey = proto.has.call(target, value);

  if (!hadKey) {
    target.add(value);
    trigger(target, "add"
    /* ADD */
    , value, value);
  }

  return this;
}

function set$1(key, value) {
  value = toRaw(value);
  var target = toRaw(this);

  var _getProto2 = getProto(target),
      has = _getProto2.has,
      get = _getProto2.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  var oldValue = get.call(target, key);
  target.set(key, value);

  if (!hadKey) {
    trigger(target, "add"
    /* ADD */
    , key, value);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
    trigger(target, "set"
    /* SET */
    , key, value, oldValue);
  }

  return this;
}

function deleteEntry(key) {
  var target = toRaw(this);

  var _getProto3 = getProto(target),
      has = _getProto3.has,
      get = _getProto3.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  var oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions

  var result = target.delete(key);

  if (hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function clear() {
  var target = toRaw(this);
  var hadItems = target.size !== 0;
  var oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0; // forward the operation before queueing reactions

  var result = target.clear();

  if (hadItems) {
    trigger(target, "clear"
    /* CLEAR */
    , undefined, undefined, oldTarget);
  }

  return result;
}

function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    var observed = this;
    var target = observed["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , ITERATE_KEY);
    return target.forEach(function (value, key) {
      // important: make sure the callback is
      // 1. invoked with the reactive map as `this` and 3rd arg
      // 2. the value received should be a corresponding reactive/readonly.
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}

function createIterableMethod(method, isReadonly, isShallow) {
  return function () {
    var target = this["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
    var isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;
    var isKeyOnly = method === 'keys' && targetIsMap;
    var innerIterator = target[method].apply(target, arguments);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the
    // values emitted from the real iterator

    return _defineProperty({
      // iterator protocol
      next: function next() {
        var _innerIterator$next = innerIterator.next(),
            value = _innerIterator$next.value,
            done = _innerIterator$next.done;

        return done ? {
          value: value,
          done: done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done: done
        };
      }
    }, Symbol.iterator, function () {
      return this;
    });
  };
}

function createReadonlyMethod(type) {
  return function () {
    if (true) {
      var key = (arguments.length <= 0 ? undefined : arguments[0]) ? "on key \"".concat(arguments.length <= 0 ? undefined : arguments[0], "\" ") : "";
      console.warn("".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type), " operation ").concat(key, "failed: target is readonly."), toRaw(this));
    }

    return type === "delete"
    /* DELETE */
    ? false : this;
  };
}

var mutableInstrumentations = {
  get: function get(key) {
    return get$1(this, key);
  },

  get size() {
    return size(this);
  },

  has: has$1,
  add: add,
  set: set$1,
  delete: deleteEntry,
  clear: clear,
  forEach: createForEach(false, false)
};
var shallowInstrumentations = {
  get: function get(key) {
    return get$1(this, key, false, true);
  },

  get size() {
    return size(this);
  },

  has: has$1,
  add: add,
  set: set$1,
  delete: deleteEntry,
  clear: clear,
  forEach: createForEach(false, true)
};
var readonlyInstrumentations = {
  get: function get(key) {
    return get$1(this, key, true);
  },

  get size() {
    return size(this, true);
  },

  has: function has(key) {
    return has$1.call(this, key, true);
  },
  add: createReadonlyMethod("add"
  /* ADD */
  ),
  set: createReadonlyMethod("set"
  /* SET */
  ),
  delete: createReadonlyMethod("delete"
  /* DELETE */
  ),
  clear: createReadonlyMethod("clear"
  /* CLEAR */
  ),
  forEach: createForEach(true, false)
};
var shallowReadonlyInstrumentations = {
  get: function get(key) {
    return get$1(this, key, true, true);
  },

  get size() {
    return size(this, true);
  },

  has: function has(key) {
    return has$1.call(this, key, true);
  },
  add: createReadonlyMethod("add"
  /* ADD */
  ),
  set: createReadonlyMethod("set"
  /* SET */
  ),
  delete: createReadonlyMethod("delete"
  /* DELETE */
  ),
  clear: createReadonlyMethod("clear"
  /* CLEAR */
  ),
  forEach: createForEach(true, true)
};
var iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
iteratorMethods.forEach(function (method) {
  mutableInstrumentations[method] = createIterableMethod(method, false, false);
  readonlyInstrumentations[method] = createIterableMethod(method, true, false);
  shallowInstrumentations[method] = createIterableMethod(method, false, true);
  shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
});

function createInstrumentationGetter(isReadonly, shallow) {
  var instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return function (target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
        return !isReadonly;
      } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
        return isReadonly;
      } else if (key === "__v_raw"
    /* RAW */
    ) {
        return target;
      }

    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}

var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, true)
};

function checkIdentityKeys(target, has, key) {
  var rawKey = toRaw(key);

  if (rawKey !== key && has.call(target, rawKey)) {
    var type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
    console.warn("Reactive ".concat(type, " contains both the raw and reactive ") + "versions of the same object".concat(type === "Map" ? " as keys" : "", ", ") + "which can lead to inconsistencies. " + "Avoid differentiating between the raw and reactive versions " + "of an object and only use the reactive version if possible.");
  }
}

var reactiveMap = new WeakMap();
var shallowReactiveMap = new WeakMap();
var readonlyMap = new WeakMap();
var shallowReadonlyMap = new WeakMap();

function targetTypeMap(rawType) {
  switch (rawType) {
    case 'Object':
    case 'Array':
      return 1
      /* COMMON */
      ;

    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
      /* COLLECTION */
      ;

    default:
      return 0
      /* INVALID */
      ;
  }
}

function getTargetType(value) {
  return value["__v_skip"
  /* SKIP */
  ] || !Object.isExtensible(value) ? 0
  /* INVALID */
  : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}

function reactive(target) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (target && target["__v_isReadonly"
  /* IS_READONLY */
  ]) {
    return target;
  }

  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */


function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */


function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */


function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}

function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    if (true) {
      console.warn("value cannot be made reactive: ".concat(String(target)));
    }

    return target;
  } // target is already a Proxy, return it.
  // exception: calling readonly() on a reactive object


  if (target["__v_raw"
  /* RAW */
  ] && !(isReadonly && target["__v_isReactive"
  /* IS_REACTIVE */
  ])) {
    return target;
  } // target already has corresponding Proxy


  var existingProxy = proxyMap.get(target);

  if (existingProxy) {
    return existingProxy;
  } // only a whitelist of value types can be observed.


  var targetType = getTargetType(target);

  if (targetType === 0
  /* INVALID */
  ) {
      return target;
    }

  var proxy = new Proxy(target, targetType === 2
  /* COLLECTION */
  ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}

function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"
    /* RAW */
    ]);
  }

  return !!(value && value["__v_isReactive"
  /* IS_REACTIVE */
  ]);
}

function isReadonly(value) {
  return !!(value && value["__v_isReadonly"
  /* IS_READONLY */
  ]);
}

function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

function toRaw(observed) {
  return observed && toRaw(observed["__v_raw"
  /* RAW */
  ]) || observed;
}

function markRaw(value) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip"
  /* SKIP */
  , true);
  return value;
}

var convert = function convert(val) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) ? reactive(val) : val;
};

function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}

function ref(value) {
  return createRef(value);
}

function shallowRef(value) {
  return createRef(value, true);
}

var RefImpl = /*#__PURE__*/function () {
  function RefImpl(_rawValue) {
    var _shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, RefImpl);

    this._rawValue = _rawValue;
    this._shallow = _shallow;
    this.__v_isRef = true;
    this._value = _shallow ? _rawValue : convert(_rawValue);
  }

  _createClass(RefImpl, [{
    key: "value",
    get: function get() {
      track(toRaw(this), "get"
      /* GET */
      , 'value');
      return this._value;
    },
    set: function set(newVal) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(toRaw(newVal), this._rawValue)) {
        this._rawValue = newVal;
        this._value = this._shallow ? newVal : convert(newVal);
        trigger(toRaw(this), "set"
        /* SET */
        , 'value', newVal);
      }
    }
  }]);

  return RefImpl;
}();

function createRef(rawValue) {
  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (isRef(rawValue)) {
    return rawValue;
  }

  return new RefImpl(rawValue, shallow);
}

function triggerRef(ref) {
  trigger(toRaw(ref), "set"
  /* SET */
  , 'value',  true ? ref.value : 0);
}

function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}

var shallowUnwrapHandlers = {
  get: function get(target, key, receiver) {
    return unref(Reflect.get(target, key, receiver));
  },
  set: function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};

function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

var CustomRefImpl = /*#__PURE__*/function () {
  function CustomRefImpl(factory) {
    var _this = this;

    _classCallCheck(this, CustomRefImpl);

    this.__v_isRef = true;

    var _factory = factory(function () {
      return track(_this, "get"
      /* GET */
      ,
      /* GET */
      'value');
    }, function () {
      return trigger(_this, "set"
      /* SET */
      ,
      /* SET */
      'value');
    }),
        get = _factory.get,
        set = _factory.set;

    this._get = get;
    this._set = set;
  }

  _createClass(CustomRefImpl, [{
    key: "value",
    get: function get() {
      return this._get();
    },
    set: function set(newVal) {
      this._set(newVal);
    }
  }]);

  return CustomRefImpl;
}();

function customRef(factory) {
  return new CustomRefImpl(factory);
}

function toRefs(object) {
  if ( true && !isProxy(object)) {
    console.warn("toRefs() expects a reactive object but received a plain one.");
  }

  var ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};

  for (var key in object) {
    ret[key] = toRef(object, key);
  }

  return ret;
}

var ObjectRefImpl = /*#__PURE__*/function () {
  function ObjectRefImpl(_object, _key) {
    _classCallCheck(this, ObjectRefImpl);

    this._object = _object;
    this._key = _key;
    this.__v_isRef = true;
  }

  _createClass(ObjectRefImpl, [{
    key: "value",
    get: function get() {
      return this._object[this._key];
    },
    set: function set(newVal) {
      this._object[this._key] = newVal;
    }
  }]);

  return ObjectRefImpl;
}();

function toRef(object, key) {
  return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);
}

var ComputedRefImpl = /*#__PURE__*/function () {
  function ComputedRefImpl(getter, _setter, isReadonly) {
    var _this2 = this;

    _classCallCheck(this, ComputedRefImpl);

    this._setter = _setter;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = effect(getter, {
      lazy: true,
      scheduler: function scheduler() {
        if (!_this2._dirty) {
          _this2._dirty = true;
          trigger(toRaw(_this2), "set"
          /* SET */
          , 'value');
        }
      }
    });
    this["__v_isReadonly"
    /* IS_READONLY */
    ] = isReadonly;
  }

  _createClass(ComputedRefImpl, [{
    key: "value",
    get: function get() {
      // the computed ref may get wrapped by other proxies e.g. readonly() #3376
      var self = toRaw(this);

      if (self._dirty) {
        self._value = this.effect();
        self._dirty = false;
      }

      track(self, "get"
      /* GET */
      , 'value');
      return self._value;
    },
    set: function set(newValue) {
      this._setter(newValue);
    }
  }]);

  return ComputedRefImpl;
}();

function computed(getterOrOptions) {
  var getter;
  var setter;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
    getter = getterOrOptions;
    setter =  true ? function () {
      console.warn('Write operation failed: computed value is readonly');
    } : 0;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }

  return new ComputedRefImpl(getter, setter, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions) || !getterOrOptions.set);
}



/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment$1),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmit": () => (/* binding */ defineEmit),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "useContext": () => (/* binding */ useContext),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _ErrorTypeStrings, _deprecationData;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





var stack = [];

function pushWarningContext(vnode) {
  stack.push(vnode);
}

function popWarningContext() {
  stack.pop();
}

function warn(msg) {
  // avoid props formatting or warn handler tracking deps that might be mutated
  // during patch, leading to infinite recursion.
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
  var instance = stack.length ? stack[stack.length - 1].component : null;
  var appWarnHandler = instance && instance.appContext.config.warnHandler;
  var trace = getComponentTrace();

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11
    /* APP_WARN_HANDLER */
    , [msg + args.join(''), instance && instance.proxy, trace.map(function (_ref) {
      var vnode = _ref.vnode;
      return "at <".concat(formatComponentName(instance, vnode.type), ">");
    }).join('\n'), trace]);
  } else {
    var _console;

    var warnArgs = ["[Vue warn]: ".concat(msg)].concat(args);
    /* istanbul ignore if */

    if (trace.length && // avoid spamming console during tests
    !false) {
      warnArgs.push.apply(warnArgs, ["\n"].concat(_toConsumableArray(formatTrace(trace))));
    }

    (_console = console).warn.apply(_console, _toConsumableArray(warnArgs));
  }

  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}

function getComponentTrace() {
  var currentVNode = stack[stack.length - 1];

  if (!currentVNode) {
    return [];
  } // we can't just use the stack because it will be incomplete during updates
  // that did not start from the root. Re-construct the parent chain using
  // instance parent pointers.


  var normalizedStack = [];

  while (currentVNode) {
    var last = normalizedStack[0];

    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }

    var parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }

  return normalizedStack;
}
/* istanbul ignore next */


function formatTrace(trace) {
  var logs = [];
  trace.forEach(function (entry, i) {
    logs.push.apply(logs, _toConsumableArray(i === 0 ? [] : ["\n"]).concat(_toConsumableArray(formatTraceEntry(entry))));
  });
  return logs;
}

function formatTraceEntry(_ref2) {
  var vnode = _ref2.vnode,
      recurseCount = _ref2.recurseCount;
  var postfix = recurseCount > 0 ? "... (".concat(recurseCount, " recursive calls)") : "";
  var isRoot = vnode.component ? vnode.component.parent == null : false;
  var open = " at <".concat(formatComponentName(vnode.component, vnode.type, isRoot));
  var close = ">" + postfix;
  return vnode.props ? [open].concat(_toConsumableArray(formatProps(vnode.props)), [close]) : [open + close];
}
/* istanbul ignore next */


function formatProps(props) {
  var res = [];
  var keys = Object.keys(props);
  keys.slice(0, 3).forEach(function (key) {
    res.push.apply(res, _toConsumableArray(formatProp(key, props[key])));
  });

  if (keys.length > 3) {
    res.push(" ...");
  }

  return res;
}
/* istanbul ignore next */


function formatProp(key, value, raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    value = JSON.stringify(value);
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
    return raw ? value : ["".concat(key, "=Ref<"), value, ">"];
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    return ["".concat(key, "=fn").concat(value.name ? "<".concat(value.name, ">") : "")];
  } else {
    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
    return raw ? value : ["".concat(key, "="), value];
  }
}

var ErrorTypeStrings = (_ErrorTypeStrings = {}, _defineProperty(_ErrorTypeStrings, "bc"
/* BEFORE_CREATE */
, 'beforeCreate hook'), _defineProperty(_ErrorTypeStrings, "c"
/* CREATED */
, 'created hook'), _defineProperty(_ErrorTypeStrings, "bm"
/* BEFORE_MOUNT */
, 'beforeMount hook'), _defineProperty(_ErrorTypeStrings, "m"
/* MOUNTED */
, 'mounted hook'), _defineProperty(_ErrorTypeStrings, "bu"
/* BEFORE_UPDATE */
, 'beforeUpdate hook'), _defineProperty(_ErrorTypeStrings, "u"
/* UPDATED */
, 'updated'), _defineProperty(_ErrorTypeStrings, "bum"
/* BEFORE_UNMOUNT */
, 'beforeUnmount hook'), _defineProperty(_ErrorTypeStrings, "um"
/* UNMOUNTED */
, 'unmounted hook'), _defineProperty(_ErrorTypeStrings, "a"
/* ACTIVATED */
, 'activated hook'), _defineProperty(_ErrorTypeStrings, "da"
/* DEACTIVATED */
, 'deactivated hook'), _defineProperty(_ErrorTypeStrings, "ec"
/* ERROR_CAPTURED */
, 'errorCaptured hook'), _defineProperty(_ErrorTypeStrings, "rtc"
/* RENDER_TRACKED */
, 'renderTracked hook'), _defineProperty(_ErrorTypeStrings, "rtg"
/* RENDER_TRIGGERED */
, 'renderTriggered hook'), _defineProperty(_ErrorTypeStrings, 0
/* SETUP_FUNCTION */
, 'setup function'), _defineProperty(_ErrorTypeStrings, 1
/* RENDER_FUNCTION */
, 'render function'), _defineProperty(_ErrorTypeStrings, 2
/* WATCH_GETTER */
, 'watcher getter'), _defineProperty(_ErrorTypeStrings, 3
/* WATCH_CALLBACK */
, 'watcher callback'), _defineProperty(_ErrorTypeStrings, 4
/* WATCH_CLEANUP */
, 'watcher cleanup function'), _defineProperty(_ErrorTypeStrings, 5
/* NATIVE_EVENT_HANDLER */
, 'native event handler'), _defineProperty(_ErrorTypeStrings, 6
/* COMPONENT_EVENT_HANDLER */
, 'component event handler'), _defineProperty(_ErrorTypeStrings, 7
/* VNODE_HOOK */
, 'vnode hook'), _defineProperty(_ErrorTypeStrings, 8
/* DIRECTIVE_HOOK */
, 'directive hook'), _defineProperty(_ErrorTypeStrings, 9
/* TRANSITION_HOOK */
, 'transition hook'), _defineProperty(_ErrorTypeStrings, 10
/* APP_ERROR_HANDLER */
, 'app errorHandler'), _defineProperty(_ErrorTypeStrings, 11
/* APP_WARN_HANDLER */
, 'app warnHandler'), _defineProperty(_ErrorTypeStrings, 12
/* FUNCTION_REF */
, 'ref function'), _defineProperty(_ErrorTypeStrings, 13
/* ASYNC_COMPONENT_LOADER */
, 'async component loader'), _defineProperty(_ErrorTypeStrings, 14
/* SCHEDULER */
, 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'), _ErrorTypeStrings);

function callWithErrorHandling(fn, instance, type, args) {
  var res;

  try {
    res = args ? fn.apply(void 0, _toConsumableArray(args)) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }

  return res;
}

function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
    var res = callWithErrorHandling(fn, instance, type, args);

    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
      res.catch(function (err) {
        handleError(err, instance, type);
      });
    }

    return res;
  }

  var values = [];

  for (var i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }

  return values;
}

function handleError(err, instance, type) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var contextVNode = instance ? instance.vnode : null;

  if (instance) {
    var cur = instance.parent; // the exposed instance is the render proxy to keep it consistent with 2.x

    var exposedInstance = instance.proxy; // in production the hook receives only the error code

    var errorInfo =  true ? ErrorTypeStrings[type] : 0;

    while (cur) {
      var errorCapturedHooks = cur.ec;

      if (errorCapturedHooks) {
        for (var i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }

      cur = cur.parent;
    } // app-level handling


    var appErrorHandler = instance.appContext.config.errorHandler;

    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10
      /* APP_ERROR_HANDLER */
      , [err, exposedInstance, errorInfo]);
      return;
    }
  }

  logError(err, type, contextVNode, throwInDev);
}

function logError(err, type, contextVNode) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (true) {
    var info = ErrorTypeStrings[type];

    if (contextVNode) {
      pushWarningContext(contextVNode);
    }

    warn("Unhandled error".concat(info ? " during execution of ".concat(info) : ""));

    if (contextVNode) {
      popWarningContext();
    } // crash in dev by default so it's more noticeable


    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {}
}

var isFlushing = false;
var isFlushPending = false;
var queue = [];
var flushIndex = 0;
var pendingPreFlushCbs = [];
var activePreFlushCbs = null;
var preFlushIndex = 0;
var pendingPostFlushCbs = [];
var activePostFlushCbs = null;
var postFlushIndex = 0;
var resolvedPromise = Promise.resolve();
var currentFlushPromise = null;
var currentPreFlushParentJob = null;
var RECURSION_LIMIT = 100;

function nextTick(fn) {
  var p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
} // #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.


function findInsertionIndex(job) {
  // the start index should be `flushIndex + 1`
  var start = flushIndex + 1;
  var end = queue.length;
  var jobId = getId(job);

  while (start < end) {
    var middle = start + end >>> 1;
    var middleJobId = getId(queue[middle]);
    middleJobId < jobId ? start = middle + 1 : end = middle;
  }

  return start;
}

function queueJob(job) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    var pos = findInsertionIndex(job);

    if (pos > -1) {
      queue.splice(pos, 0, job);
    } else {
      queue.push(job);
    }

    queueFlush();
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}

function invalidateJob(job) {
  var i = queue.indexOf(job);

  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}

function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    // if cb is an array, it is a component lifecycle hook which can only be
    // triggered by a job, which is already deduped in the main queue, so
    // we can skip duplicate check here to improve perf
    pendingQueue.push.apply(pendingQueue, _toConsumableArray(cb));
  }

  queueFlush();
}

function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

function flushPreFlushCbs(seen) {
  var parentJob = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = _toConsumableArray(new Set(pendingPreFlushCbs));
    pendingPreFlushCbs.length = 0;

    if (true) {
      seen = seen || new Map();
    }

    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
        continue;
      }

      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null; // recursively flush until it drains

    flushPreFlushCbs(seen, parentJob);
  }
}

function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    var deduped = _toConsumableArray(new Set(pendingPostFlushCbs));

    pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call

    if (activePostFlushCbs) {
      var _activePostFlushCbs;

      (_activePostFlushCbs = activePostFlushCbs).push.apply(_activePostFlushCbs, _toConsumableArray(deduped));

      return;
    }

    activePostFlushCbs = deduped;

    if (true) {
      seen = seen || new Map();
    }

    activePostFlushCbs.sort(function (a, b) {
      return getId(a) - getId(b);
    });

    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }

      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}

var getId = function getId(job) {
  return job.id == null ? Infinity : job.id;
};

function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;

  if (true) {
    seen = seen || new Map();
  }

  flushPreFlushCbs(seen); // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child so its render effect will have smaller
  //    priority number)
  // 2. If a component is unmounted during a parent component's update,
  //    its update can be skipped.

  queue.sort(function (a, b) {
    return getId(a) - getId(b);
  });

  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      var job = queue[flushIndex];

      if (job && job.active !== false) {
        if ( true && checkRecursiveUpdates(seen, job)) {
          continue;
        }

        callWithErrorHandling(job, null, 14
        /* SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null; // some postFlushCb queued jobs!
    // keep flushing until it drains.

    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}

function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    var count = seen.get(fn);

    if (count > RECURSION_LIMIT) {
      var instance = fn.ownerInstance;
      var componentName = instance && getComponentName(instance.type);
      warn("Maximum recursive updates exceeded".concat(componentName ? " in component <".concat(componentName, ">") : "", ". ") + "This means you have a reactive effect that is mutating its own " + "dependencies and thus recursively triggering itself. Possible sources " + "include component template, render function, updated hook or " + "watcher source function.");
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
/* eslint-disable no-restricted-globals */


var isHmrUpdating = false;
var hmrDirtyComponents = new Set(); // Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.

if (true) {
  var globalObject = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {};
  globalObject.__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}

var map = new Map();

function registerHMR(instance) {
  var id = instance.type.__hmrId;
  var record = map.get(id);

  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }

  record.instances.add(instance);
}

function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}

function createRecord(id, component) {
  if (!component) {
    warn("HMR API usage is out of date.\n" + "Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant " + "dependency that handles Vue SFC compilation.");
    component = {};
  }

  if (map.has(id)) {
    return false;
  }

  map.set(id, {
    component: isClassComponent(component) ? component.__vccOpts : component,
    instances: new Set()
  });
  return true;
}

function rerender(id, newRender) {
  var record = map.get(id);
  if (!record) return;
  if (newRender) record.component.render = newRender; // Array.from creates a snapshot which avoids the set being mutated during
  // updates

  Array.from(record.instances).forEach(function (instance) {
    if (newRender) {
      instance.render = newRender;
    }

    instance.renderCache = []; // this flag forces child components with slot content to update

    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}

function reload(id, newComp) {
  var record = map.get(id);
  if (!record) return; // Array.from creates a snapshot which avoids the set being mutated during
  // updates

  var component = record.component,
      instances = record.instances;

  if (!hmrDirtyComponents.has(component)) {
    // 1. Update existing comp definition to match new one
    newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(component, newComp);

    for (var key in component) {
      if (key !== '__file' && !(key in newComp)) {
        delete component[key];
      }
    } // 2. Mark component dirty. This forces the renderer to replace the component
    // on patch.


    hmrDirtyComponents.add(component); // 3. Make sure to unmark the component after the reload.

    queuePostFlushCb(function () {
      hmrDirtyComponents.delete(component);
    });
  }

  Array.from(instances).forEach(function (instance) {
    if (instance.parent) {
      // 4. Force the parent instance to re-render. This will cause all updated
      // components to be unmounted and re-mounted. Queue the update so that we
      // don't end up forcing the same parent to re-render multiple times.
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      // root instance mounted via createApp() has a reload method
      instance.appContext.reload();
    } else if (typeof window !== 'undefined') {
      // root instance inside tree created via raw render(). Force reload.
      window.location.reload();
    } else {
      console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
    }
  });
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn("[HMR] Something went wrong during Vue component hot-reload. " + "Full reload required.");
    }
  };
}

var devtools;

function setDevtoolsHook(hook) {
  devtools = hook;
}

function devtoolsInitApp(app, version) {
  // TODO queue if devtools is undefined
  if (!devtools) return;
  devtools.emit("app:init"
  /* APP_INIT */
  , app, version, {
    Fragment: Fragment,
    Text: Text,
    Comment: Comment$1,
    Static: Static
  });
}

function devtoolsUnmountApp(app) {
  if (!devtools) return;
  devtools.emit("app:unmount"
  /* APP_UNMOUNT */
  , app);
}

var devtoolsComponentAdded = /*#__PURE__*/createDevtoolsComponentHook("component:added"
/* COMPONENT_ADDED */
);
var devtoolsComponentUpdated = /*#__PURE__*/createDevtoolsComponentHook("component:updated"
/* COMPONENT_UPDATED */
);
var devtoolsComponentRemoved = /*#__PURE__*/createDevtoolsComponentHook("component:removed"
/* COMPONENT_REMOVED */
);

function createDevtoolsComponentHook(hook) {
  return function (component) {
    if (!devtools) return;
    devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
  };
}

var devtoolsPerfStart = /*#__PURE__*/createDevtoolsPerformanceHook("perf:start"
/* PERFORMANCE_START */
);
var devtoolsPerfEnd = /*#__PURE__*/createDevtoolsPerformanceHook("perf:end"
/* PERFORMANCE_END */
);

function createDevtoolsPerformanceHook(hook) {
  return function (component, type, time) {
    if (!devtools) return;
    devtools.emit(hook, component.appContext.app, component.uid, component, type, time);
  };
}

function devtoolsComponentEmit(component, event, params) {
  if (!devtools) return;
  devtools.emit("component:emit"
  /* COMPONENT_EMIT */
  , component.appContext.app, component, event, params);
}

var deprecationData = (_deprecationData = {}, _defineProperty(_deprecationData, "GLOBAL_MOUNT"
/* GLOBAL_MOUNT */
, {
  message: "The global app bootstrapping API has changed: vm.$mount() and the \"el\" " + "option have been removed. Use createApp(RootComponent).mount() instead.",
  link: "https://v3.vuejs.org/guide/migration/global-api.html#mounting-app-instance"
}), _defineProperty(_deprecationData, "GLOBAL_MOUNT_CONTAINER"
/* GLOBAL_MOUNT_CONTAINER */
, {
  message: "Vue detected directives on the mount container. " + "In Vue 3, the container is no longer considered part of the template " + "and will not be processed/replaced.",
  link: "https://v3.vuejs.org/guide/migration/mount-changes.html"
}), _defineProperty(_deprecationData, "GLOBAL_EXTEND"
/* GLOBAL_EXTEND */
, {
  message: "Vue.extend() has been removed in Vue 3. " + "Use defineComponent() instead.",
  link: "https://v3.vuejs.org/api/global-api.html#definecomponent"
}), _defineProperty(_deprecationData, "GLOBAL_PROTOTYPE"
/* GLOBAL_PROTOTYPE */
, {
  message: "Vue.prototype is no longer available in Vue 3. " + "Use app.config.globalProperties instead.",
  link: "https://v3.vuejs.org/guide/migration/global-api.html#vue-prototype-replaced-by-config-globalproperties"
}), _defineProperty(_deprecationData, "GLOBAL_SET"
/* GLOBAL_SET */
, {
  message: "Vue.set() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "GLOBAL_DELETE"
/* GLOBAL_DELETE */
, {
  message: "Vue.delete() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "GLOBAL_OBSERVABLE"
/* GLOBAL_OBSERVABLE */
, {
  message: "Vue.observable() has been removed. " + "Use `import { reactive } from \"vue\"` from Composition API instead.",
  link: "https://v3.vuejs.org/api/basic-reactivity.html"
}), _defineProperty(_deprecationData, "GLOBAL_PRIVATE_UTIL"
/* GLOBAL_PRIVATE_UTIL */
, {
  message: "Vue.util has been removed. Please refactor to avoid its usage " + "since it was an internal API even in Vue 2."
}), _defineProperty(_deprecationData, "CONFIG_SILENT"
/* CONFIG_SILENT */
, {
  message: "config.silent has been removed because it is not good practice to " + "intentionally suppress warnings. You can use your browser console's " + "filter features to focus on relevant messages."
}), _defineProperty(_deprecationData, "CONFIG_DEVTOOLS"
/* CONFIG_DEVTOOLS */
, {
  message: "config.devtools has been removed. To enable devtools for " + "production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.",
  link: "https://github.com/vuejs/vue-next/tree/master/packages/vue#bundler-build-feature-flags"
}), _defineProperty(_deprecationData, "CONFIG_KEY_CODES"
/* CONFIG_KEY_CODES */
, {
  message: "config.keyCodes has been removed. " + "In Vue 3, you can directly use the kebab-case key names as v-on modifiers.",
  link: "https://v3.vuejs.org/guide/migration/keycode-modifiers.html"
}), _defineProperty(_deprecationData, "CONFIG_PRODUCTION_TIP"
/* CONFIG_PRODUCTION_TIP */
, {
  message: "config.productionTip has been removed.",
  link: "https://v3.vuejs.org/guide/migration/global-api.html#config-productiontip-removed"
}), _defineProperty(_deprecationData, "CONFIG_IGNORED_ELEMENTS"
/* CONFIG_IGNORED_ELEMENTS */
, {
  message: function message() {
    var msg = "config.ignoredElements has been removed.";

    if (isRuntimeOnly()) {
      msg += " Pass the \"isCustomElement\" option to @vue/compiler-dom instead.";
    } else {
      msg += " Use config.isCustomElement instead.";
    }

    return msg;
  },
  link: "https://v3.vuejs.org/guide/migration/global-api.html#config-ignoredelements-is-now-config-iscustomelement"
}), _defineProperty(_deprecationData, "CONFIG_WHITESPACE"
/* CONFIG_WHITESPACE */
, {
  // this warning is only relevant in the full build when using runtime
  // compilation, so it's put in the runtime compatConfig list.
  message: "Vue 3 compiler's whitespace option will default to \"condense\" instead of " + "\"preserve\". To suppress this warning, provide an explicit value for " + "`config.compilerOptions.whitespace`."
}), _defineProperty(_deprecationData, "CONFIG_OPTION_MERGE_STRATS"
/* CONFIG_OPTION_MERGE_STRATS */
, {
  message: "config.optionMergeStrategies no longer exposes internal strategies. " + "Use custom merge functions instead."
}), _defineProperty(_deprecationData, "INSTANCE_SET"
/* INSTANCE_SET */
, {
  message: "vm.$set() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "INSTANCE_DELETE"
/* INSTANCE_DELETE */
, {
  message: "vm.$delete() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "INSTANCE_DESTROY"
/* INSTANCE_DESTROY */
, {
  message: "vm.$destroy() has been removed. Use app.unmount() instead.",
  link: "https://v3.vuejs.org/api/application-api.html#unmount"
}), _defineProperty(_deprecationData, "INSTANCE_EVENT_EMITTER"
/* INSTANCE_EVENT_EMITTER */
, {
  message: "vm.$on/$once/$off() have been removed. " + "Use an external event emitter library instead.",
  link: "https://v3.vuejs.org/guide/migration/events-api.html"
}), _defineProperty(_deprecationData, "INSTANCE_EVENT_HOOKS"
/* INSTANCE_EVENT_HOOKS */
, {
  message: function message(event) {
    return "\"".concat(event, "\" lifecycle events are no longer supported. From templates, ") + "use the \"vnode\" prefix instead of \"hook:\". For example, @".concat(event, " ") + "should be changed to @vnode-".concat(event.slice(5), ". ") + "From JavaScript, use Composition API to dynamically register lifecycle " + "hooks.";
  },
  link: "https://v3.vuejs.org/guide/migration/vnode-lifecycle-events.html"
}), _defineProperty(_deprecationData, "INSTANCE_CHILDREN"
/* INSTANCE_CHILDREN */
, {
  message: "vm.$children has been removed. Consider refactoring your logic " + "to avoid relying on direct access to child components.",
  link: "https://v3.vuejs.org/guide/migration/children.html"
}), _defineProperty(_deprecationData, "INSTANCE_LISTENERS"
/* INSTANCE_LISTENERS */
, {
  message: "vm.$listeners has been removed. In Vue 3, parent v-on listeners are " + "included in vm.$attrs and it is no longer necessary to separately use " + "v-on=\"$listeners\" if you are already using v-bind=\"$attrs\". " + "(Note: the Vue 3 behavior only applies if this compat config is disabled)",
  link: "https://v3.vuejs.org/guide/migration/listeners-removed.html"
}), _defineProperty(_deprecationData, "INSTANCE_SCOPED_SLOTS"
/* INSTANCE_SCOPED_SLOTS */
, {
  message: "vm.$scopedSlots has been removed. Use vm.$slots instead.",
  link: "https://v3.vuejs.org/guide/migration/slots-unification.html"
}), _defineProperty(_deprecationData, "INSTANCE_ATTRS_CLASS_STYLE"
/* INSTANCE_ATTRS_CLASS_STYLE */
, {
  message: function message(componentName) {
    return "Component <".concat(componentName || 'Anonymous', "> has `inheritAttrs: false` but is ") + "relying on class/style fallthrough from parent. In Vue 3, class/style " + "are now included in $attrs and will no longer fallthrough when " + "inheritAttrs is false. If you are already using v-bind=\"$attrs\" on " + "component root it should render the same end result. " + "If you are binding $attrs to a non-root element and expecting " + "class/style to fallthrough on root, you will need to now manually bind " + "them on root via :class=\"$attrs.class\".";
  },
  link: "https://v3.vuejs.org/guide/migration/attrs-includes-class-style.html"
}), _defineProperty(_deprecationData, "OPTIONS_DATA_FN"
/* OPTIONS_DATA_FN */
, {
  message: "The \"data\" option can no longer be a plain object. " + "Always use a function.",
  link: "https://v3.vuejs.org/guide/migration/data-option.html"
}), _defineProperty(_deprecationData, "OPTIONS_DATA_MERGE"
/* OPTIONS_DATA_MERGE */
, {
  message: function message(key) {
    return "Detected conflicting key \"".concat(key, "\" when merging data option values. ") + "In Vue 3, data keys are merged shallowly and will override one another.";
  },
  link: "https://v3.vuejs.org/guide/migration/data-option.html#mixin-merge-behavior-change"
}), _defineProperty(_deprecationData, "OPTIONS_BEFORE_DESTROY"
/* OPTIONS_BEFORE_DESTROY */
, {
  message: "`beforeDestroy` has been renamed to `beforeUnmount`."
}), _defineProperty(_deprecationData, "OPTIONS_DESTROYED"
/* OPTIONS_DESTROYED */
, {
  message: "`destroyed` has been renamed to `unmounted`."
}), _defineProperty(_deprecationData, "WATCH_ARRAY"
/* WATCH_ARRAY */
, {
  message: "\"watch\" option or vm.$watch on an array value will no longer " + "trigger on array mutation unless the \"deep\" option is specified. " + "If current usage is intended, you can disable the compat behavior and " + "suppress this warning with:" + "\n\n  configureCompat({ ".concat("WATCH_ARRAY"
  /* WATCH_ARRAY */
  , ": false })\n"),
  link: "https://v3.vuejs.org/guide/migration/watch.html"
}), _defineProperty(_deprecationData, "PROPS_DEFAULT_THIS"
/* PROPS_DEFAULT_THIS */
, {
  message: function message(key) {
    return "props default value function no longer has access to \"this\". The compat " + "build only offers access to this.$options." + "(found in prop \"".concat(key, "\")");
  },
  link: "https://v3.vuejs.org/guide/migration/props-default-this.html"
}), _defineProperty(_deprecationData, "CUSTOM_DIR"
/* CUSTOM_DIR */
, {
  message: function message(legacyHook, newHook) {
    return "Custom directive hook \"".concat(legacyHook, "\" has been removed. ") + "Use \"".concat(newHook, "\" instead.");
  },
  link: "https://v3.vuejs.org/guide/migration/custom-directives.html"
}), _defineProperty(_deprecationData, "V_FOR_REF"
/* V_FOR_REF */
, {
  message: "Ref usage on v-for no longer creates array ref values in Vue 3. " + "Consider using function refs or refactor to avoid ref usage altogether.",
  link: "https://v3.vuejs.org/guide/migration/array-refs.html"
}), _defineProperty(_deprecationData, "V_ON_KEYCODE_MODIFIER"
/* V_ON_KEYCODE_MODIFIER */
, {
  message: "Using keyCode as v-on modifier is no longer supported. " + "Use kebab-case key name modifiers instead.",
  link: "https://v3.vuejs.org/guide/migration/keycode-modifiers.html"
}), _defineProperty(_deprecationData, "ATTR_FALSE_VALUE"
/* ATTR_FALSE_VALUE */
, {
  message: function message(name) {
    return "Attribute \"".concat(name, "\" with v-bind value `false` will render ") + "".concat(name, "=\"false\" instead of removing it in Vue 3. To remove the attribute, ") + "use `null` or `undefined` instead. If the usage is intended, " + "you can disable the compat behavior and suppress this warning with:" + "\n\n  configureCompat({ ".concat("ATTR_FALSE_VALUE"
    /* ATTR_FALSE_VALUE */
    , ": false })\n");
  },
  link: "https://v3.vuejs.org/guide/migration/attribute-coercion.html"
}), _defineProperty(_deprecationData, "ATTR_ENUMERATED_COERCION"
/* ATTR_ENUMERATED_COERCION */
, {
  message: function message(name, value, coerced) {
    return "Enumerated attribute \"".concat(name, "\" with v-bind value `").concat(value, "` will ") + "".concat(value === null ? "be removed" : "render the value as-is", " instead of coercing the value to \"").concat(coerced, "\" in Vue 3. ") + "Always use explicit \"true\" or \"false\" values for enumerated attributes. " + "If the usage is intended, " + "you can disable the compat behavior and suppress this warning with:" + "\n\n  configureCompat({ ".concat("ATTR_ENUMERATED_COERCION"
    /* ATTR_ENUMERATED_COERCION */
    , ": false })\n");
  },
  link: "https://v3.vuejs.org/guide/migration/attribute-coercion.html"
}), _defineProperty(_deprecationData, "TRANSITION_CLASSES"
/* TRANSITION_CLASSES */
, {
  message: "" // this feature cannot be runtime-detected

}), _defineProperty(_deprecationData, "TRANSITION_GROUP_ROOT"
/* TRANSITION_GROUP_ROOT */
, {
  message: "<TransitionGroup> no longer renders a root <span> element by " + "default if no \"tag\" prop is specified. If you do not rely on the span " + "for styling, you can disable the compat behavior and suppress this " + "warning with:" + "\n\n  configureCompat({ ".concat("TRANSITION_GROUP_ROOT"
  /* TRANSITION_GROUP_ROOT */
  , ": false })\n"),
  link: "https://v3.vuejs.org/guide/migration/transition-group.html"
}), _defineProperty(_deprecationData, "COMPONENT_ASYNC"
/* COMPONENT_ASYNC */
, {
  message: function message(comp) {
    var name = getComponentName(comp);
    return "Async component".concat(name ? " <".concat(name, ">") : "s", " should be explicitly created via `defineAsyncComponent()` ") + "in Vue 3. Plain functions will be treated as functional components in " + "non-compat build. If you have already migrated all async component " + "usage and intend to use plain functions for functional components, " + "you can disable the compat behavior and suppress this " + "warning with:" + "\n\n  configureCompat({ ".concat("COMPONENT_ASYNC"
    /* COMPONENT_ASYNC */
    , ": false })\n");
  },
  link: "https://v3.vuejs.org/guide/migration/async-components.html"
}), _defineProperty(_deprecationData, "COMPONENT_FUNCTIONAL"
/* COMPONENT_FUNCTIONAL */
, {
  message: function message(comp) {
    var name = getComponentName(comp);
    return "Functional component".concat(name ? " <".concat(name, ">") : "s", " should be defined as a plain function in Vue 3. The \"functional\" ") + "option has been removed. NOTE: Before migrating to use plain " + "functions for functional components, first make sure that all async " + "components usage have been migrated and its compat behavior has " + "been disabled.";
  },
  link: "https://v3.vuejs.org/guide/migration/functional-components.html"
}), _defineProperty(_deprecationData, "COMPONENT_V_MODEL"
/* COMPONENT_V_MODEL */
, {
  message: function message(comp) {
    var configMsg = "opt-in to " + "Vue 3 behavior on a per-component basis with `compatConfig: { ".concat("COMPONENT_V_MODEL"
    /* COMPONENT_V_MODEL */
    , ": false }`.");

    if (comp.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(comp.props) ? comp.props.includes('modelValue') : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(comp.props, 'modelValue')) {
      return "Component delcares \"modelValue\" prop, which is Vue 3 usage, but " + "is running under Vue 2 compat v-model behavior. You can ".concat(configMsg);
    }

    return "v-model usage on component has changed in Vue 3. Component that expects " + "to work with v-model should now use the \"modelValue\" prop and emit the " + "\"update:modelValue\" event. You can update the usage and then ".concat(configMsg);
  },
  link: "https://v3.vuejs.org/guide/migration/v-model.html"
}), _defineProperty(_deprecationData, "RENDER_FUNCTION"
/* RENDER_FUNCTION */
, {
  message: "Vue 3's render function API has changed. " + "You can opt-in to the new API with:" + "\n\n  configureCompat({ ".concat("RENDER_FUNCTION"
  /* RENDER_FUNCTION */
  , ": false })\n") + "\n  (This can also be done per-component via the \"compatConfig\" option.)",
  link: "https://v3.vuejs.org/guide/migration/render-function-api.html"
}), _defineProperty(_deprecationData, "FILTERS"
/* FILTERS */
, {
  message: "filters have been removed in Vue 3. " + "The \"|\" symbol will be treated as native JavaScript bitwise OR operator. " + "Use method calls or computed properties instead.",
  link: "https://v3.vuejs.org/guide/migration/filters.html"
}), _defineProperty(_deprecationData, "PRIVATE_APIS"
/* PRIVATE_APIS */
, {
  message: function message(name) {
    return "\"".concat(name, "\" is a Vue 2 private API that no longer exists in Vue 3. ") + "If you are seeing this warning only due to a dependency, you can " + "suppress this warning via { PRIVATE_APIS: 'supress-warning' }.";
  }
}), _deprecationData);
var instanceWarned = Object.create(null);
var warnCount = Object.create(null);

function warnDeprecation(key, instance) {
  if (false) {}

  instance = instance || getCurrentInstance(); // check user config

  var config = getCompatConfigForKey(key, instance);

  if (config === 'suppress-warning') {
    return;
  }

  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  var dupKey = key + args.join('');
  var compId = instance && formatComponentName(instance, instance.type);

  if (compId === 'Anonymous' && instance) {
    compId = instance.uid;
  } // skip if the same warning is emitted for the same component type


  var componentDupKey = dupKey + compId;

  if (componentDupKey in instanceWarned) {
    return;
  }

  instanceWarned[componentDupKey] = true; // same warning, but different component. skip the long message and just
  // log the key and count.

  if (dupKey in warnCount) {
    warn("(deprecation ".concat(key, ") (").concat(++warnCount[dupKey] + 1, ")"));
    return;
  }

  warnCount[dupKey] = 0;
  var _deprecationData$key = deprecationData[key],
      message = _deprecationData$key.message,
      link = _deprecationData$key.link;
  warn("(deprecation ".concat(key, ") ").concat(typeof message === 'function' ? message.apply(void 0, args) : message).concat(link ? "\n  Details: ".concat(link) : ""));

  if (!isCompatEnabled(key, instance, true)) {
    console.error("^ The above deprecation's compat behavior is disabled and will likely " + "lead to runtime errors.");
  }
}

var globalCompatConfig = {
  MODE: 2
};

function getCompatConfigForKey(key, instance) {
  var instanceConfig = instance && instance.type.compatConfig;

  if (instanceConfig && key in instanceConfig) {
    return instanceConfig[key];
  }

  return globalCompatConfig[key];
}

function isCompatEnabled(key, instance) {
  var enableForBuiltIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // skip compat for built-in components
  if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
    return false;
  }

  var rawMode = getCompatConfigForKey('MODE', instance) || 2;
  var val = getCompatConfigForKey(key, instance);
  var mode = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rawMode) ? rawMode(instance && instance.type) : rawMode;

  if (mode === 2) {
    return val !== false;
  } else {
    return val === true || val === 'suppress-warning';
  }
}

function emit(instance, event) {
  var props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  for (var _len3 = arguments.length, rawArgs = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    rawArgs[_key3 - 2] = arguments[_key3];
  }

  if (true) {
    var emitsOptions = instance.emitsOptions,
        _instance$propsOption = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption[0];

    if (emitsOptions) {
      if (!(event in emitsOptions) && !false) {
        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
          warn("Component emitted event \"".concat(event, "\" but it is neither declared in ") + "the emits option nor as an \"".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event), "\" prop."));
        }
      } else {
        var validator = emitsOptions[event];

        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
          var isValid = validator.apply(void 0, rawArgs);

          if (!isValid) {
            warn("Invalid event arguments: event validation failed for event \"".concat(event, "\"."));
          }
        }
      }
    }
  }

  var args = rawArgs;
  var isModelListener = event.startsWith('update:'); // for v-model update:xxx events, apply modifiers on args

  var modelArg = isModelListener && event.slice(7);

  if (modelArg && modelArg in props) {
    var modifiersKey = "".concat(modelArg === 'modelValue' ? 'model' : modelArg, "Modifiers");

    var _ref3 = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        number = _ref3.number,
        trim = _ref3.trim;

    if (trim) {
      args = rawArgs.map(function (a) {
        return a.trim();
      });
    } else if (number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
    }
  }

  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }

  if (true) {
    var lowerCaseEvent = event.toLowerCase();

    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
      warn("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") + "".concat(formatComponentName(instance, instance.type), " but the handler is registered for \"").concat(event, "\". ") + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), "\" instead of \"").concat(event, "\"."));
    }
  }

  var handlerName;
  var handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))]; // for v-model update:xxx events, also trigger kebab-case equivalent
  // for props passed via kebab-case

  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];
  }

  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }

  var onceHandler = props[handlerName + "Once"];

  if (onceHandler) {
    if (!instance.emitted) {
      (instance.emitted = {})[handlerName] = true;
    } else if (instance.emitted[handlerName]) {
      return;
    }

    callWithAsyncErrorHandling(onceHandler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }
}

function normalizeEmitsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.emitsCache;
  var cached = cache.get(comp);

  if (cached !== undefined) {
    return cached;
  }

  var raw = comp.emits;
  var normalized = {}; // apply mixin/extends props

  var hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    var extendEmits = function extendEmits(raw) {
      var normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);

      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
      }
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }

    if (comp.extends) {
      extendEmits(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    raw.forEach(function (key) {
      return normalized[key] = null;
    });
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
  }

  cache.set(comp, normalized);
  return normalized;
} // Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.


function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    return false;
  }

  key = key.slice(2).replace(/Once$/, '');
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);
}
/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */


var currentRenderingInstance = null;
var currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */

function setCurrentRenderingInstance(instance) {
  var prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */


function pushScopeId(id) {
  currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */


function popScopeId() {
  currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */


var withScopeId = function withScopeId(_id) {
  return withCtx;
};
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */


function withCtx(fn) // false only
{
  var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentRenderingInstance;
  var isNonScopedSlot = arguments.length > 2 ? arguments[2] : undefined;
  if (!ctx) return fn; // already normalized

  if (fn._n) {
    return fn;
  }

  var renderFnWithContext = function renderFnWithContext() {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we disable block tracking and
    // force bail out when invoking a compiled slot (indicated by the ._d flag).
    // This isn't necessary if rendering a compiled `<slot>`, so we flip the
    // ._d flag off when invoking the wrapped fn inside `renderSlot`.
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }

    var prevInstance = setCurrentRenderingInstance(ctx);
    var res = fn.apply(void 0, arguments);
    setCurrentRenderingInstance(prevInstance);

    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }

    if (true) {
      devtoolsComponentUpdated(ctx);
    }

    return res;
  }; // mark normalized to avoid duplicated wrapping


  renderFnWithContext._n = true; // mark this as compiled by default
  // this is used in vnode.ts -> normalizeChildren() to set the slot
  // rendering flag.

  renderFnWithContext._c = true; // disable block tracking by default

  renderFnWithContext._d = true;
  return renderFnWithContext;
}
/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */


var accessedAttrs = false;

function markAttrsAccessed() {
  accessedAttrs = true;
}

function renderComponentRoot(instance) {
  var Component = instance.type,
      vnode = instance.vnode,
      proxy = instance.proxy,
      withProxy = instance.withProxy,
      props = instance.props,
      _instance$propsOption2 = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption2[0],
      slots = instance.slots,
      attrs = instance.attrs,
      emit = instance.emit,
      render = instance.render,
      renderCache = instance.renderCache,
      data = instance.data,
      setupState = instance.setupState,
      ctx = instance.ctx,
      inheritAttrs = instance.inheritAttrs;

  var result;
  var prev = setCurrentRenderingInstance(instance);

  if (true) {
    accessedAttrs = false;
  }

  try {
    var fallthroughAttrs;

    if (vnode.shapeFlag & 4
    /* STATEFUL_COMPONENT */
    ) {
        // withProxy is a proxy with a different `has` trap only for
        // runtime-compiled render functions using `with` block.
        var proxyToUse = withProxy || proxy;
        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
        fallthroughAttrs = attrs;
      } else {
      // functional
      var _render = Component; // in dev, mark attrs accessed if optional props (attrs === props)

      if ( true && attrs === props) {
        markAttrsAccessed();
      }

      result = normalizeVNode(_render.length > 1 ? _render(props,  true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },

        slots: slots,
        emit: emit
      } : 0) : _render(props, null
      /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    } // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment


    var root = result;
    var setRoot = undefined;

    if ( true && result.patchFlag > 0 && result.patchFlag & 2048
    /* DEV_ROOT_FRAGMENT */
    ) {
        ;

        var _getChildRoot = getChildRoot(result);

        var _getChildRoot2 = _slicedToArray(_getChildRoot, 2);

        root = _getChildRoot2[0];
        setRoot = _getChildRoot2[1];
      }

    if (fallthroughAttrs && inheritAttrs !== false) {
      var keys = Object.keys(fallthroughAttrs);
      var _root = root,
          shapeFlag = _root.shapeFlag;

      if (keys.length) {
        if (shapeFlag & 1
        /* ELEMENT */
        || shapeFlag & 6
        /* COMPONENT */
        ) {
            if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
              // If a v-model listener (onUpdate:xxx) has a corresponding declared
              // prop, it indicates this component expects to handle v-model and
              // it should not fallthrough.
              // related: #1543, #1643, #1989
              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
            }

            root = cloneVNode(root, fallthroughAttrs);
          } else if ( true && !accessedAttrs && root.type !== Comment$1) {
          var allAttrs = Object.keys(attrs);
          var eventAttrs = [];
          var extraAttrs = [];

          for (var i = 0, l = allAttrs.length; i < l; i++) {
            var key = allAttrs[i];

            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
              // ignore v-model handlers when they fail to fallthrough
              if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                // remove `on`, lowercase first letter to reflect event casing
                // accurately
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }

          if (extraAttrs.length) {
            warn("Extraneous non-props attributes (" + "".concat(extraAttrs.join(', '), ") ") + "were passed to component but could not be automatically inherited " + "because component renders fragment or text root nodes.");
          }

          if (eventAttrs.length) {
            warn("Extraneous non-emits event listeners (" + "".concat(eventAttrs.join(', '), ") ") + "were passed to component but could not be automatically inherited " + "because component renders fragment or text root nodes. " + "If the listener is intended to be a component custom event listener only, " + "declare it using the \"emits\" option.");
          }
        }
      }
    }

    if (false) {} // inherit directives

    if (vnode.dirs) {
      if ( true && !isElementRoot(root)) {
        warn("Runtime directive used on component with non-element root node. " + "The directives will not function as intended.");
      }

      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    } // inherit transition data


    if (vnode.transition) {
      if ( true && !isElementRoot(root)) {
        warn("Component inside <Transition> renders non-element root node " + "that cannot be animated.");
      }

      root.transition = vnode.transition;
    }

    if ( true && setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1
    /* RENDER_FUNCTION */
    );
    result = createVNode(Comment$1);
  }

  setCurrentRenderingInstance(prev);
  return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */


var getChildRoot = function getChildRoot(vnode) {
  var rawChildren = vnode.children;
  var dynamicChildren = vnode.dynamicChildren;
  var childRoot = filterSingleRoot(rawChildren);

  if (!childRoot) {
    return [vnode, undefined];
  }

  var index = rawChildren.indexOf(childRoot);
  var dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;

  var setRoot = function setRoot(updatedRoot) {
    rawChildren[index] = updatedRoot;

    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [].concat(_toConsumableArray(dynamicChildren), [updatedRoot]);
      }
    }
  };

  return [normalizeVNode(childRoot), setRoot];
};

function filterSingleRoot(children) {
  var singleRoot;

  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment$1 || child.children === 'v-if') {
        if (singleRoot) {
          // has more than 1 non-comment child, return now
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }

  return singleRoot;
}

var getFunctionalFallthrough = function getFunctionalFallthrough(attrs) {
  var res;

  for (var key in attrs) {
    if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }

  return res;
};

var filterModelListeners = function filterModelListeners(attrs, props) {
  var res = {};

  for (var key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }

  return res;
};

var isElementRoot = function isElementRoot(vnode) {
  return vnode.shapeFlag & 6
  /* COMPONENT */
  || vnode.shapeFlag & 1
  /* ELEMENT */
  || vnode.type === Comment$1 // potential v-if branch switch
  ;
};

function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  var prevProps = prevVNode.props,
      prevChildren = prevVNode.children,
      component = prevVNode.component;
  var nextProps = nextVNode.props,
      nextChildren = nextVNode.children,
      patchFlag = nextVNode.patchFlag;
  var emits = component.emitsOptions; // Parent component's render function was hot-updated. Since this may have
  // caused the child component's slots content to have changed, we need to
  // force the child to update as well.

  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  } // force child update for runtime directive or transition on component vnode.


  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }

  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024
    /* DYNAMIC_SLOTS */
    ) {
        // slot content that references values that might have changed,
        // e.g. in a v-for
        return true;
      }

    if (patchFlag & 16
    /* FULL_PROPS */
    ) {
        if (!prevProps) {
          return !!nextProps;
        } // presence of this flag indicates props are always non-null


        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8
    /* PROPS */
    ) {
        var dynamicProps = nextVNode.dynamicProps;

        for (var i = 0; i < dynamicProps.length; i++) {
          var key = dynamicProps[i];

          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
  } else {
    // this path is only taken by manually written render functions
    // so presence of any children leads to a forced update
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }

    if (prevProps === nextProps) {
      return false;
    }

    if (!prevProps) {
      return !!nextProps;
    }

    if (!nextProps) {
      return true;
    }

    return hasPropsChanged(prevProps, nextProps, emits);
  }

  return false;
}

function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  var nextKeys = Object.keys(nextProps);

  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }

  for (var i = 0; i < nextKeys.length; i++) {
    var key = nextKeys[i];

    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }

  return false;
}

function updateHOCHostEl(_ref4, el // HostNode
) {
  var vnode = _ref4.vnode,
      parent = _ref4.parent;

  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}

var isSuspense = function isSuspense(type) {
  return type.__isSuspense;
}; // Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.


var SuspenseImpl = {
  name: 'Suspense',
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process: function process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, // platform-specific impl passed from renderer
  rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
}; // Force-casted public typing for h and TSX props inference

var Suspense = SuspenseImpl;

function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  var patch = rendererInternals.p,
      createElement = rendererInternals.o.createElement;
  var hiddenContainer = createElement('div');
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals); // start mounting the content subtree in an off-dom container

  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds); // now check if we have encountered any async deps

  if (suspense.deps > 0) {
    // has async
    // mount the fallback tree
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
    isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    // Suspense has no async deps. Just resolve.
    suspense.resolve();
  }
}

function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, _ref5) {
  var patch = _ref5.p,
      unmount = _ref5.um,
      createElement = _ref5.o.createElement;
  var suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  var newBranch = n2.ssContent;
  var newFallback = n2.ssFallback;
  var activeBranch = suspense.activeBranch,
      pendingBranch = suspense.pendingBranch,
      isInFallback = suspense.isInFallback,
      isHydrating = suspense.isHydrating;

  if (pendingBranch) {
    suspense.pendingBranch = newBranch;

    if (isSameVNodeType(newBranch, pendingBranch)) {
      // same root type but content may have changed.
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      // toggled before pending tree is resolved
      suspense.pendingId++;

      if (isHydrating) {
        // if toggled before hydration is finished, the current DOM tree is
        // no longer valid. set it as the active branch so it will be unmounted
        // when resolved
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      } // increment pending ID. this is used to invalidate async callbacks
      // reset suspense state


      suspense.deps = 0; // discard effects from pending branch

      suspense.effects.length = 0; // discard previous container

      suspense.hiddenContainer = createElement('div');

      if (isInFallback) {
        // already in fallback state
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
          isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        // toggled "back" to current active branch
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized); // force resolve

        suspense.resolve(true);
      } else {
        // switched to a 3rd branch
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      // root did not change, just normal patch
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      // root node toggled
      // invoke @pending event
      var onPending = n2.props && n2.props.onPending;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onPending)) {
        onPending();
      } // mount pending branch in off-dom container


      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        // incoming branch has no async deps, resolve now.
        suspense.resolve();
      } else {
        var timeout = suspense.timeout,
            pendingId = suspense.pendingId;

        if (timeout > 0) {
          setTimeout(function () {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}

var hasWarned = false;

function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals) {
  var isHydrating = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;

  /* istanbul ignore if */
  if ( true && !hasWarned) {
    hasWarned = true; // @ts-ignore `console.info` cannot be null error

    console[console.info ? 'info' : 'log']("<Suspense> is an experimental feature and its API will likely change.");
  }

  var patch = rendererInternals.p,
      _move = rendererInternals.m,
      _unmount2 = rendererInternals.um,
      _next = rendererInternals.n,
      _rendererInternals$o = rendererInternals.o,
      parentNode = _rendererInternals$o.parentNode,
      remove = _rendererInternals$o.remove;
  var timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
  var suspense = {
    vnode: vnode,
    parent: parent,
    parentComponent: parentComponent,
    isSVG: isSVG,
    container: container,
    hiddenContainer: hiddenContainer,
    anchor: anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === 'number' ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating: isHydrating,
    isUnmounted: false,
    effects: [],
    resolve: function resolve() {
      var resume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (true) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error("suspense.resolve() is called without a pending branch.");
        }

        if (suspense.isUnmounted) {
          throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");
        }
      }

      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          pendingBranch = suspense.pendingBranch,
          pendingId = suspense.pendingId,
          effects = suspense.effects,
          parentComponent = suspense.parentComponent,
          container = suspense.container;

      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        var delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';

        if (delayEnter) {
          activeBranch.transition.afterLeave = function () {
            if (pendingId === suspense.pendingId) {
              _move(pendingBranch, container, _anchor, 0
              /* ENTER */
              );
            }
          };
        } // this is initial anchor on mount


        var _anchor = suspense.anchor; // unmount current active tree

        if (activeBranch) {
          // if the fallback tree was mounted, it may have been moved
          // as part of a parent suspense. get the latest anchor for insertion
          _anchor = _next(activeBranch);

          _unmount2(activeBranch, parentComponent, suspense, true);
        }

        if (!delayEnter) {
          // move content from off-dom container to actual container
          _move(pendingBranch, container, _anchor, 0
          /* ENTER */
          );
        }
      }

      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false; // flush buffered effects
      // check if there is a pending parent suspense

      var parent = suspense.parent;
      var hasUnresolvedAncestor = false;

      while (parent) {
        if (parent.pendingBranch) {
          var _parent$effects;

          // found a pending parent suspense, merge buffered post jobs
          // into that parent
          (_parent$effects = parent.effects).push.apply(_parent$effects, _toConsumableArray(effects));

          hasUnresolvedAncestor = true;
          break;
        }

        parent = parent.parent;
      } // no pending parent suspense, flush all jobs


      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }

      suspense.effects = []; // invoke @resolve event

      var onResolve = vnode.props && vnode.props.onResolve;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onResolve)) {
        onResolve();
      }
    },
    fallback: function fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }

      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          parentComponent = suspense.parentComponent,
          container = suspense.container,
          isSVG = suspense.isSVG; // invoke @fallback event

      var onFallback = vnode.props && vnode.props.onFallback;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onFallback)) {
        onFallback();
      }

      var anchor = _next(activeBranch);

      var mountFallback = function mountFallback() {
        if (!suspense.isInFallback) {
          return;
        } // mount the fallback tree


        patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };

      var delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';

      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      } // unmount current active branch


      _unmount2(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
      true // shouldRemove
      );

      suspense.isInFallback = true;

      if (!delayEnter) {
        mountFallback();
      }
    },
    move: function move(container, anchor, type) {
      suspense.activeBranch && _move(suspense.activeBranch, container, anchor, type);
      suspense.container = container;
    },
    next: function next() {
      return suspense.activeBranch && _next(suspense.activeBranch);
    },
    registerDep: function registerDep(instance, setupRenderEffect) {
      var isInPendingSuspense = !!suspense.pendingBranch;

      if (isInPendingSuspense) {
        suspense.deps++;
      }

      var hydratedEl = instance.vnode.el;
      instance.asyncDep.catch(function (err) {
        handleError(err, instance, 0
        /* SETUP_FUNCTION */
        );
      }).then(function (asyncSetupResult) {
        // retry when the setup() promise resolves.
        // component may have been unmounted before resolve.
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        } // retry from this component


        instance.asyncResolved = true;
        var vnode = instance.vnode;

        if (true) {
          pushWarningContext(vnode);
        }

        handleSetupResult(instance, asyncSetupResult, false);

        if (hydratedEl) {
          // vnode may have been replaced if an update happened before the
          // async dep is resolved.
          vnode.el = hydratedEl;
        }

        var placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode, // component may have been moved before resolve.
        // if this is not a hydration, instance.subTree will be the comment
        // placeholder.
        parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
        // consider the comment placeholder case.
        hydratedEl ? null : _next(instance.subTree), suspense, isSVG, optimized);

        if (placeholder) {
          remove(placeholder);
        }

        updateHOCHostEl(instance, vnode.el);

        if (true) {
          popWarningContext();
        } // only decrease deps count if suspense is not already resolved


        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount: function unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;

      if (suspense.activeBranch) {
        _unmount2(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }

      if (suspense.pendingBranch) {
        _unmount2(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}

function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  /* eslint-disable no-restricted-globals */
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true
  /* hydrating */
  ); // there are two possible scenarios for server-rendered suspense:
  // - success: ssr content should be fully resolved
  // - failure: ssr content should be the fallback branch.
  // however, on the client we don't really know if it has failed or not
  // attempt to hydrate the DOM assuming it has succeeded, but we still
  // need to construct a suspense boundary first

  var result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);

  if (suspense.deps === 0) {
    suspense.resolve();
  }

  return result;
  /* eslint-enable no-restricted-globals */
}

function normalizeSuspenseChildren(vnode) {
  var shapeFlag = vnode.shapeFlag,
      children = vnode.children;
  var isSlotChildren = shapeFlag & 32
  /* SLOTS_CHILDREN */
  ;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}

function normalizeSuspenseSlot(s) {
  var block;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
    var isCompiledSlot = s._c;

    if (isCompiledSlot) {
      // disableTracking: false
      // allow block tracking for compiled slots
      // (see ./componentRenderContext.ts)
      s._d = false;
      openBlock();
    }

    s = s();

    if (isCompiledSlot) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
    var singleChild = filterSingleRoot(s);

    if ( true && !singleChild) {
      warn("<Suspense> slots expect a single root node.");
    }

    s = singleChild;
  }

  s = normalizeVNode(s);

  if (block) {
    s.dynamicChildren = block.filter(function (c) {
      return c !== s;
    });
  }

  return s;
}

function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
      var _suspense$effects;

      (_suspense$effects = suspense.effects).push.apply(_suspense$effects, _toConsumableArray(fn));
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}

function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  var vnode = suspense.vnode,
      parentComponent = suspense.parentComponent;
  var el = vnode.el = branch.el; // in case suspense is the root node of a component,
  // recursively update the HOC el

  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}

function provide(key, value) {
  if (!currentInstance) {
    if (true) {
      warn("provide() can only be used inside setup().");
    }
  } else {
    var provides = currentInstance.provides; // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.

    var parentProvides = currentInstance.parent && currentInstance.parent.provides;

    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    } // TS doesn't allow symbol as index type


    provides[key] = value;
  }
}

function inject(key, defaultValue) {
  var treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // fallback to `currentRenderingInstance` so that this can be called in
  // a functional component
  var instance = currentInstance || currentRenderingInstance;

  if (instance) {
    // #2400
    // to support `app.use` plugins,
    // fallback to appContext's `provides` if the intance is at root
    var provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;

    if (provides && key in provides) {
      // TS doesn't allow symbol as index type
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue() : defaultValue;
    } else if (true) {
      warn("injection \"".concat(String(key), "\" not found."));
    }
  } else if (true) {
    warn("inject() can only be used inside setup() or functional components.");
  }
} // Simple effect.


function watchEffect(effect, options) {
  return doWatch(effect, null, options);
} // initial value for watchers to trigger on undefined initial values


var INITIAL_WATCHER_VALUE = {}; // implementation

function watch(source, cb, options) {
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
    warn("`watch(fn, options?)` signature has been moved to a separate API. " + "Use `watchEffect(fn, options?)` instead. `watch` now only " + "supports `watch(source, cb, options?) signature.");
  }

  return doWatch(source, cb, options);
}

function doWatch(source, cb) {
  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
      immediate = _ref6.immediate,
      deep = _ref6.deep,
      flush = _ref6.flush,
      onTrack = _ref6.onTrack,
      onTrigger = _ref6.onTrigger;

  var instance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : currentInstance;

  if ( true && !cb) {
    if (immediate !== undefined) {
      warn("watch() \"immediate\" option is only respected when using the " + "watch(source, callback, options?) signature.");
    }

    if (deep !== undefined) {
      warn("watch() \"deep\" option is only respected when using the " + "watch(source, callback, options?) signature.");
    }
  }

  var warnInvalidSource = function warnInvalidSource(s) {
    warn("Invalid watch source: ", s, "A watch source can only be a getter/effect function, a ref, " + "a reactive object, or an array of these types.");
  };

  var getter;
  var forceTrigger = false;
  var isMultiSource = false;

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
    getter = function getter() {
      return source.value;
    };

    forceTrigger = !!source._shallow;
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
    getter = function getter() {
      return source;
    };

    deep = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive);

    getter = function getter() {
      return source.map(function (s) {
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
          return s.value;
        } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
          return traverse(s);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
          return callWithErrorHandling(s, instance, 2
          /* WATCH_GETTER */
          );
        } else {
           true && warnInvalidSource(s);
        }
      });
    };
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    if (cb) {
      // getter with cb
      getter = function getter() {
        return callWithErrorHandling(source, instance, 2
        /* WATCH_GETTER */
        );
      };
    } else {
      // no cb -> simple effect
      getter = function getter() {
        if (instance && instance.isUnmounted) {
          return;
        }

        if (cleanup) {
          cleanup();
        }

        return callWithAsyncErrorHandling(source, instance, 3
        /* WATCH_CALLBACK */
        , [onInvalidate]);
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
     true && warnInvalidSource(source);
  }

  if (cb && deep) {
    var baseGetter = getter;

    getter = function getter() {
      return traverse(baseGetter());
    };
  }

  var cleanup;

  var onInvalidate = function onInvalidate(fn) {
    cleanup = runner.options.onStop = function () {
      callWithErrorHandling(fn, instance, 4
      /* WATCH_CLEANUP */
      );
    };
  };

  var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;

  var job = function job() {
    if (!runner.active) {
      return;
    }

    if (cb) {
      // watch(source, cb)
      var newValue = runner();

      if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]);
      }) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) || false) {
        // cleanup before running cb again
        if (cleanup) {
          cleanup();
        }

        callWithAsyncErrorHandling(cb, instance, 3
        /* WATCH_CALLBACK */
        , [newValue, // pass undefined as the old value when it's changed for the first time
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate]);
        oldValue = newValue;
      }
    } else {
      // watchEffect
      runner();
    }
  }; // important: mark the job as a watcher callback so that scheduler knows
  // it is allowed to self-trigger (#1727)


  job.allowRecurse = !!cb;
  var scheduler;

  if (flush === 'sync') {
    scheduler = job; // the scheduler function gets called directly
  } else if (flush === 'post') {
    scheduler = function scheduler() {
      return queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else {
    // default: 'pre'
    scheduler = function scheduler() {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }

  var runner = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(getter, {
    lazy: true,
    onTrack: onTrack,
    onTrigger: onTrigger,
    scheduler: scheduler
  });
  recordInstanceBoundEffect(runner, instance); // initial run

  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = runner();
    }
  } else if (flush === 'post') {
    queuePostRenderEffect(runner, instance && instance.suspense);
  } else {
    runner();
  }

  return function () {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(runner);

    if (instance) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.effects, runner);
    }
  };
} // this.$watch


function instanceWatch(source, value, options) {
  var publicThis = this.proxy;
  var getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes('.') ? createPathGetter(publicThis, source) : function () {
    return publicThis[source];
  } : source.bind(publicThis, publicThis);
  var cb;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }

  return doWatch(getter, cb.bind(publicThis), options, this);
}

function createPathGetter(ctx, path) {
  var segments = path.split('.');
  return function () {
    var cur = ctx;

    for (var i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }

    return cur;
  };
}

function traverse(value) {
  var seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || seen.has(value) || value["__v_skip"
  /* SKIP */
  ]) {
    return value;
  }

  seen.add(value);

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    traverse(value.value, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    for (var i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
    value.forEach(function (v) {
      traverse(v, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
    for (var key in value) {
      traverse(value[key], seen);
    }
  }

  return value;
}

function useTransitionState() {
  var state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(function () {
    state.isMounted = true;
  });
  onBeforeUnmount(function () {
    state.isUnmounting = true;
  });
  return state;
}

var TransitionHookValidator = [Function, Array];
var BaseTransitionImpl = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup: function setup(props, _ref7) {
    var slots = _ref7.slots;
    var instance = getCurrentInstance();
    var state = useTransitionState();
    var prevTransitionKey;
    return function () {
      var children = slots.default && getTransitionRawChildren(slots.default(), true);

      if (!children || !children.length) {
        return;
      } // warn multiple elements


      if ( true && children.length > 1) {
        warn('<transition> can only be used on a single element or component. Use ' + '<transition-group> for lists.');
      } // there's no need to track reactivity for these props so use the raw
      // props for a bit better perf


      var rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
      var mode = rawProps.mode; // check mode

      if ( true && mode && !['in-out', 'out-in', 'default'].includes(mode)) {
        warn("invalid <transition> mode: ".concat(mode));
      } // at this point children has a guaranteed length of 1.


      var child = children[0];

      if (state.isLeaving) {
        return emptyPlaceholder(child);
      } // in the case of <transition><keep-alive/></transition>, we need to
      // compare the type of the kept-alive children.


      var innerChild = getKeepAliveChild(child);

      if (!innerChild) {
        return emptyPlaceholder(child);
      }

      var enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      var oldChild = instance.subTree;
      var oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      var transitionKeyChanged = false;
      var getTransitionKey = innerChild.type.getTransitionKey;

      if (getTransitionKey) {
        var key = getTransitionKey();

        if (prevTransitionKey === undefined) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      } // handle mode


      if (oldInnerChild && oldInnerChild.type !== Comment$1 && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        var leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance); // update old tree's hooks in case of dynamic transition

        setTransitionHooks(oldInnerChild, leavingHooks); // switching between different views

        if (mode === 'out-in') {
          state.isLeaving = true; // return placeholder node and queue update when leave finishes

          leavingHooks.afterLeave = function () {
            state.isLeaving = false;
            instance.update();
          };

          return emptyPlaceholder(child);
        } else if (mode === 'in-out' && innerChild.type !== Comment$1) {
          leavingHooks.delayLeave = function (el, earlyRemove, delayedLeave) {
            var leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild; // early removal callback

            el._leaveCb = function () {
              earlyRemove();
              el._leaveCb = undefined;
              delete enterHooks.delayedLeave;
            };

            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }

      return child;
    };
  }
}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(state, vnode) {
  var leavingVNodes = state.leavingVNodes;
  var leavingVNodesCache = leavingVNodes.get(vnode.type);

  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }

  return leavingVNodesCache;
} // The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.


function resolveTransitionHooks(vnode, props, state, instance) {
  var appear = props.appear,
      mode = props.mode,
      _props$persisted = props.persisted,
      persisted = _props$persisted === void 0 ? false : _props$persisted,
      onBeforeEnter = props.onBeforeEnter,
      onEnter = props.onEnter,
      onAfterEnter = props.onAfterEnter,
      onEnterCancelled = props.onEnterCancelled,
      onBeforeLeave = props.onBeforeLeave,
      onLeave = props.onLeave,
      onAfterLeave = props.onAfterLeave,
      onLeaveCancelled = props.onLeaveCancelled,
      onBeforeAppear = props.onBeforeAppear,
      onAppear = props.onAppear,
      onAfterAppear = props.onAfterAppear,
      onAppearCancelled = props.onAppearCancelled;
  var key = String(vnode.key);
  var leavingVNodesCache = getLeavingNodesForType(state, vnode);

  var callHook = function callHook(hook, args) {
    hook && callWithAsyncErrorHandling(hook, instance, 9
    /* TRANSITION_HOOK */
    , args);
  };

  var hooks = {
    mode: mode,
    persisted: persisted,
    beforeEnter: function beforeEnter(el) {
      var hook = onBeforeEnter;

      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      } // for same element (v-show)


      if (el._leaveCb) {
        el._leaveCb(true
        /* cancelled */
        );
      } // for toggled element with same key (v-if)


      var leavingVNode = leavingVNodesCache[key];

      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        // force early removal (not cancelled)
        leavingVNode.el._leaveCb();
      }

      callHook(hook, [el]);
    },
    enter: function enter(el) {
      var hook = onEnter;
      var afterHook = onAfterEnter;
      var cancelHook = onEnterCancelled;

      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }

      var called = false;

      var done = el._enterCb = function (cancelled) {
        if (called) return;
        called = true;

        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }

        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }

        el._enterCb = undefined;
      };

      if (hook) {
        hook(el, done);

        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave: function leave(el, remove) {
      var key = String(vnode.key);

      if (el._enterCb) {
        el._enterCb(true
        /* cancelled */
        );
      }

      if (state.isUnmounting) {
        return remove();
      }

      callHook(onBeforeLeave, [el]);
      var called = false;

      var done = el._leaveCb = function (cancelled) {
        if (called) return;
        called = true;
        remove();

        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }

        el._leaveCb = undefined;

        if (leavingVNodesCache[key] === vnode) {
          delete leavingVNodesCache[key];
        }
      };

      leavingVNodesCache[key] = vnode;

      if (onLeave) {
        onLeave(el, done);

        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone: function clone(vnode) {
      return resolveTransitionHooks(vnode, props, state, instance);
    }
  };
  return hooks;
} // the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.


function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}

function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;
}

function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6
  /* COMPONENT */
  && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
    vnode.transition = hooks;
  }
}

function getTransitionRawChildren(children) {
  var keepComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var ret = [];
  var keyedFragmentCount = 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // handle fragment children case, e.g. v-for

    if (child.type === Fragment) {
      if (child.patchFlag & 128
      /* KEYED_FRAGMENT */
      ) keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } // comment placeholders should be skipped, e.g. v-if
    else if (keepComment || child.type !== Comment$1) {
        ret.push(child);
      }
  } // #1126 if a transition children list contains multiple sub fragments, these
  // fragments will be merged into a flat children array. Since each v-for
  // fragment may contain different static bindings inside, we need to de-op
  // these children to force full diffs to ensure correct behavior.


  if (keyedFragmentCount > 1) {
    for (var _i2 = 0; _i2 < ret.length; _i2++) {
      ret[_i2].patchFlag = -2
      /* BAIL */
      ;
    }
  }

  return ret;
} // implementation, close to no-op


function defineComponent(options) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? {
    setup: options,
    name: options.name
  } : options;
}

var isAsyncWrapper = function isAsyncWrapper(i) {
  return !!i.type.__asyncLoader;
};

function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    source = {
      loader: source
    };
  }

  var _source = source,
      loader = _source.loader,
      loadingComponent = _source.loadingComponent,
      errorComponent = _source.errorComponent,
      _source$delay = _source.delay,
      delay = _source$delay === void 0 ? 200 : _source$delay,
      timeout = _source.timeout,
      _source$suspensible = _source.suspensible,
      suspensible = _source$suspensible === void 0 ? true : _source$suspensible,
      userOnError = _source.onError;
  var pendingRequest = null;
  var resolvedComp;
  var retries = 0;

  var retry = function retry() {
    retries++;
    pendingRequest = null;
    return load();
  };

  var load = function load() {
    var thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch(function (err) {
      err = err instanceof Error ? err : new Error(String(err));

      if (userOnError) {
        return new Promise(function (resolve, reject) {
          var userRetry = function userRetry() {
            return resolve(retry());
          };

          var userFail = function userFail() {
            return reject(err);
          };

          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(function (comp) {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }

      if ( true && !comp) {
        warn("Async component loader resolved to undefined. " + "If you are using retry(), make sure to return its return value.");
      } // interop module default


      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
      }

      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        throw new Error("Invalid async component load result: ".concat(comp));
      }

      resolvedComp = comp;
      return comp;
    }));
  };

  return defineComponent({
    name: 'AsyncComponentWrapper',
    __asyncLoader: load,

    get __asyncResolved() {
      return resolvedComp;
    },

    setup: function setup() {
      var instance = currentInstance; // already resolved

      if (resolvedComp) {
        return function () {
          return createInnerComp(resolvedComp, instance);
        };
      }

      var onError = function onError(err) {
        pendingRequest = null;
        handleError(err, instance, 13
        /* ASYNC_COMPONENT_LOADER */
        , !errorComponent
        /* do not throw in dev if user provided error component */
        );
      }; // suspense-controlled or SSR.


      if (suspensible && instance.suspense || false) {
        return load().then(function (comp) {
          return function () {
            return createInnerComp(comp, instance);
          };
        }).catch(function (err) {
          onError(err);
          return function () {
            return errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          };
        });
      }

      var loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
      var error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
      var delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);

      if (delay) {
        setTimeout(function () {
          delayed.value = false;
        }, delay);
      }

      if (timeout != null) {
        setTimeout(function () {
          if (!loaded.value && !error.value) {
            var err = new Error("Async component timed out after ".concat(timeout, "ms."));
            onError(err);
            error.value = err;
          }
        }, timeout);
      }

      load().then(function () {
        loaded.value = true;

        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          // parent is keep-alive, force update so the loaded component's
          // name is taken into account
          queueJob(instance.parent.update);
        }
      }).catch(function (err) {
        onError(err);
        error.value = err;
      });
      return function () {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}

function createInnerComp(comp, _ref8) {
  var _ref8$vnode = _ref8.vnode,
      ref = _ref8$vnode.ref,
      props = _ref8$vnode.props,
      children = _ref8$vnode.children;
  var vnode = createVNode(comp, props, children); // ensure inner component inherits the async wrapper's ref owner

  vnode.ref = ref;
  return vnode;
}

var isKeepAlive = function isKeepAlive(vnode) {
  return vnode.type.__isKeepAlive;
};

var KeepAliveImpl = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup: function setup(props, _ref9) {
    var slots = _ref9.slots;
    var instance = getCurrentInstance(); // KeepAlive communicates with the instantiated renderer via the
    // ctx where the renderer passes in its internals,
    // and the KeepAlive instance exposes activate/deactivate implementations.
    // The whole point of this is to avoid importing KeepAlive directly in the
    // renderer to facilitate tree-shaking.

    var sharedContext = instance.ctx; // if the internal renderer is not registered, it indicates that this is server-side rendering,
    // for KeepAlive, we just need to render its children

    if (!sharedContext.renderer) {
      return slots.default;
    }

    var cache = new Map();
    var keys = new Set();
    var current = null;

    if (true) {
      instance.__v_cache = cache;
    }

    var parentSuspense = instance.suspense;
    var _sharedContext$render = sharedContext.renderer,
        patch = _sharedContext$render.p,
        move = _sharedContext$render.m,
        _unmount = _sharedContext$render.um,
        createElement = _sharedContext$render.o.createElement;
    var storageContainer = createElement('div');

    sharedContext.activate = function (vnode, container, anchor, isSVG, optimized) {
      var instance = vnode.component;
      move(vnode, container, anchor, 0
      /* ENTER */
      , parentSuspense); // in case props have changed

      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(function () {
        instance.isDeactivated = false;

        if (instance.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeMounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    sharedContext.deactivate = function (vnode) {
      var instance = vnode.component;
      move(vnode, storageContainer, null, 1
      /* LEAVE */
      , parentSuspense);
      queuePostRenderEffect(function () {
        if (instance.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }

        instance.isDeactivated = true;
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    function unmount(vnode) {
      // reset the shapeFlag so it can be properly unmounted
      resetShapeFlag(vnode);

      _unmount(vnode, instance, parentSuspense);
    }

    function pruneCache(filter) {
      cache.forEach(function (vnode, key) {
        var name = getComponentName(vnode.type);

        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }

    function pruneCacheEntry(key) {
      var cached = cache.get(key);

      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        // current active instance should no longer be kept-alive.
        // we can't unmount it now but it might be later, so reset its flag now.
        resetShapeFlag(current);
      }

      cache.delete(key);
      keys.delete(key);
    } // prune cache on include/exclude prop change


    watch(function () {
      return [props.include, props.exclude];
    }, function (_ref10) {
      var _ref11 = _slicedToArray(_ref10, 2),
          include = _ref11[0],
          exclude = _ref11[1];

      include && pruneCache(function (name) {
        return matches(include, name);
      });
      exclude && pruneCache(function (name) {
        return !matches(exclude, name);
      });
    }, // prune post-render after `current` has been updated
    {
      flush: 'post',
      deep: true
    }); // cache sub tree after render

    var pendingCacheKey = null;

    var cacheSubtree = function cacheSubtree() {
      // fix #1621, the pendingCacheKey could be 0
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };

    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(function () {
      cache.forEach(function (cached) {
        var subTree = instance.subTree,
            suspense = instance.suspense;
        var vnode = getInnerChild(subTree);

        if (cached.type === vnode.type) {
          // current instance will be unmounted as part of keep-alive's unmount
          resetShapeFlag(vnode); // but invoke its deactivated hook here

          var da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }

        unmount(cached);
      });
    });
    return function () {
      pendingCacheKey = null;

      if (!slots.default) {
        return null;
      }

      var children = slots.default();
      var rawVNode = children[0];

      if (children.length > 1) {
        if (true) {
          warn("KeepAlive should contain exactly one component child.");
        }

        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4
      /* STATEFUL_COMPONENT */
      ) && !(rawVNode.shapeFlag & 128
      /* SUSPENSE */
      )) {
        current = null;
        return rawVNode;
      }

      var vnode = getInnerChild(rawVNode);
      var comp = vnode.type; // for async components, name check should be based in its loaded
      // inner component if available

      var name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      var include = props.include,
          exclude = props.exclude,
          max = props.max;

      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }

      var key = vnode.key == null ? comp : vnode.key;
      var cachedVNode = cache.get(key); // clone vnode if it's reused because we are going to mutate it

      if (vnode.el) {
        vnode = cloneVNode(vnode);

        if (rawVNode.shapeFlag & 128
        /* SUSPENSE */
        ) {
            rawVNode.ssContent = vnode;
          }
      } // #1513 it's possible for the returned vnode to be cloned due to attr
      // fallthrough or scopeId, so the vnode here may not be the final vnode
      // that is mounted. Instead of caching it directly, we store the pending
      // key and cache `instance.subTree` (the normalized vnode) in
      // beforeMount/beforeUpdate hooks.


      pendingCacheKey = key;

      if (cachedVNode) {
        // copy over mounted state
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;

        if (vnode.transition) {
          // recursively update transition hooks on subTree
          setTransitionHooks(vnode, vnode.transition);
        } // avoid vnode being mounted as fresh


        vnode.shapeFlag |= 512
        /* COMPONENT_KEPT_ALIVE */
        ; // make this key the freshest

        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key); // prune oldest entry

        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      } // avoid vnode being unmounted


      vnode.shapeFlag |= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
      current = vnode;
      return rawVNode;
    };
  }
}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var KeepAlive = KeepAliveImpl;

function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
    return pattern.some(function (p) {
      return matches(p, name);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern.test) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a"
  /* ACTIVATED */
  , target);
}

function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da"
  /* DEACTIVATED */
  , target);
}

function registerKeepAliveHook(hook, type) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;

  // cache the deactivate branch check wrapper for injected hooks so the same
  // hook can be properly deduped by the scheduler. "__wdc" stands for "with
  // deactivation check".
  var wrappedHook = hook.__wdc || (hook.__wdc = function () {
    // only fire the hook if the target instance is NOT in a deactivated branch.
    var current = target;

    while (current) {
      if (current.isDeactivated) {
        return;
      }

      current = current.parent;
    }

    hook();
  });

  injectHook(type, wrappedHook, target); // In addition to registering it on the target instance, we walk up the parent
  // chain and register it on all ancestor instances that are keep-alive roots.
  // This avoids the need to walk the entire component tree when invoking these
  // hooks, and more importantly, avoids the need to track child components in
  // arrays.

  if (target) {
    var current = target.parent;

    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }

      current = current.parent;
    }
  }
}

function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  // injectHook wraps the original for error handling, so make sure to remove
  // the wrapped version.
  var injected = injectHook(type, hook, keepAliveRoot, true
  /* prepend */
  );
  onUnmounted(function () {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
  }, target);
}

function resetShapeFlag(vnode) {
  var shapeFlag = vnode.shapeFlag;

  if (shapeFlag & 256
  /* COMPONENT_SHOULD_KEEP_ALIVE */
  ) {
      shapeFlag -= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
    }

  if (shapeFlag & 512
  /* COMPONENT_KEPT_ALIVE */
  ) {
      shapeFlag -= 512
      /* COMPONENT_KEPT_ALIVE */
      ;
    }

  vnode.shapeFlag = shapeFlag;
}

function getInnerChild(vnode) {
  return vnode.shapeFlag & 128
  /* SUSPENSE */
  ? vnode.ssContent : vnode;
}

function injectHook(type, hook) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
  var prepend = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (target) {
    var hooks = target[type] || (target[type] = []); // cache the error handling wrapper for injected hooks so the same hook
    // can be properly deduped by the scheduler. "__weh" stands for "with error
    // handling".

    var wrappedHook = hook.__weh || (hook.__weh = function () {
      if (target.isUnmounted) {
        return;
      } // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.


      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // Set currentInstance during hook invocation.
      // This assumes the hook does not synchronously trigger other hooks, which
      // can only be false when the user does something really funky.

      setCurrentInstance(target);

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var res = callWithAsyncErrorHandling(hook, target, type, args);
      setCurrentInstance(null);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return res;
    });

    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }

    return wrappedHook;
  } else if (true) {
    var apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
    warn("".concat(apiName, " is called when there is no active component instance to be ") + "associated with. " + "Lifecycle injection APIs can only be used during execution of setup()." + (" If you are using async setup(), make sure to register lifecycle " + "hooks before the first await statement."));
  }
}

var createHook = function createHook(lifecycle) {
  return function (hook) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
    return (// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp"
      /* SERVER_PREFETCH */
      ) && injectHook(lifecycle, hook, target)
    );
  };
};

var onBeforeMount = createHook("bm"
/* BEFORE_MOUNT */
);
var onMounted = createHook("m"
/* MOUNTED */
);
var onBeforeUpdate = createHook("bu"
/* BEFORE_UPDATE */
);
var onUpdated = createHook("u"
/* UPDATED */
);
var onBeforeUnmount = createHook("bum"
/* BEFORE_UNMOUNT */
);
var onUnmounted = createHook("um"
/* UNMOUNTED */
);
var onServerPrefetch = createHook("sp"
/* SERVER_PREFETCH */
);
var onRenderTriggered = createHook("rtg"
/* RENDER_TRIGGERED */
);
var onRenderTracked = createHook("rtc"
/* RENDER_TRACKED */
);

function onErrorCaptured(hook) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
  injectHook("ec"
  /* ERROR_CAPTURED */
  , hook, target);
}

function createDuplicateChecker() {
  var cache = Object.create(null);
  return function (type, key) {
    if (cache[key]) {
      warn("".concat(type, " property \"").concat(key, "\" is already defined in ").concat(cache[key], "."));
    } else {
      cache[key] = type;
    }
  };
}

var shouldCacheAccess = true;

function applyOptions(instance) {
  var options = resolveMergedOptions(instance);
  var publicThis = instance.proxy;
  var ctx = instance.ctx; // do not cache property access on public proxy during state initialization

  shouldCacheAccess = false; // call beforeCreate first before accessing other options since
  // the hook may mutate resolved options (#2791)

  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc"
    /* BEFORE_CREATE */
    );
  }

  var dataOptions = options.data,
      computedOptions = options.computed,
      methods = options.methods,
      watchOptions = options.watch,
      provideOptions = options.provide,
      injectOptions = options.inject,
      created = options.created,
      beforeMount = options.beforeMount,
      mounted = options.mounted,
      beforeUpdate = options.beforeUpdate,
      updated = options.updated,
      activated = options.activated,
      deactivated = options.deactivated,
      beforeDestroy = options.beforeDestroy,
      beforeUnmount = options.beforeUnmount,
      destroyed = options.destroyed,
      unmounted = options.unmounted,
      render = options.render,
      renderTracked = options.renderTracked,
      renderTriggered = options.renderTriggered,
      errorCaptured = options.errorCaptured,
      serverPrefetch = options.serverPrefetch,
      expose = options.expose,
      inheritAttrs = options.inheritAttrs,
      components = options.components,
      directives = options.directives,
      filters = options.filters;
  var checkDuplicateProperties =  true ? createDuplicateChecker() : 0;

  if (true) {
    var _instance$propsOption3 = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption3[0];

    if (propsOptions) {
      for (var key in propsOptions) {
        checkDuplicateProperties("Props"
        /* PROPS */
        , key);
      }
    }
  } // options initialization order (to be consistent with Vue 2):
  // - props (already done outside of this function)
  // - inject
  // - methods
  // - data (deferred since it relies on `this` access)
  // - computed
  // - watch (deferred since it relies on `this` access)


  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }

  if (methods) {
    for (var _key5 in methods) {
      var methodHandler = methods[_key5];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
        // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
        // and those are read-only but reconfigurable, so it needs to be redefined here
        if (true) {
          Object.defineProperty(ctx, _key5, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {}

        if (true) {
          checkDuplicateProperties("Methods"
          /* METHODS */
          , _key5);
        }
      } else if (true) {
        warn("Method \"".concat(_key5, "\" has type \"").concat(_typeof(methodHandler), "\" in the component definition. ") + "Did you reference the function correctly?");
      }
    }
  }

  if (dataOptions) {
    (function () {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
        warn("The data option must be a function. " + "Plain object usage is no longer supported.");
      }

      var data = dataOptions.call(publicThis, publicThis);

      if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
        warn("data() returned a Promise - note data() cannot be async; If you " + "intend to perform data fetching before component renders, use " + "async setup() + <Suspense>.");
      }

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
         true && warn("data() should return an object.");
      } else {
        instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);

        if (true) {
          var _loop = function _loop(_key6) {
            checkDuplicateProperties("Data"
            /* DATA */
            , _key6); // expose data on ctx during dev

            if (_key6[0] !== '$' && _key6[0] !== '_') {
              Object.defineProperty(ctx, _key6, {
                configurable: true,
                enumerable: true,
                get: function get() {
                  return data[_key6];
                },
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
              });
            }
          };

          for (var _key6 in data) {
            _loop(_key6);
          }
        }
      }
    })();
  } // state initialization complete at this point - start caching access


  shouldCacheAccess = true;

  if (computedOptions) {
    var _loop2 = function _loop2(_key7) {
      var opt = computedOptions[_key7];
      var get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;

      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        warn("Computed property \"".concat(_key7, "\" has no getter."));
      }

      var set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? function () {
        warn("Write operation failed: computed property \"".concat(_key7, "\" is readonly."));
      } : 0;
      var c = computed({
        get: get,
        set: set
      });
      Object.defineProperty(ctx, _key7, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return c.value;
        },
        set: function set(v) {
          return c.value = v;
        }
      });

      if (true) {
        checkDuplicateProperties("Computed"
        /* COMPUTED */
        , _key7);
      }
    };

    for (var _key7 in computedOptions) {
      _loop2(_key7);
    }
  }

  if (watchOptions) {
    for (var _key8 in watchOptions) {
      createWatcher(watchOptions[_key8], ctx, publicThis, _key8);
    }
  }

  if (provideOptions) {
    var provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach(function (key) {
      provide(key, provides[key]);
    });
  }

  if (created) {
    callHook(created, instance, "c"
    /* CREATED */
    );
  }

  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      hook.forEach(function (_hook) {
        return register(_hook.bind(publicThis));
      });
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }

  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
    if (expose.length) {
      var exposed = instance.exposed || (instance.exposed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)({}));
      expose.forEach(function (key) {
        exposed[key] = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(publicThis, key);
      });
    } else if (!instance.exposed) {
      instance.exposed = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
  } // options that are handled when creating the instance but also need to be
  // applied from mixins


  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    instance.render = render;
  }

  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  } // asset options.


  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}

function resolveInjections(injectOptions, ctx) {
  var checkDuplicateProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }

  for (var key in injectOptions) {
    var opt = injectOptions[key];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
      if ('default' in opt) {
        ctx[key] = inject(opt.from || key, opt.default, true
        /* treat default function as factory */
        );
      } else {
        ctx[key] = inject(opt.from || key);
      }
    } else {
      ctx[key] = inject(opt);
    }

    if (true) {
      checkDuplicateProperties("Inject"
      /* INJECT */
      , key);
    }
  }
}

function callHook(hook, instance, type) {
  callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map(function (h) {
    return h.bind(instance.proxy);
  }) : hook.bind(instance.proxy), instance, type);
}

function createWatcher(raw, ctx, publicThis, key) {
  var getter = key.includes('.') ? createPathGetter(publicThis, key) : function () {
    return publicThis[key];
  };

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
    var handler = ctx[raw];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
      watch(getter, handler);
    } else if (true) {
      warn("Invalid watch handler specified by key \"".concat(raw, "\""), handler);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
      raw.forEach(function (r) {
        return createWatcher(r, ctx, publicThis, key);
      });
    } else {
      var _handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_handler)) {
        watch(getter, _handler, raw);
      } else if (true) {
        warn("Invalid watch handler specified by key \"".concat(raw.handler, "\""), _handler);
      }
    }
  } else if (true) {
    warn("Invalid watch option: \"".concat(key, "\""), raw);
  }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */


function resolveMergedOptions(instance) {
  var base = instance.type;
  var mixins = base.mixins,
      extendsOptions = base.extends;
  var _instance$appContext = instance.appContext,
      globalMixins = _instance$appContext.mixins,
      cache = _instance$appContext.optionsCache,
      optionMergeStrategies = _instance$appContext.config.optionMergeStrategies;
  var cached = cache.get(base);
  var resolved;

  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};

    if (globalMixins.length) {
      globalMixins.forEach(function (m) {
        return mergeOptions(resolved, m, optionMergeStrategies, true);
      });
    }

    mergeOptions(resolved, base, optionMergeStrategies);
  }

  cache.set(base, resolved);
  return resolved;
}

function mergeOptions(to, from, strats) {
  var asMixin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var mixins = from.mixins,
      extendsOptions = from.extends;

  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }

  if (mixins) {
    mixins.forEach(function (m) {
      return mergeOptions(to, m, strats, true);
    });
  }

  for (var key in from) {
    if (asMixin && key === 'expose') {
       true && warn("\"expose\" option is ignored when declared in mixins or extends. " + "It should only be declared in the base component itself.");
    } else {
      var strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }

  return to;
}

var internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeHook,
  created: mergeHook,
  beforeMount: mergeHook,
  mounted: mergeHook,
  beforeUpdate: mergeHook,
  updated: mergeHook,
  beforeDestroy: mergeHook,
  destroyed: mergeHook,
  activated: mergeHook,
  deactivated: mergeHook,
  errorCaptured: mergeHook,
  serverPrefetch: mergeHook,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch has special merge behavior in v2, but isn't actually needed in v3.
  // since we are only exposing these for compat and nobody should be relying
  // on the watch-specific behavior, just expose the object merge strat.
  watch: mergeObjectOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};

function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }

  if (!to) {
    return from;
  }

  return function mergedDataFn() {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
  };
}

function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}

function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    var res = {};

    for (var i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }

    return res;
  }

  return raw;
}

function mergeHook(to, from) {
  return to ? _toConsumableArray(new Set([].concat(to, from))) : from;
}

function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}

function initProps(instance, rawProps, isStateful) {
  var isSSR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var props = {};
  var attrs = {};
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props, attrs); // ensure all declared prop keys are present

  for (var key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = undefined;
    }
  } // validation


  if (true) {
    validateProps(rawProps || {}, props, instance);
  }

  if (isStateful) {
    // stateful
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
  } else {
    if (!instance.type.props) {
      // functional w/ optional props, props === attrs
      instance.props = attrs;
    } else {
      // functional w/ declared props
      instance.props = props;
    }
  }

  instance.attrs = attrs;
}

function updateProps(instance, rawProps, rawPrevProps, optimized) {
  var props = instance.props,
      attrs = instance.attrs,
      patchFlag = instance.vnode.patchFlag;
  var rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);

  var _instance$propsOption4 = _slicedToArray(instance.propsOptions, 1),
      options = _instance$propsOption4[0];

  var hasAttrsChanged = false;

  if ( // always force full diff in dev
  // - #1942 if hmr is enabled with sfc component
  // - vite#872 non-sfc component used by sfc component
  !( true && (instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId)) && (optimized || patchFlag > 0) && !(patchFlag & 16
  /* FULL_PROPS */
  )) {
    if (patchFlag & 8
    /* PROPS */
    ) {
        // Compiler-generated props & no keys change, just set the updated
        // the props.
        var propsToUpdate = instance.vnode.dynamicProps;

        for (var i = 0; i < propsToUpdate.length; i++) {
          var key = propsToUpdate[i]; // PROPS flag guarantees rawProps to be non-null

          var value = rawProps[key];

          if (options) {
            // attr / props separation was done on init and will be consistent
            // in this code path, so just check if attrs have it.
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              var camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false
              /* isAbsent */
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
  } else {
    // full props update.
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    } // in case of dynamic props, check if we need to delete keys from
    // the props object


    var kebabKey;

    for (var _key9 in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, _key9) && ( // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      (kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(_key9)) === _key9 || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && ( // for camelCase
          rawPrevProps[_key9] !== undefined || // for kebab-case
          rawPrevProps[kebabKey] !== undefined)) {
            props[_key9] = resolvePropValue(options, rawCurrentProps, _key9, undefined, instance, true
            /* isAbsent */
            );
          }
        } else {
          delete props[_key9];
        }
      }
    } // in the case of functional component w/o props declaration, props and
    // attrs point to the same object so it should already have been updated.


    if (attrs !== rawCurrentProps) {
      for (var _key10 in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, _key10)) {
          delete attrs[_key10];
          hasAttrsChanged = true;
        }
      }
    }
  } // trigger updates for $attrs in case it's used in component slots


  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set"
    /* SET */
    , '$attrs');
  }

  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}

function setFullProps(instance, rawProps, props, attrs) {
  var _instance$propsOption5 = _slicedToArray(instance.propsOptions, 2),
      options = _instance$propsOption5[0],
      needCastKeys = _instance$propsOption5[1];

  var hasAttrsChanged = false;
  var rawCastValues;

  if (rawProps) {
    for (var key in rawProps) {
      // key, ref are reserved and never passed down
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
        continue;
      }

      var value = rawProps[key]; // prop option names are camelized during normalization, so to support
      // kebab -> camel conversion here we need to camelize the key.

      var camelKey = void 0;

      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }

  if (needCastKeys) {
    var rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    var castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

    for (var i = 0; i < needCastKeys.length; i++) {
      var _key11 = needCastKeys[i];
      props[_key11] = resolvePropValue(options, rawCurrentProps, _key11, castValues[_key11], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, _key11));
    }
  }

  return hasAttrsChanged;
}

function resolvePropValue(options, props, key, value, instance, isAbsent) {
  var opt = options[key];

  if (opt != null) {
    var hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default'); // default values

    if (hasDefault && value === undefined) {
      var defaultValue = opt.default;

      if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
        var propsDefaults = instance.propsDefaults;

        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          setCurrentInstance(null);
        }
      } else {
        value = defaultValue;
      }
    } // boolean casting


    if (opt[0
    /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1
      /* shouldCastTrue */
      ] && (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
        value = true;
      }
    }
  }

  return value;
}

function normalizePropsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.propsCache;
  var cached = cache.get(comp);

  if (cached) {
    return cached;
  }

  var raw = comp.props;
  var normalized = {};
  var needCastKeys = []; // apply mixin/extends props

  var hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    var extendProps = function extendProps(raw) {
      hasExtends = true;

      var _normalizePropsOption = normalizePropsOptions(raw, appContext, true),
          _normalizePropsOption2 = _slicedToArray(_normalizePropsOption, 2),
          props = _normalizePropsOption2[0],
          keys = _normalizePropsOption2[1];

      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
      if (keys) needCastKeys.push.apply(needCastKeys, _toConsumableArray(keys));
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }

    if (comp.extends) {
      extendProps(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    for (var i = 0; i < raw.length; i++) {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
        warn("props must be strings when using array syntax.", raw[i]);
      }

      var normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);

      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
      warn("invalid props options", raw);
    }

    for (var key in raw) {
      var _normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);

      if (validatePropName(_normalizedKey)) {
        var opt = raw[key];
        var prop = normalized[_normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? {
          type: opt
        } : opt;

        if (prop) {
          var booleanIndex = getTypeIndex(Boolean, prop.type);
          var stringIndex = getTypeIndex(String, prop.type);
          prop[0
          /* shouldCast */
          ] = booleanIndex > -1;
          prop[1
          /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex; // if the prop needs boolean casting or default value

          if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
            needCastKeys.push(_normalizedKey);
          }
        }
      }
    }
  }

  var res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}

function validatePropName(key) {
  if (key[0] !== '$') {
    return true;
  } else if (true) {
    warn("Invalid prop name: \"".concat(key, "\" is a reserved property."));
  }

  return false;
} // use function string name to check type constructors
// so that it works across vms / iframes.


function getType(ctor) {
  var match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
    return expectedTypes.findIndex(function (t) {
      return isSameType(t, type);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  return -1;
}
/**
 * dev only
 */


function validateProps(rawProps, props, instance) {
  var resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  var options = instance.propsOptions[0];

  for (var key in options) {
    var opt = options[key];
    if (opt == null) continue;
    validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
  }
}
/**
 * dev only
 */


function validateProp(name, value, prop, isAbsent) {
  var type = prop.type,
      required = prop.required,
      validator = prop.validator; // required!

  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  } // missing but optional


  if (value == null && !prop.required) {
    return;
  } // type check


  if (type != null && type !== true) {
    var isValid = false;
    var types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
    var expectedTypes = []; // value is valid as long as one of the specified types match

    for (var i = 0; i < types.length && !isValid; i++) {
      var _assertType = assertType(value, types[i]),
          valid = _assertType.valid,
          expectedType = _assertType.expectedType;

      expectedTypes.push(expectedType || '');
      isValid = valid;
    }

    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  } // custom validator


  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}

var isSimpleType = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (isSimpleType(expectedType)) {
    var t = _typeof(value);

    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
  } else if (expectedType === 'Array') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * dev only
 */


function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") + " Expected ".concat(expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value ".concat(expectedValue);
  }

  message += ", got ".concat(receivedType, " "); // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value ".concat(receivedValue, ".");
  }

  return message;
}
/**
 * dev only
 */


function styleValue(value, type) {
  if (type === 'String') {
    return "\"".concat(value, "\"");
  } else if (type === 'Number') {
    return "".concat(Number(value));
  } else {
    return "".concat(value);
  }
}
/**
 * dev only
 */


function isExplicable(type) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return type.toLowerCase() === elem;
  });
}
/**
 * dev only
 */


function isBoolean() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key12 = 0; _key12 < _len5; _key12++) {
    args[_key12] = arguments[_key12];
  }

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}

var isInternalKey = function isInternalKey(key) {
  return key[0] === '_' || key === '$stable';
};

var normalizeSlotValue = function normalizeSlotValue(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
};

var normalizeSlot = function normalizeSlot(key, rawSlot, ctx) {
  var normalized = withCtx(function (props) {
    if ( true && currentInstance) {
      warn("Slot \"".concat(key, "\" invoked outside of the render function: ") + "this will not track dependencies used in the slot. " + "Invoke the slot function inside the render function instead.");
    }

    return normalizeSlotValue(rawSlot(props));
  }, ctx);
  normalized._c = false;
  return normalized;
};

var normalizeObjectSlots = function normalizeObjectSlots(rawSlots, slots, instance) {
  var ctx = rawSlots._ctx;

  for (var key in rawSlots) {
    if (isInternalKey(key)) continue;
    var value = rawSlots[key];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      (function () {
        if (true) {
          warn("Non-function value encountered for slot \"".concat(key, "\". ") + "Prefer function slots for better performance.");
        }

        var normalized = normalizeSlotValue(value);

        slots[key] = function () {
          return normalized;
        };
      })();
    }
  }
};

var normalizeVNodeSlots = function normalizeVNodeSlots(instance, children) {
  if ( true && !isKeepAlive(instance.vnode) && !false) {
    warn("Non-function value encountered for default slot. " + "Prefer function slots for better performance.");
  }

  var normalized = normalizeSlotValue(children);

  instance.slots.default = function () {
    return normalized;
  };
};

var initSlots = function initSlots(instance, children) {
  if (instance.vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
      var type = children._;

      if (type) {
        // users can get the shallow readonly version of the slots object through `this.$slots`,
        // we should avoid the proxy object polluting the slots of the internal instance
        instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children); // make compiler marker non-enumerable

        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
      } else {
        normalizeObjectSlots(children, instance.slots = {});
      }
    } else {
    instance.slots = {};

    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }

  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};

var updateSlots = function updateSlots(instance, children, optimized) {
  var vnode = instance.vnode,
      slots = instance.slots;
  var needDeletionCheck = true;
  var deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  if (vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
      var type = children._;

      if (type) {
        // compiled slots.
        if ( true && isHmrUpdating) {
          // Parent was HMR updated so slot content may have changed.
          // force update slots and mark instance for hmr as well
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
        } else if (optimized && type === 1
        /* STABLE */
        ) {
            // compiled AND stable.
            // no need to update, and skip stale slots removal.
            needDeletionCheck = false;
          } else {
          // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
          // normalization.
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children); // #2893
          // when rendering the optimized slots by manually written render function,
          // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
          // i.e. let the `renderSlot` create the bailed Fragment

          if (!optimized && type === 1
          /* STABLE */
          ) {
              delete slots._;
            }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }

      deletionComparisonTarget = children;
    } else if (children) {
    // non slot object children (direct value) passed to a component
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      default: 1
    };
  } // delete stale slots


  if (needDeletionCheck) {
    for (var key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/


var isBuiltInDirective = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');

function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn('Do not use built-in directive ids as custom directive id: ' + name);
  }
}
/**
 * Adds directives to a VNode.
 */


function withDirectives(vnode, directives) {
  var internalInstance = currentRenderingInstance;

  if (internalInstance === null) {
     true && warn("withDirectives can only be used inside render functions.");
    return vnode;
  }

  var instance = internalInstance.proxy;
  var bindings = vnode.dirs || (vnode.dirs = []);

  for (var i = 0; i < directives.length; i++) {
    var _directives$i = _slicedToArray(directives[i], 4),
        dir = _directives$i[0],
        value = _directives$i[1],
        arg = _directives$i[2],
        _directives$i$ = _directives$i[3],
        modifiers = _directives$i$ === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ : _directives$i$;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }

    bindings.push({
      dir: dir,
      instance: instance,
      value: value,
      oldValue: void 0,
      arg: arg,
      modifiers: modifiers
    });
  }

  return vnode;
}

function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  var bindings = vnode.dirs;
  var oldBindings = prevVNode && prevVNode.dirs;

  for (var i = 0; i < bindings.length; i++) {
    var binding = bindings[i];

    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }

    var hook = binding.dir[name];

    if (hook) {
      // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithAsyncErrorHandling(hook, instance, 8
      /* DIRECTIVE_HOOK */
      , [vnode.el, binding, vnode, prevVNode]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
  }
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: undefined,
      warnHandler: undefined,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}

var uid = 0;

function createAppAPI(render, hydrate) {
  return function createApp(rootComponent) {
    var rootProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
       true && warn("root props passed to app.mount() must be an object.");
      rootProps = null;
    }

    var context = createAppContext();
    var installedPlugins = new Set();
    var isMounted = false;
    var app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      version: version,

      get config() {
        return context.config;
      },

      set config(v) {
        if (true) {
          warn("app.config cannot be replaced. Modify individual options instead.");
        }
      },

      use: function use(plugin) {
        for (var _len6 = arguments.length, options = new Array(_len6 > 1 ? _len6 - 1 : 0), _key13 = 1; _key13 < _len6; _key13++) {
          options[_key13 - 1] = arguments[_key13];
        }

        if (installedPlugins.has(plugin)) {
           true && warn("Plugin has already been applied to target app.");
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install.apply(plugin, [app].concat(options));
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
          installedPlugins.add(plugin);
          plugin.apply(void 0, [app].concat(options));
        } else if (true) {
          warn("A plugin must either be a function or an object with an \"install\" " + "function.");
        }

        return app;
      },
      mixin: function mixin(_mixin) {
        if (true) {
          if (!context.mixins.includes(_mixin)) {
            context.mixins.push(_mixin);
          } else if (true) {
            warn('Mixin has already been applied to target app' + (_mixin.name ? ": ".concat(_mixin.name) : ''));
          }
        } else {}

        return app;
      },
      component: function component(name, _component) {
        if (true) {
          validateComponentName(name, context.config);
        }

        if (!_component) {
          return context.components[name];
        }

        if ( true && context.components[name]) {
          warn("Component \"".concat(name, "\" has already been registered in target app."));
        }

        context.components[name] = _component;
        return app;
      },
      directive: function directive(name, _directive) {
        if (true) {
          validateDirectiveName(name);
        }

        if (!_directive) {
          return context.directives[name];
        }

        if ( true && context.directives[name]) {
          warn("Directive \"".concat(name, "\" has already been registered in target app."));
        }

        context.directives[name] = _directive;
        return app;
      },
      mount: function mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          var vnode = createVNode(rootComponent, rootProps); // store app context on the root VNode.
          // this will be set on the root instance on initial mount.

          vnode.appContext = context; // HMR root reload

          if (true) {
            context.reload = function () {
              render(cloneVNode(vnode), rootContainer, isSVG);
            };
          }

          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }

          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;

          if (true) {
            devtoolsInitApp(app, version);
          }

          return vnode.component.proxy;
        } else if (true) {
          warn("App has already been mounted.\n" + "If you want to remount the same app, move your app creation logic " + "into a factory function and create fresh app instances for each " + "mount - e.g. `const createMyApp = () => createApp(App)`");
        }
      },
      unmount: function unmount() {
        if (isMounted) {
          render(null, app._container);

          if (true) {
            devtoolsUnmountApp(app);
          }

          delete app._container.__vue_app__;
        } else if (true) {
          warn("Cannot unmount an app that is not mounted.");
        }
      },
      provide: function provide(key, value) {
        if ( true && key in context.provides) {
          warn("App already provides property with key \"".concat(String(key), "\". ") + "It will be overwritten with the new value.");
        } // TypeScript doesn't allow symbols as index type
        // https://github.com/Microsoft/TypeScript/issues/24587


        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}

var hasMismatch = false;

var isSVGContainer = function isSVGContainer(container) {
  return /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
};

var isComment = function isComment(node) {
  return node.nodeType === 8;
}
/* COMMENT */
; // Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.


function createHydrationFunctions(rendererInternals) {
  var mountComponent = rendererInternals.mt,
      patch = rendererInternals.p,
      _rendererInternals$o2 = rendererInternals.o,
      patchProp = _rendererInternals$o2.patchProp,
      nextSibling = _rendererInternals$o2.nextSibling,
      parentNode = _rendererInternals$o2.parentNode,
      remove = _rendererInternals$o2.remove,
      insert = _rendererInternals$o2.insert,
      createComment = _rendererInternals$o2.createComment;

  var hydrate = function hydrate(vnode, container) {
    if ( true && !container.hasChildNodes()) {
      warn("Attempting to hydrate existing markup but container is empty. " + "Performing full mount instead.");
      patch(null, vnode, container);
      return;
    }

    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();

    if (hasMismatch && !false) {
      // this error should show up in production
      console.error("Hydration completed but contains mismatches.");
    }
  };

  var hydrateNode = function hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds) {
    var optimized = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var isFragmentStart = isComment(node) && node.data === '[';

    var onMismatch = function onMismatch() {
      return handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    };

    var type = vnode.type,
        ref = vnode.ref,
        shapeFlag = vnode.shapeFlag;
    var domType = node.nodeType;
    vnode.el = node;
    var nextNode = null;

    switch (type) {
      case Text:
        if (domType !== 3
        /* TEXT */
        ) {
            nextNode = onMismatch();
          } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
             true && warn("Hydration text mismatch:" + "\n- Client: ".concat(JSON.stringify(node.data)) + "\n- Server: ".concat(JSON.stringify(vnode.children)));
            node.data = vnode.children;
          }

          nextNode = nextSibling(node);
        }

        break;

      case Comment$1:
        if (domType !== 8
        /* COMMENT */
        || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }

        break;

      case Static:
        if (domType !== 1
        /* ELEMENT */
        ) {
            nextNode = onMismatch();
          } else {
          // determine anchor, adopt content
          nextNode = node; // if the static vnode has its content stripped during build,
          // adopt it from the server-rendered HTML.

          var needToAdoptContent = !vnode.children.length;

          for (var i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.outerHTML;

            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }

            nextNode = nextSibling(nextNode);
          }

          return nextNode;
        }

        break;

      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
            if (domType !== 1
            /* ELEMENT */
            || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
          } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
            // when setting up the render effect, if the initial vnode already
            // has .el set, the component will perform hydration instead of mount
            // on its sub-tree.
            vnode.slotScopeIds = slotScopeIds;
            var container = parentNode(node);
            mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized); // component may be async, so in the case of fragments we cannot rely
            // on component's rendered output to determine the end of the fragment
            // instead, we do a lookahead to find the end anchor node.

            nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node); // #3787
            // if component is async, it may get moved / unmounted before its
            // inner component is loaded, so we need to give it a placeholder
            // vnode that matches its adopted DOM.

            if (isAsyncWrapper(vnode)) {
              var subTree;

              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');
              }

              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
            if (domType !== 8
            /* COMMENT */
            ) {
                nextNode = onMismatch();
              } else {
              nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
            }
          } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
          } else if (true) {
          warn('Invalid HostVNode type:', type, "(".concat(_typeof(type), ")"));
        }

    }

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }

    return nextNode;
  };

  var hydrateElement = function hydrateElement(el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!vnode.dynamicChildren;
    var props = vnode.props,
        patchFlag = vnode.patchFlag,
        shapeFlag = vnode.shapeFlag,
        dirs = vnode.dirs; // skip props & children if this is hoisted static nodes

    if (patchFlag !== -1
    /* HOISTED */
    ) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, 'created');
        } // props


        if (props) {
          if (!optimized || patchFlag & 16
          /* FULL_PROPS */
          || patchFlag & 32
          /* HYDRATE_EVENTS */
          ) {
            for (var key in props) {
              if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                patchProp(el, key, null, props[key]);
              }
            }
          } else if (props.onClick) {
            // Fast path for click listeners (which is most often) to avoid
            // iterating through props.
            patchProp(el, 'onClick', null, props.onClick);
          }
        } // vnode / directive hooks


        var vnodeHooks;

        if (vnodeHooks = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }

        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }

        if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
          queueEffectWithSuspense(function () {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
          }, parentSuspense);
        } // children


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        && // skip if element has innerHTML / textContent
        !(props && (props.innerHTML || props.textContent))) {
          var next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
          var _hasWarned = false;

          while (next) {
            hasMismatch = true;

            if ( true && !_hasWarned) {
              warn("Hydration children mismatch in <".concat(vnode.type, ">: ") + "server rendered element contains more child nodes than client vdom.");
              _hasWarned = true;
            } // The SSRed DOM contains more nodes than it should. Remove them.


            var cur = next;
            next = next.nextSibling;
            remove(cur);
          }
        } else if (shapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
            if (el.textContent !== vnode.children) {
              hasMismatch = true;
               true && warn("Hydration text content mismatch in <".concat(vnode.type, ">:\n") + "- Client: ".concat(el.textContent, "\n") + "- Server: ".concat(vnode.children));
              el.textContent = vnode.children;
            }
          }
      }

    return el.nextSibling;
  };

  var hydrateChildren = function hydrateChildren(node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!parentVNode.dynamicChildren;
    var children = parentVNode.children;
    var l = children.length;
    var hasWarned = false;

    for (var i = 0; i < l; i++) {
      var vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);

      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;

        if ( true && !hasWarned) {
          warn("Hydration children mismatch in <".concat(container.tagName.toLowerCase(), ">: ") + "server rendered element contains fewer child nodes than client vdom.");
          hasWarned = true;
        } // the SSRed DOM didn't contain enough nodes. Mount the missing ones.


        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }

    return node;
  };

  var hydrateFragment = function hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    var fragmentSlotScopeIds = vnode.slotScopeIds;

    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    var container = parentNode(node);
    var next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);

    if (next && isComment(next) && next.data === ']') {
      return nextSibling(vnode.anchor = next);
    } else {
      // fragment didn't hydrate successfully, since we didn't get a end anchor
      // back. This should have led to node/children mismatch warnings.
      hasMismatch = true; // since the anchor is missing, we need to create one and insert it

      insert(vnode.anchor = createComment("]"), container, next);
      return next;
    }
  };

  var handleMismatch = function handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) {
    hasMismatch = true;
     true && warn("Hydration node mismatch:\n- Client vnode:", vnode.type, "\n- Server rendered DOM:", node, node.nodeType === 3
    /* TEXT */
    ? "(text)" : isComment(node) && node.data === '[' ? "(start of fragment)" : "");
    vnode.el = null;

    if (isFragment) {
      // remove excessive fragment nodes
      var end = locateClosingAsyncAnchor(node);

      while (true) {
        var _next2 = nextSibling(node);

        if (_next2 && _next2 !== end) {
          remove(_next2);
        } else {
          break;
        }
      }
    }

    var next = nextSibling(node);
    var container = parentNode(node);
    remove(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };

  var locateClosingAsyncAnchor = function locateClosingAsyncAnchor(node) {
    var match = 0;

    while (node) {
      node = nextSibling(node);

      if (node && isComment(node)) {
        if (node.data === '[') match++;

        if (node.data === ']') {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }

    return node;
  };

  return [hydrate, hydrateNode];
}

var supported;
var perf;

function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark("vue-".concat(type, "-").concat(instance.uid));
  }

  if (true) {
    devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
  }
}

function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    var startTag = "vue-".concat(type, "-").concat(instance.uid);
    var endTag = startTag + ":end";
    perf.mark(endTag);
    perf.measure("<".concat(formatComponentName(instance, instance.type), "> ").concat(type), startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }

  if (true) {
    devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
  }
}

function isSupported() {
  if (supported !== undefined) {
    return supported;
  }
  /* eslint-disable no-restricted-globals */


  if (typeof window !== 'undefined' && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  /* eslint-enable no-restricted-globals */


  return supported;
}
/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */


function initFeatureFlags() {
  var needWarn = false;

  if (false) {}

  if (false) {}

  if ( true && needWarn) {
    console.warn("You are running the esm-bundler build of Vue. It is recommended to " + "configure your bundler to explicitly replace feature flag globals " + "with boolean literals to get proper tree-shaking in the final bundle. " + "See http://link.vuejs.org/feature-flags for more details.");
  }
}

var prodEffectOptions = {
  scheduler: queueJob,
  // #1801, #2043 component render effects should allow recursive updates
  allowRecurse: true
};

function createDevEffectOptions(instance) {
  return {
    scheduler: queueJob,
    allowRecurse: true,
    onTrack: instance.rtc ? function (e) {
      return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e);
    } : void 0,
    onTrigger: instance.rtg ? function (e) {
      return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e);
    } : void 0
  };
}

var queuePostRenderEffect = queueEffectWithSuspense;

var setRef = function setRef(rawRef, oldRawRef, parentSuspense, vnode) {
  var isUnmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
    rawRef.forEach(function (r, i) {
      return setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount);
    });
    return;
  }

  if (isAsyncWrapper(vnode) && !isUnmount) {
    // when mounting async components, nothing needs to be done,
    // because the template ref is forwarded to inner component
    return;
  }

  var refValue = vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ? vnode.component.exposed || vnode.component.proxy : vnode.el;
  var value = isUnmount ? null : refValue;
  var owner = rawRef.i,
      ref = rawRef.r;

  if ( true && !owner) {
    warn("Missing ref owner context. ref cannot be used on hoisted vnodes. " + "A vnode with ref must be created inside the render function.");
    return;
  }

  var oldRef = oldRawRef && oldRawRef.r;
  var refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  var setupState = owner.setupState; // dynamic ref changed. unset old ref

  if (oldRef != null && oldRef !== ref) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
      refs[oldRef] = null;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
      oldRef.value = null;
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref)) {
    var doSet = function doSet() {
      {
        refs[ref] = value;
      }

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
        setupState[ref] = value;
      }
    }; // #1789: for non-null values, set them after render
    // null values means this is unmount and it should not overwrite another
    // ref with the same key


    if (value) {
      doSet.id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
    var _doSet = function _doSet() {
      ref.value = value;
    };

    if (value) {
      _doSet.id = -1;
      queuePostRenderEffect(_doSet, parentSuspense);
    } else {
      _doSet();
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
    callWithErrorHandling(ref, owner, 12
    /* FUNCTION_REF */
    , [value, refs]);
  } else if (true) {
    warn('Invalid template ref type:', value, "(".concat(_typeof(value), ")"));
  }
};
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */


function createRenderer(options) {
  return baseCreateRenderer(options);
} // Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.


function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
} // implementation


function baseCreateRenderer(options, createHydrationFns) {
  // compile-time feature flags check
  {
    initFeatureFlags();
  }

  if (true) {
    var target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);
  }

  var hostInsert = options.insert,
      hostRemove = options.remove,
      hostPatchProp = options.patchProp,
      hostForcePatchProp = options.forcePatchProp,
      hostCreateElement = options.createElement,
      hostCreateText = options.createText,
      hostCreateComment = options.createComment,
      hostSetText = options.setText,
      hostSetElementText = options.setElementText,
      hostParentNode = options.parentNode,
      hostNextSibling = options.nextSibling,
      _options$setScopeId = options.setScopeId,
      hostSetScopeId = _options$setScopeId === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP : _options$setScopeId,
      hostCloneNode = options.cloneNode,
      hostInsertStaticContent = options.insertStaticContent; // Note: functions inside this closure should use `const xxx = () => {}`
  // style in order to prevent being inlined by minifiers.

  var patch = function patch(n1, n2, container) {
    var anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var parentComponent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var parentSuspense = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var isSVG = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var slotScopeIds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;

    // patching & not same type, unmount old tree
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }

    if (n2.patchFlag === -2
    /* BAIL */
    ) {
        optimized = false;
        n2.dynamicChildren = null;
      }

    var type = n2.type,
        ref = n2.ref,
        shapeFlag = n2.shapeFlag;

    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;

      case Comment$1:
        processCommentNode(n1, n2, container, anchor);
        break;

      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (true) {
          patchStaticNode(n1, n2, container, isSVG);
        }

        break;

      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (true) {
          warn('Invalid VNode type:', type, "(".concat(_typeof(type), ")"));
        }

    } // set ref


    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };

  var processText = function processText(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      var el = n2.el = n1.el;

      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };

  var processCommentNode = function processCommentNode(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);
    } else {
      // there's no support for dynamic comments
      n2.el = n1.el;
    }
  };

  var mountStaticNode = function mountStaticNode(n2, container, anchor, isSVG) {
    var _hostInsertStaticCont = hostInsertStaticContent(n2.children, container, anchor, isSVG);

    var _hostInsertStaticCont2 = _slicedToArray(_hostInsertStaticCont, 2);

    n2.el = _hostInsertStaticCont2[0];
    n2.anchor = _hostInsertStaticCont2[1];
  };
  /**
   * Dev / HMR only
   */


  var patchStaticNode = function patchStaticNode(n1, n2, container, isSVG) {
    // static nodes are only patched during dev for HMR
    if (n2.children !== n1.children) {
      var anchor = hostNextSibling(n1.anchor); // remove existing

      removeStaticNode(n1);

      var _hostInsertStaticCont3 = hostInsertStaticContent(n2.children, container, anchor, isSVG);

      var _hostInsertStaticCont4 = _slicedToArray(_hostInsertStaticCont3, 2);

      n2.el = _hostInsertStaticCont4[0];
      n2.anchor = _hostInsertStaticCont4[1];
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };

  var moveStaticNode = function moveStaticNode(_ref12, container, nextSibling) {
    var el = _ref12.el,
        anchor = _ref12.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }

    hostInsert(anchor, container, nextSibling);
  };

  var removeStaticNode = function removeStaticNode(_ref13) {
    var el = _ref13.el,
        anchor = _ref13.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }

    hostRemove(anchor);
  };

  var processElement = function processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    isSVG = isSVG || n2.type === 'svg';

    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var mountElement = function mountElement(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el;
    var vnodeHook;
    var type = vnode.type,
        props = vnode.props,
        shapeFlag = vnode.shapeFlag,
        transition = vnode.transition,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs;

    if (false
    /* HOISTED */
    ) {} else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props); // mount children first, since some props may rely on child content
      // being already rendered, e.g. `<select value>`

      if (shapeFlag & 8
      /* TEXT_CHILDREN */
      ) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized || !!vnode.dynamicChildren);
        }

      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'created');
      } // props


      if (props) {
        for (var key in props) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }

        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      } // scopeId


      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }

    if (true) {
      Object.defineProperty(el, '__vnode', {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, '__vueParentComponent', {
        value: parentComponent,
        enumerable: false
      });
    }

    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
    } // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
    // #1689 For inside suspense + suspense resolved case, just call it


    var needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;

    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }

    hostInsert(el, container, anchor);

    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
      }, parentSuspense);
    }
  };

  var setScopeId = function setScopeId(el, vnode, scopeId, slotScopeIds, parentComponent) {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }

    if (slotScopeIds) {
      for (var i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }

    if (parentComponent) {
      var subTree = parentComponent.subTree;

      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048
      /* DEV_ROOT_FRAGMENT */
      ) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }

      if (vnode === subTree) {
        var parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };

  var mountChildren = function mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var start = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

    for (var i = start; i < children.length; i++) {
      var child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var patchElement = function patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el = n2.el = n1.el;
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        dirs = n2.dirs; // #1426 take the old vnode's patch flag into account since user may clone a
    // compiler-generated vnode, which de-opts to FULL_PROPS

    patchFlag |= n1.patchFlag & 16
    /* FULL_PROPS */
    ;
    var oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    var newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    var vnodeHook;

    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }

    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
    }

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }

    if (patchFlag > 0) {
      // the presence of a patchFlag means this element's render code was
      // generated by the compiler and can take the fast path.
      // in this path old node and new node are guaranteed to have the same shape
      // (i.e. at the exact same position in the source template)
      if (patchFlag & 16
      /* FULL_PROPS */
      ) {
          // element props contain dynamic keys, full diff needed
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
        // class
        // this flag is matched when the element has dynamic class bindings.
        if (patchFlag & 2
        /* CLASS */
        ) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, 'class', null, newProps.class, isSVG);
            }
          } // style
        // this flag is matched when the element has dynamic style bindings


        if (patchFlag & 4
        /* STYLE */
        ) {
            hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
          } // props
        // This flag is matched when the element has dynamic prop/attr bindings
        // other than class and style. The keys of dynamic prop/attrs are saved for
        // faster iteration.
        // Note dynamic keys like :[foo]="bar" will cause this optimization to
        // bail out and go through a full diff because we need to unset the old key


        if (patchFlag & 8
        /* PROPS */
        ) {
            // if the flag is present then dynamicProps must be non-null
            var propsToUpdate = n2.dynamicProps;

            for (var i = 0; i < propsToUpdate.length; i++) {
              var key = propsToUpdate[i];
              var prev = oldProps[key];
              var next = newProps[key];

              if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
      } // text
      // This flag is matched when the element has only dynamic text children.


      if (patchFlag & 1
      /* TEXT */
      ) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
    } else if (!optimized && dynamicChildren == null) {
      // unoptimized, full diff
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }

    var areChildrenSVG = isSVG && n2.type !== 'foreignObject';

    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);

      if ( true && parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      // full diff
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }

    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
      }, parentSuspense);
    }
  }; // The fast path for blocks.


  var patchBlockChildren = function patchBlockChildren(oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    for (var i = 0; i < newChildren.length; i++) {
      var oldVNode = oldChildren[i];
      var newVNode = newChildren[i]; // Determine the container (parent element) for the patch.

      var container = // oldVNode may be an errored async setup() component inside Suspense
      // which will not have a mounted element
      oldVNode.el && ( // - In the case of a Fragment, we need to provide the actual parent
      // of the Fragment itself so it can move its children.
      oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
      // which also requires the correct parent container
      !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
      oldVNode.shapeFlag & 6
      /* COMPONENT */
      || oldVNode.shapeFlag & 64
      /* TELEPORT */
      ) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
      // just pass the block element here to avoid a DOM parentNode call.
      fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };

  var patchProps = function patchProps(el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) {
    if (oldProps !== newProps) {
      for (var key in newProps) {
        // empty string is not valid prop
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;
        var next = newProps[key];
        var prev = oldProps[key];

        if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }

      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        for (var _key14 in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(_key14) && !(_key14 in newProps)) {
            hostPatchProp(el, _key14, oldProps[_key14], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
    }
  };

  var processFragment = function processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');
    var fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        fragmentSlotScopeIds = n2.slotScopeIds;

    if (dynamicChildren) {
      optimized = true;
    } // check if this is a slot fragment with :slotted scope ids


    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }

    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor); // a fragment can only have array children
      // since they are either generated by the compiler, or implicitly created
      // from arrays.

      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        // a stable fragment (template root or <template v-for>) doesn't need to
        // patch children order, but it may contain dynamicChildren.
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);

        if ( true && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if ( // #2080 if the stable fragment has a key, it's a <template v-for> that may
        //  get moved around. Make sure all root level vnodes inherit el.
        // #2134 or if it's a component root, it may also get moved around
        // as the component is being moved.
        n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true
          /* shallow */
          );
        }
      } else {
        // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };

  var processComponent = function processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    n2.slotScopeIds = slotScopeIds;

    if (n1 == null) {
      if (n2.shapeFlag & 512
      /* COMPONENT_KEPT_ALIVE */
      ) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };

  var mountComponent = function mountComponent(initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
    var instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);

    if ( true && instance.type.__hmrId) {
      registerHMR(instance);
    }

    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, "mount");
    } // inject renderer internals for keepAlive


    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    } // resolve props and slots for setup context


    {
      if (true) {
        startMeasure(instance, "init");
      }

      setupComponent(instance);

      if (true) {
        endMeasure(instance, "init");
      }
    } // setup() is async. This component relies on async logic to be resolved
    // before proceeding

    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect); // Give it a placeholder if this is not hydration
      // TODO handle self-defined fallback

      if (!initialVNode.el) {
        var placeholder = instance.subTree = createVNode(Comment$1);
        processCommentNode(null, placeholder, container, anchor);
      }

      return;
    }

    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);

    if (true) {
      popWarningContext();
      endMeasure(instance, "mount");
    }
  };

  var updateComponent = function updateComponent(n1, n2, optimized) {
    var instance = n2.component = n1.component;

    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        // async & still pending - just update props and slots
        // since the component's reactive effect for render isn't set-up yet
        if (true) {
          pushWarningContext(n2);
        }

        updateComponentPreRender(instance, n2, optimized);

        if (true) {
          popWarningContext();
        }

        return;
      } else {
        // normal update
        instance.next = n2; // in case the child component is also queued, remove it to avoid
        // double updating the same child component in the same flush.

        invalidateJob(instance.update); // instance.update is the reactive effect runner.

        instance.update();
      }
    } else {
      // no update needed. just copy over properties
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };

  var setupRenderEffect = function setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) {
    // create reactive effect for rendering
    instance.update = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(function componentEffect() {
      if (!instance.isMounted) {
        var vnodeHook;
        var _initialVNode = initialVNode,
            el = _initialVNode.el,
            props = _initialVNode.props;
        var bm = instance.bm,
            m = instance.m,
            parent = instance.parent; // beforeMount hook

        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
        } // onVnodeBeforeMount


        if (vnodeHook = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }

        if (el && hydrateNode) {
          // vnode has adopted host node - perform hydration instead of mount.
          var hydrateSubTree = function hydrateSubTree() {
            if (true) {
              startMeasure(instance, "render");
            }

            instance.subTree = renderComponentRoot(instance);

            if (true) {
              endMeasure(instance, "render");
            }

            if (true) {
              startMeasure(instance, "hydrate");
            }

            hydrateNode(el, instance.subTree, instance, parentSuspense, null);

            if (true) {
              endMeasure(instance, "hydrate");
            }
          };

          if (isAsyncWrapper(initialVNode)) {
            initialVNode.type.__asyncLoader().then( // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            function () {
              return !instance.isUnmounted && hydrateSubTree();
            });
          } else {
            hydrateSubTree();
          }
        } else {
          if (true) {
            startMeasure(instance, "render");
          }

          var subTree = instance.subTree = renderComponentRoot(instance);

          if (true) {
            endMeasure(instance, "render");
          }

          if (true) {
            startMeasure(instance, "patch");
          }

          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);

          if (true) {
            endMeasure(instance, "patch");
          }

          initialVNode.el = subTree.el;
        } // mounted hook


        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        } // onVnodeMounted


        if (vnodeHook = props && props.onVnodeMounted) {
          var scopedInitialVNode = initialVNode;
          queuePostRenderEffect(function () {
            return invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
          }, parentSuspense);
        } // activated hook for keep-alive roots.
        // #1742 activated hook must be accessed after first render
        // since the hook may be injected by a child keep-alive


        if (initialVNode.shapeFlag & 256
        /* COMPONENT_SHOULD_KEEP_ALIVE */
        ) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }

        instance.isMounted = true;

        if (true) {
          devtoolsComponentAdded(instance);
        } // #2458: deference mount-only object parameters to prevent memleaks


        initialVNode = container = anchor = null;
      } else {
        // updateComponent
        // This is triggered by mutation of component's own state (next: null)
        // OR parent calling processComponent (next: VNode)
        var next = instance.next,
            bu = instance.bu,
            u = instance.u,
            _parent = instance.parent,
            vnode = instance.vnode;
        var originNext = next;

        var _vnodeHook;

        if (true) {
          pushWarningContext(next || instance.vnode);
        }

        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        } // beforeUpdate hook


        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
        } // onVnodeBeforeUpdate


        if (_vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(_vnodeHook, _parent, next, vnode);
        } // render


        if (true) {
          startMeasure(instance, "render");
        }

        var nextTree = renderComponentRoot(instance);

        if (true) {
          endMeasure(instance, "render");
        }

        var prevTree = instance.subTree;
        instance.subTree = nextTree;

        if (true) {
          startMeasure(instance, "patch");
        }

        patch(prevTree, nextTree, // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree), instance, parentSuspense, isSVG);

        if (true) {
          endMeasure(instance, "patch");
        }

        next.el = nextTree.el;

        if (originNext === null) {
          // self-triggered update. In case of HOC, update parent component
          // vnode el. HOC is indicated by parent instance's subTree pointing
          // to child component's vnode
          updateHOCHostEl(instance, nextTree.el);
        } // updated hook


        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        } // onVnodeUpdated


        if (_vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(function () {
            return invokeVNodeHook(_vnodeHook, _parent, next, vnode);
          }, parentSuspense);
        }

        if (true) {
          devtoolsComponentUpdated(instance);
        }

        if (true) {
          popWarningContext();
        }
      }
    },  true ? createDevEffectOptions(instance) : 0);

    if (true) {
      // @ts-ignore
      instance.update.ownerInstance = instance;
    }
  };

  var updateComponentPreRender = function updateComponentPreRender(instance, nextVNode, optimized) {
    nextVNode.component = instance;
    var prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // props update may have triggered pre-flush watchers.
    // flush them before the render update.

    flushPreFlushCbs(undefined, instance.update);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  };

  var patchChildren = function patchChildren(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    var c1 = n1 && n1.children;
    var prevShapeFlag = n1 ? n1.shapeFlag : 0;
    var c2 = n2.children;
    var patchFlag = n2.patchFlag,
        shapeFlag = n2.shapeFlag; // fast path

    if (patchFlag > 0) {
      if (patchFlag & 128
      /* KEYED_FRAGMENT */
      ) {
          // this could be either fully-keyed or mixed (some keyed some not)
          // presence of patchFlag means children are guaranteed to be arrays
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) {
          // unkeyed
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
    } // children has 3 possibilities: text, array or no children.


    if (shapeFlag & 8
    /* TEXT_CHILDREN */
    ) {
        // text children fast path
        if (prevShapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }

        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
      if (prevShapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          // prev children was array
          if (shapeFlag & 16
          /* ARRAY_CHILDREN */
          ) {
              // two arrays, cannot assume anything, do full diff
              patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else {
            // no new children, just unmount old
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
        // prev children was text OR null
        // new children is array OR null
        if (prevShapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
            hostSetElementText(container, '');
          } // mount new if array


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      }
    }
  };

  var patchUnkeyedChildren = function patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    var oldLength = c1.length;
    var newLength = c2.length;
    var commonLength = Math.min(oldLength, newLength);
    var i;

    for (i = 0; i < commonLength; i++) {
      var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }

    if (oldLength > newLength) {
      // remove old
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      // mount new
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  }; // can be all-keyed or mixed


  var patchKeyedChildren = function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var i = 0;
    var l2 = c2.length;
    var e1 = c1.length - 1; // prev ending index

    var e2 = l2 - 1; // next ending index
    // 1. sync from start
    // (a b) c
    // (a b) d e

    while (i <= e1 && i <= e2) {
      var n1 = c1[i];
      var n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      i++;
    } // 2. sync from end
    // a (b c)
    // d e (b c)


    while (i <= e1 && i <= e2) {
      var _n2 = c1[e1];

      var _n3 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);

      if (isSameVNodeType(_n2, _n3)) {
        patch(_n2, _n3, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      e1--;
      e2--;
    } // 3. common sequence + mount
    // (a b)
    // (a b) c
    // i = 2, e1 = 1, e2 = 2
    // (a b)
    // c (a b)
    // i = 0, e1 = -1, e2 = 0


    if (i > e1) {
      if (i <= e2) {
        var nextPos = e2 + 1;
        var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;

        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } // 4. common sequence + unmount
    // (a b) c
    // (a b)
    // i = 2, e1 = 2, e2 = 1
    // a (b c)
    // (b c)
    // i = 0, e1 = 0, e2 = -1
    else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } // 5. unknown sequence
      // [i ... e1 + 1]: a b [c d e] f g
      // [i ... e2 + 1]: a b [e d c h] f g
      // i = 2, e1 = 4, e2 = 5
      else {
          var s1 = i; // prev starting index

          var s2 = i; // next starting index
          // 5.1 build key:index map for newChildren

          var keyToNewIndexMap = new Map();

          for (i = s2; i <= e2; i++) {
            var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

            if (nextChild.key != null) {
              if ( true && keyToNewIndexMap.has(nextChild.key)) {
                warn("Duplicate keys found during update:", JSON.stringify(nextChild.key), "Make sure keys are unique.");
              }

              keyToNewIndexMap.set(nextChild.key, i);
            }
          } // 5.2 loop through old children left to be patched and try to patch
          // matching nodes & remove nodes that are no longer present


          var j;
          var patched = 0;
          var toBePatched = e2 - s2 + 1;
          var moved = false; // used to track whether any node has moved

          var maxNewIndexSoFar = 0; // works as Map<newIndex, oldIndex>
          // Note that oldIndex is offset by +1
          // and oldIndex = 0 is a special value indicating the new node has
          // no corresponding old node.
          // used for determining longest stable subsequence

          var newIndexToOldIndexMap = new Array(toBePatched);

          for (i = 0; i < toBePatched; i++) {
            newIndexToOldIndexMap[i] = 0;
          }

          for (i = s1; i <= e1; i++) {
            var prevChild = c1[i];

            if (patched >= toBePatched) {
              // all new children have been patched so this can only be a removal
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }

            var newIndex = void 0;

            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              // key-less node, try to locate a key-less node of the same type
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }

            if (newIndex === undefined) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;

              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }

              patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              patched++;
            }
          } // 5.3 move and mount
          // generate longest stable subsequence only when nodes have moved


          var increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1; // looping backwards so that we can use last patched node as anchor

          for (i = toBePatched - 1; i >= 0; i--) {
            var nextIndex = s2 + i;
            var _nextChild = c2[nextIndex];

            var _anchor2 = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;

            if (newIndexToOldIndexMap[i] === 0) {
              // mount new
              patch(null, _nextChild, container, _anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (moved) {
              // move if:
              // There is no stable subsequence (e.g. a reverse)
              // OR current node is not among the stable sequence
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(_nextChild, container, _anchor2, 2
                /* REORDER */
                );
              } else {
                j--;
              }
            }
          }
        }
  };

  var move = function move(vnode, container, anchor, moveType) {
    var parentSuspense = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var el = vnode.el,
        type = vnode.type,
        transition = vnode.transition,
        children = vnode.children,
        shapeFlag = vnode.shapeFlag;

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }

    if (shapeFlag & 128
    /* SUSPENSE */
    ) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
        type.move(vnode, container, anchor, internals);
        return;
      }

    if (type === Fragment) {
      hostInsert(el, container, anchor);

      for (var i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }

      hostInsert(vnode.anchor, container, anchor);
      return;
    }

    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    } // single nodes


    var needTransition = moveType !== 2
    /* REORDER */
    && shapeFlag & 1
    /* ELEMENT */
    && transition;

    if (needTransition) {
      if (moveType === 0
      /* ENTER */
      ) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(function () {
            return transition.enter(el);
          }, parentSuspense);
        } else {
        var leave = transition.leave,
            delayLeave = transition.delayLeave,
            afterLeave = transition.afterLeave;

        var _remove = function _remove() {
          return hostInsert(el, container, anchor);
        };

        var performLeave = function performLeave() {
          leave(el, function () {
            _remove();

            afterLeave && afterLeave();
          });
        };

        if (delayLeave) {
          delayLeave(el, _remove, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };

  var unmount = function unmount(vnode, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var type = vnode.type,
        props = vnode.props,
        ref = vnode.ref,
        children = vnode.children,
        dynamicChildren = vnode.dynamicChildren,
        shapeFlag = vnode.shapeFlag,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs; // unset ref

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }

    if (shapeFlag & 256
    /* COMPONENT_SHOULD_KEEP_ALIVE */
    ) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }

    var shouldInvokeDirs = shapeFlag & 1
    /* ELEMENT */
    && dirs;
    var vnodeHook;

    if (vnodeHook = props && props.onVnodeBeforeUnmount) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
      if (shapeFlag & 128
      /* SUSPENSE */
      ) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }

      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
      }

      if (shapeFlag & 64
      /* TELEPORT */
      ) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && ( // #1153: fast path should not be taken for non-stable (v-for) fragments
      type !== Fragment || patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      )) {
        // fast path for block nodes: only need to unmount dynamic children.
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && (patchFlag & 128
      /* KEYED_FRAGMENT */
      || patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) || !optimized && shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        unmountChildren(children, parentComponent, parentSuspense);
      }

      if (doRemove) {
        remove(vnode);
      }
    }

    if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
      }, parentSuspense);
    }
  };

  var remove = function remove(vnode) {
    var type = vnode.type,
        el = vnode.el,
        anchor = vnode.anchor,
        transition = vnode.transition;

    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }

    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }

    var performRemove = function performRemove() {
      hostRemove(el);

      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };

    if (vnode.shapeFlag & 1
    /* ELEMENT */
    && transition && !transition.persisted) {
      var leave = transition.leave,
          delayLeave = transition.delayLeave;

      var performLeave = function performLeave() {
        return leave(el, performRemove);
      };

      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };

  var removeFragment = function removeFragment(cur, end) {
    // For fragments, directly remove all contained DOM nodes.
    // (fragment child nodes cannot have transition)
    var next;

    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }

    hostRemove(end);
  };

  var unmountComponent = function unmountComponent(instance, parentSuspense, doRemove) {
    if ( true && instance.type.__hmrId) {
      unregisterHMR(instance);
    }

    var bum = instance.bum,
        effects = instance.effects,
        update = instance.update,
        subTree = instance.subTree,
        um = instance.um; // beforeUnmount hook

    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
    }

    if (effects) {
      for (var i = 0; i < effects.length; i++) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(effects[i]);
      }
    } // update may be null if a component is unmounted before its async
    // setup has resolved.


    if (update) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(update);
      unmount(subTree, instance, parentSuspense, doRemove);
    } // unmounted hook


    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }

    queuePostRenderEffect(function () {
      instance.isUnmounted = true;
    }, parentSuspense); // A component with async dep inside a pending suspense is unmounted before
    // its async dep resolves. This should remove the dep from the suspense, and
    // cause the suspense to resolve immediately if that was the last dep.

    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;

      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }

    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };

  var unmountChildren = function unmountChildren(children, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var start = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    for (var i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };

  var getNextHostNode = function getNextHostNode(vnode) {
    if (vnode.shapeFlag & 6
    /* COMPONENT */
    ) {
        return getNextHostNode(vnode.component.subTree);
      }

    if (vnode.shapeFlag & 128
    /* SUSPENSE */
    ) {
        return vnode.suspense.next();
      }

    return hostNextSibling(vnode.anchor || vnode.el);
  };

  var render = function render(vnode, container, isSVG) {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }

    flushPostFlushCbs();
    container._vnode = vnode;
  };

  var internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  var hydrate;
  var hydrateNode;

  if (createHydrationFns) {
    var _createHydrationFns = createHydrationFns(internals);

    var _createHydrationFns2 = _slicedToArray(_createHydrationFns, 2);

    hydrate = _createHydrationFns2[0];
    hydrateNode = _createHydrationFns2[1];
  }

  return {
    render: render,
    hydrate: hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}

function invokeVNodeHook(hook, instance, vnode) {
  var prevVNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  callWithAsyncErrorHandling(hook, instance, 7
  /* VNODE_HOOK */
  , [vnode, prevVNode]);
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always moved so that need inherit el form previous nodes
 * to ensure correct moved position.
 */


function traverseStaticChildren(n1, n2) {
  var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var ch1 = n1.children;
  var ch2 = n2.children;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
    for (var i = 0; i < ch1.length; i++) {
      // this is only called in the optimized path so array children are
      // guaranteed to be vnodes
      var c1 = ch1[i];
      var c2 = ch2[i];

      if (c2.shapeFlag & 1
      /* ELEMENT */
      && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32
        /* HYDRATE_EVENTS */
        ) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }

        if (!shallow) traverseStaticChildren(c1, c2);
      } // also inherit for comment nodes, but not placeholders (e.g. v-if which
      // would have received .el during block patch)


      if ( true && c2.type === Comment$1 && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
} // https://en.wikipedia.org/wiki/Longest_increasing_subsequence


function getSequence(arr) {
  var p = arr.slice();
  var result = [0];
  var i, j, u, v, c;
  var len = arr.length;

  for (i = 0; i < len; i++) {
    var arrI = arr[i];

    if (arrI !== 0) {
      j = result[result.length - 1];

      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }

      u = 0;
      v = result.length - 1;

      while (u < v) {
        c = (u + v) / 2 | 0;

        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }

      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }

        result[u] = i;
      }
    }
  }

  u = result.length;
  v = result[u - 1];

  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }

  return result;
}

var isTeleport = function isTeleport(type) {
  return type.__isTeleport;
};

var isTeleportDisabled = function isTeleportDisabled(props) {
  return props && (props.disabled || props.disabled === '');
};

var isTargetSVG = function isTargetSVG(target) {
  return typeof SVGElement !== 'undefined' && target instanceof SVGElement;
};

var resolveTarget = function resolveTarget(props, select) {
  var targetSelector = props && props.to;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
    if (!select) {
       true && warn("Current renderer does not support string target for Teleports. " + "(missing querySelector renderer option)");
      return null;
    } else {
      var target = select(targetSelector);

      if (!target) {
         true && warn("Failed to locate Teleport target with selector \"".concat(targetSelector, "\". ") + "Note the target element must exist before the component is mounted - " + "i.e. the target cannot be rendered by the component itself, and " + "ideally should be outside of the entire Vue component tree.");
      }

      return target;
    }
  } else {
    if ( true && !targetSelector && !isTeleportDisabled(props)) {
      warn("Invalid Teleport target: ".concat(targetSelector));
    }

    return targetSelector;
  }
};

var TeleportImpl = {
  __isTeleport: true,
  process: function (_process) {
    function process(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {
      return _process.apply(this, arguments);
    }

    process.toString = function () {
      return _process.toString();
    };

    return process;
  }(function (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    var mountChildren = internals.mc,
        patchChildren = internals.pc,
        patchBlockChildren = internals.pbc,
        _internals$o = internals.o,
        insert = _internals$o.insert,
        querySelector = _internals$o.querySelector,
        createText = _internals$o.createText,
        createComment = _internals$o.createComment;
    var disabled = isTeleportDisabled(n2.props);
    var shapeFlag = n2.shapeFlag,
        children = n2.children,
        dynamicChildren = n2.dynamicChildren; // #3302
    // HMR updated, force full diff

    if ( true && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }

    if (n1 == null) {
      // insert anchors in the main view
      var placeholder = n2.el =  true ? createComment('teleport start') : 0;
      var mainAnchor = n2.anchor =  true ? createComment('teleport end') : 0;
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      var target = n2.target = resolveTarget(n2.props, querySelector);
      var targetAnchor = n2.targetAnchor = createText('');

      if (target) {
        insert(targetAnchor, target); // #2652 we could be teleporting from a non-SVG tree into an SVG tree

        isSVG = isSVG || isTargetSVG(target);
      } else if ( true && !disabled) {
        warn('Invalid Teleport target on mount:', target, "(".concat(_typeof(target), ")"));
      }

      var mount = function mount(container, anchor) {
        // Teleport *always* has Array children. This is enforced in both the
        // compiler and vnode children normalization.
        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      };

      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      // update content
      n2.el = n1.el;

      var _mainAnchor = n2.anchor = n1.anchor;

      var _target = n2.target = n1.target;

      var _targetAnchor = n2.targetAnchor = n1.targetAnchor;

      var wasDisabled = isTeleportDisabled(n1.props);
      var currentContainer = wasDisabled ? container : _target;
      var currentAnchor = wasDisabled ? _mainAnchor : _targetAnchor;
      isSVG = isSVG || isTargetSVG(_target);

      if (dynamicChildren) {
        // fast path when the teleport happens to be a block root
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds); // even in block tree mode we need to make sure all root-level nodes
        // in the teleport inherit previous DOM references so that they can
        // be moved in future patches.

        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }

      if (disabled) {
        if (!wasDisabled) {
          // enabled -> disabled
          // move into main container
          moveTeleport(n2, container, _mainAnchor, internals, 1
          /* TOGGLE */
          );
        }
      } else {
        // target changed
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          var nextTarget = n2.target = resolveTarget(n2.props, querySelector);

          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0
            /* TARGET_CHANGE */
            );
          } else if (true) {
            warn('Invalid Teleport target on update:', _target, "(".concat(_typeof(_target), ")"));
          }
        } else if (wasDisabled) {
          // disabled -> enabled
          // move into teleport target
          moveTeleport(n2, _target, _targetAnchor, internals, 1
          /* TOGGLE */
          );
        }
      }
    }
  }),
  remove: function remove(vnode, parentComponent, parentSuspense, optimized, _ref14, doRemove) {
    var unmount = _ref14.um,
        hostRemove = _ref14.o.remove;
    var shapeFlag = vnode.shapeFlag,
        children = vnode.children,
        anchor = vnode.anchor,
        targetAnchor = vnode.targetAnchor,
        target = vnode.target,
        props = vnode.props;

    if (target) {
      hostRemove(targetAnchor);
    } // an unmounted teleport should always remove its children if not disabled


    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);

      if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
          }
        }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};

function moveTeleport(vnode, container, parentAnchor, _ref15)
/* REORDER */
{
  var insert = _ref15.o.insert,
      move = _ref15.m;
  var moveType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;

  // move target anchor if this is a target change.
  if (moveType === 0
  /* TARGET_CHANGE */
  ) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }

  var el = vnode.el,
      anchor = vnode.anchor,
      shapeFlag = vnode.shapeFlag,
      children = vnode.children,
      props = vnode.props;
  var isReorder = moveType === 2
  /* REORDER */
  ; // move main view anchor if this is a re-order.

  if (isReorder) {
    insert(el, container, parentAnchor);
  } // if this is a re-order and teleport is enabled (content is in target)
  // do not move children. So the opposite is: only move children if this
  // is not a reorder, or the teleport is disabled


  if (!isReorder || isTeleportDisabled(props)) {
    // Teleport has either Array children or no children.
    if (shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
        for (var i = 0; i < children.length; i++) {
          move(children[i], container, parentAnchor, 2
          /* REORDER */
          );
        }
      }
  } // move main view anchor if this is a re-order.


  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}

function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, _ref16, hydrateChildren) {
  var _ref16$o = _ref16.o,
      nextSibling = _ref16$o.nextSibling,
      parentNode = _ref16$o.parentNode,
      querySelector = _ref16$o.querySelector;
  var target = vnode.target = resolveTarget(vnode.props, querySelector);

  if (target) {
    // if multiple teleports rendered to the same target element, we need to
    // pick up from where the last teleport finished instead of the first node
    var targetNode = target._lpa || target.firstChild;

    if (vnode.shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
      }
  }

  return vnode.anchor && nextSibling(vnode.anchor);
} // Force-casted public typing for h and TSX props inference


var Teleport = TeleportImpl;
var COMPONENTS = 'components';
var DIRECTIVES = 'directives';
/**
 * @private
 */

function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}

var NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */

function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    // invalid types will fallthrough to createVNode and raise warning
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
/**
 * @private
 */


function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
} // implementation


function resolveAsset(type, name) {
  var warnMissing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var maybeSelfReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var instance = currentRenderingInstance || currentInstance;

  if (instance) {
    var Component = instance.type; // explicit self name has highest priority

    if (type === COMPONENTS) {
      var selfName = getComponentName(Component);

      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
        return Component;
      }
    }

    var res = // local registration
    // check instance[type] first which is resolved for options API
    resolve(instance[type] || Component[type], name) || // global registration
    resolve(instance.appContext[type], name);

    if (!res && maybeSelfReference) {
      // fallback to implicit self-reference
      return Component;
    }

    if ( true && warnMissing && !res) {
      warn("Failed to resolve ".concat(type.slice(0, -1), ": ").concat(name));
    }

    return res;
  } else if (true) {
    warn("resolve".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1)), " ") + "can only be used in render() or setup().");
  }
}

function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);
}

var Fragment = Symbol( true ? 'Fragment' : 0);
var Text = Symbol( true ? 'Text' : 0);
var Comment$1 = Symbol( true ? 'Comment' : 0);
var Static = Symbol( true ? 'Static' : 0); // Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).

var blockStack = [];
var currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */

function openBlock() {
  var disableTracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  blockStack.push(currentBlock = disableTracking ? null : []);
}

function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
} // Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)


var isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */

function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */


function createBlock(type, props, children, patchFlag, dynamicProps) {
  var vnode = createVNode(type, props, children, patchFlag, dynamicProps, true
  /* isBlock: prevent a block from tracking itself */
  ); // save current block children on the block vnode

  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null; // close block

  closeBlock(); // a block is always going to be patched, so track it as a child of its
  // parent block

  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }

  return vnode;
}

function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}

function isSameVNodeType(n1, n2) {
  if ( true && n2.shapeFlag & 6
  /* COMPONENT */
  && hmrDirtyComponents.has(n2.type)) {
    // HMR only: if the component has been hot-updated, force a reload.
    return false;
  }

  return n1.type === n2.type && n1.key === n2.key;
}

var vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */

function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}

var createVNodeWithArgsTransform = function createVNodeWithArgsTransform() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key15 = 0; _key15 < _len7; _key15++) {
    args[_key15] = arguments[_key15];
  }

  return _createVNode.apply(void 0, _toConsumableArray(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));
};

var InternalObjectKey = "__vInternal";

var normalizeKey = function normalizeKey(_ref17) {
  var key = _ref17.key;
  return key != null ? key : null;
};

var normalizeRef = function normalizeRef(_ref18) {
  var ref = _ref18.ref;
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? {
    i: currentRenderingInstance,
    r: ref
  } : ref : null;
};

var createVNode =  true ? createVNodeWithArgsTransform : 0;

function _createVNode(type) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var isBlockNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if ( true && !type) {
      warn("Invalid vnode type when creating vnode: ".concat(type, "."));
    }

    type = Comment$1;
  }

  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    var cloned = cloneVNode(type, props, true
    /* mergeRef: true */
    );

    if (children) {
      normalizeChildren(cloned, children);
    }

    return cloned;
  } // class component normalization.


  if (isClassComponent(type)) {
    type = type.__vccOpts;
  } // class & style normalization.


  if (props) {
    // for reactive or proxy objects, we need to clone it to enable mutation.
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props) {
      props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props);
    }

    var _props = props,
        klass = _props.class,
        style = _props.style;

    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
      // reactive state objects need to be cloned since they are likely to be
      // mutated
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
      }

      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
    }
  } // encode the vnode type information into a bitmap


  var shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1
  /* ELEMENT */
  : isSuspense(type) ? 128
  /* SUSPENSE */
  : isTeleport(type) ? 64
  /* TELEPORT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4
  /* STATEFUL_COMPONENT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2
  /* FUNCTIONAL_COMPONENT */
  : 0;

  if ( true && shapeFlag & 4
  /* STATEFUL_COMPONENT */
  && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
    warn("Vue received a Component which was made a reactive object. This can " + "lead to unnecessary performance overhead, and should be avoided by " + "marking the component with `markRaw` or using `shallowRef` " + "instead of `ref`.", "\nComponent that was made reactive: ", type);
  }

  var vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type,
    props: props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: null,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: shapeFlag,
    patchFlag: patchFlag,
    dynamicProps: dynamicProps,
    dynamicChildren: null,
    appContext: null
  }; // validate key

  if ( true && vnode.key !== vnode.key) {
    warn("VNode created with invalid key (NaN). VNode type:", vnode.type);
  }

  normalizeChildren(vnode, children); // normalize suspense children

  if (shapeFlag & 128
  /* SUSPENSE */
  ) {
      type.normalize(vnode);
    }

  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && ( // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  patchFlag > 0 || shapeFlag & 6
  /* COMPONENT */
  ) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  patchFlag !== 32
  /* HYDRATE_EVENTS */
  ) {
      currentBlock.push(vnode);
    }

  return vnode;
}

function cloneVNode(vnode, extraProps) {
  var mergeRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // This is intentionally NOT using spread or extend to avoid the runtime
  // key enumeration cost.
  var props = vnode.props,
      ref = vnode.ref,
      patchFlag = vnode.patchFlag,
      children = vnode.children;
  var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  var cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
    // if the vnode itself already has a ref, cloneVNode will need to merge
    // the refs so the single vnode can be set on multiple refs
    mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  true && patchFlag === -1
    /* HOISTED */
    && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: perserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node
    ? 16
    /* FULL_PROPS */
    : patchFlag | 16
    /* FULL_PROPS */
    : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */


function deepCloneVNode(vnode) {
  var cloned = cloneVNode(vnode);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }

  return cloned;
}
/**
 * @private
 */


function createTextVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';
  var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return createVNode(Text, null, text, flag);
}
/**
 * @private
 */


function createStaticVNode(content, numberOfNodes) {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  var vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
/**
 * @private
 */


function createCommentVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var asBlock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return asBlock ? (openBlock(), createBlock(Comment$1, null, text)) : createVNode(Comment$1, null, text);
}

function normalizeVNode(child) {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment$1);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
    // fragment
    return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
  } else if (_typeof(child) === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    return cloneIfMounted(child);
  } else {
    // strings and numbers
    return createVNode(Text, null, String(child));
  }
} // optimized normalization for template-compiled render fns


function cloneIfMounted(child) {
  return child.el === null ? child : cloneVNode(child);
}

function normalizeChildren(vnode, children) {
  var type = 0;
  var shapeFlag = vnode.shapeFlag;

  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
    type = 16
    /* ARRAY_CHILDREN */
    ;
  } else if (_typeof(children) === 'object') {
    if (shapeFlag & 1
    /* ELEMENT */
    || shapeFlag & 64
    /* TELEPORT */
    ) {
        // Normalize slot to plain children for plain element and Teleport
        var slot = children.default;

        if (slot) {
          // _c marker is added by withCtx() indicating this is a compiled slot
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }

        return;
      } else {
      type = 32
      /* SLOTS_CHILDREN */
      ;
      var slotFlag = children._;

      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3
      /* FORWARDED */
      && currentRenderingInstance) {
        // a child component receives forwarded slots from the parent.
        // its slot type is determined by its parent's slot type.
        if (currentRenderingInstance.slots._ === 1
        /* STABLE */
        ) {
            children._ = 1
            /* STABLE */
            ;
          } else {
          children._ = 2
          /* DYNAMIC */
          ;
          vnode.patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
    children = {
      default: children,
      _ctx: currentRenderingInstance
    };
    type = 32
    /* SLOTS_CHILDREN */
    ;
  } else {
    children = String(children); // force teleport children to array so it can be moved around

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
        type = 16
        /* ARRAY_CHILDREN */
        ;
        children = [createTextVNode(children)];
      } else {
      type = 8
      /* TEXT_CHILDREN */
      ;
    }
  }

  vnode.children = children;
  vnode.shapeFlag |= type;
}

function mergeProps() {
  var ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, arguments.length <= 0 ? undefined : arguments[0]);

  for (var i = 1; i < arguments.length; i++) {
    var toMerge = i < 0 || arguments.length <= i ? undefined : arguments[i];

    for (var key in toMerge) {
      if (key === 'class') {
        if (ret.class !== toMerge.class) {
          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
        }
      } else if (key === 'style') {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        var existing = ret[key];
        var incoming = toMerge[key];

        if (existing !== incoming) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== '') {
        ret[key] = toMerge[key];
      }
    }
  }

  return ret;
}
/**
 * Actual implementation
 */


function renderList(source, renderItem) {
  var ret;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
    ret = new Array(source.length);

    for (var i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i);
    }
  } else if (typeof source === 'number') {
    if ( true && !Number.isInteger(source)) {
      warn("The v-for range expect an integer value but got ".concat(source, "."));
      return [];
    }

    ret = new Array(source);

    for (var _i3 = 0; _i3 < source; _i3++) {
      ret[_i3] = renderItem(_i3 + 1, _i3);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, renderItem);
    } else {
      var keys = Object.keys(source);
      ret = new Array(keys.length);

      for (var _i4 = 0, _l = keys.length; _i4 < _l; _i4++) {
        var key = keys[_i4];
        ret[_i4] = renderItem(source[key], key, _i4);
      }
    }
  } else {
    ret = [];
  }

  return ret;
}
/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */


function createSlots(slots, dynamicSlots) {
  for (var i = 0; i < dynamicSlots.length; i++) {
    var slot = dynamicSlots[i]; // array of dynamic slot generated by <template v-for="..." #[...]>

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
      for (var j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      // conditional single slot generated by <template v-if="..." #foo>
      slots[slot.name] = slot.fn;
    }
  }

  return slots;
}
/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */


function renderSlot(slots, name) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback = arguments.length > 3 ? arguments[3] : undefined;
  var noSlotted = arguments.length > 4 ? arguments[4] : undefined;
  var slot = slots[name];

  if ( true && slot && slot.length > 1) {
    warn("SSR-optimized slot function detected in a non-SSR-optimized render " + "function. You need to mark this component with $dynamic-slots in the " + "parent template.");

    slot = function slot() {
      return [];
    };
  } // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.


  if (slot && slot._c) {
    slot._d = false;
  }

  openBlock();
  var validSlotContent = slot && ensureValidVNode(slot(props));
  var rendered = createBlock(Fragment, {
    key: props.key || "_".concat(name)
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1
  /* STABLE */
  ? 64
  /* STABLE_FRAGMENT */
  : -2
  /* BAIL */
  );

  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + '-s'];
  }

  if (slot && slot._c) {
    slot._d = true;
  }

  return rendered;
}

function ensureValidVNode(vnodes) {
  return vnodes.some(function (child) {
    if (!isVNode(child)) return true;
    if (child.type === Comment$1) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? vnodes : null;
}
/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */


function toHandlers(obj) {
  var ret = {};

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
    warn("v-on with no argument expects an object value.");
    return ret;
  }

  for (var key in obj) {
    ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
  }

  return ret;
}
/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */


var getPublicInstance = function getPublicInstance(i) {
  if (!i) return null;
  if (isStatefulComponent(i)) return i.exposed ? i.exposed : i.proxy;
  return getPublicInstance(i.parent);
};

var publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
  $: function $(i) {
    return i;
  },
  $el: function $el(i) {
    return i.vnode.el;
  },
  $data: function $data(i) {
    return i.data;
  },
  $props: function $props(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0;
  },
  $attrs: function $attrs(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0;
  },
  $slots: function $slots(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0;
  },
  $refs: function $refs(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0;
  },
  $parent: function $parent(i) {
    return getPublicInstance(i.parent);
  },
  $root: function $root(i) {
    return getPublicInstance(i.root);
  },
  $emit: function $emit(i) {
    return i.emit;
  },
  $options: function $options(i) {
    return  true ? resolveMergedOptions(i) : 0;
  },
  $forceUpdate: function $forceUpdate(i) {
    return function () {
      return queueJob(i.update);
    };
  },
  $nextTick: function $nextTick(i) {
    return nextTick.bind(i.proxy);
  },
  $watch: function $watch(i) {
    return  true ? instanceWatch.bind(i) : 0;
  }
});
var PublicInstanceProxyHandlers = {
  get: function get(_ref19, key) {
    var instance = _ref19._;
    var ctx = instance.ctx,
        setupState = instance.setupState,
        data = instance.data,
        props = instance.props,
        accessCache = instance.accessCache,
        type = instance.type,
        appContext = instance.appContext; // let @vue/reactivity know it should never observe Vue public instances.

    if (key === "__v_skip"
    /* SKIP */
    ) {
        return true;
      } // for internal formatters to know that this is a Vue instance


    if ( true && key === '__isVue') {
      return true;
    } // data / props / ctx
    // This getter gets called for every property access on the render context
    // during render and is a major hotspot. The most expensive part of this
    // is the multiple hasOwn() calls. It's much faster to do a simple property
    // access on a plain object, so we use an accessCache object (with null
    // prototype) to memoize what access type a key corresponds to.


    var normalizedProps;

    if (key[0] !== '$') {
      var n = accessCache[key];

      if (n !== undefined) {
        switch (n) {
          case 0
          /* SETUP */
          :
            return setupState[key];

          case 1
          /* DATA */
          :
            return data[key];

          case 3
          /* CONTEXT */
          :
            return ctx[key];

          case 2
          /* PROPS */
          :
            return props[key];
          // default: just fallthrough
        }
      } else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
        accessCache[key] = 0
        /* SETUP */
        ;
        return setupState[key];
      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        accessCache[key] = 1
        /* DATA */
        ;
        return data[key];
      } else if ( // only cache other properties when instance has declared (thus stable)
      // props
      (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
        accessCache[key] = 2
        /* PROPS */
        ;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
        accessCache[key] = 3
        /* CONTEXT */
        ;
        return ctx[key];
      } else if ( false || shouldCacheAccess) {
        accessCache[key] = 4
        /* OTHER */
        ;
      }
    }

    var publicGetter = publicPropertiesMap[key];
    var cssModule, globalProperties; // public $xxx properties

    if (publicGetter) {
      if (key === '$attrs') {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get"
        /* GET */
        , key);
         true && markAttrsAccessed();
      }

      return publicGetter(instance);
    } else if ( // css module (injected by vue-loader)
    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
      // user may set custom properties to `this` that start with `$`
      accessCache[key] = 3
      /* CONTEXT */
      ;
      return ctx[key];
    } else if ( // global properties
    globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf('__v') !== 0)) {
      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (key[0] === '$' || key[0] === '_') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        warn("Property ".concat(JSON.stringify(key), " must be accessed via $data because it starts with a reserved ") + "character (\"$\" or \"_\") and is not proxied on the render context.");
      } else if (instance === currentRenderingInstance) {
        warn("Property ".concat(JSON.stringify(key), " was accessed during render ") + "but is not defined on instance.");
      }
    }
  },
  set: function set(_ref20, key, value) {
    var instance = _ref20._;
    var data = instance.data,
        setupState = instance.setupState,
        ctx = instance.ctx;

    if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      setupState[key] = value;
    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
      data[key] = value;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
       true && warn("Attempting to mutate prop \"".concat(key, "\". Props are readonly."), instance);
      return false;
    }

    if (key[0] === '$' && key.slice(1) in instance) {
       true && warn("Attempting to mutate public property \"".concat(key, "\". ") + "Properties starting with $ are reserved and readonly.", instance);
      return false;
    } else {
      if ( true && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value: value
        });
      } else {
        ctx[key] = value;
      }
    }

    return true;
  },
  has: function has(_ref21, key) {
    var _ref21$_ = _ref21._,
        data = _ref21$_.data,
        setupState = _ref21$_.setupState,
        accessCache = _ref21$_.accessCache,
        ctx = _ref21$_.ctx,
        appContext = _ref21$_.appContext,
        propsOptions = _ref21$_.propsOptions;
    var normalizedProps;
    return accessCache[key] !== undefined || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key);
  }
};

if (true) {
  PublicInstanceProxyHandlers.ownKeys = function (target) {
    warn("Avoid app logic that relies on enumerating keys on a component instance. " + "The keys will be empty in production mode to avoid performance overhead.");
    return Reflect.ownKeys(target);
  };
}

var RuntimeCompiledPublicInstanceProxyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
  get: function get(target, key) {
    // fast path for unscopables when using `with` block
    if (key === Symbol.unscopables) {
      return;
    }

    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has: function has(_, key) {
    var has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);

    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {
      warn("Property ".concat(JSON.stringify(key), " should not start with _ which is a reserved prefix for Vue internals."));
    }

    return has;
  }
}); // In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.

function createRenderContext(instance) {
  var target = {}; // expose internal instance for proxy handlers

  Object.defineProperty(target, "_", {
    configurable: true,
    enumerable: false,
    get: function get() {
      return instance;
    }
  }); // expose public properties

  Object.keys(publicPropertiesMap).forEach(function (key) {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: function get() {
        return publicPropertiesMap[key](instance);
      },
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
  return target;
} // dev only


function exposePropsOnRenderContext(instance) {
  var ctx = instance.ctx,
      _instance$propsOption6 = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption6[0];

  if (propsOptions) {
    Object.keys(propsOptions).forEach(function (key) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return instance.props[key];
        },
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    });
  }
} // dev only


function exposeSetupStateOnRenderContext(instance) {
  var ctx = instance.ctx,
      setupState = instance.setupState;
  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(function (key) {
    if (key[0] === '$' || key[0] === '_') {
      warn("setup() return property ".concat(JSON.stringify(key), " should not start with \"$\" or \"_\" ") + "which are reserved prefixes for Vue internals.");
      return;
    }

    Object.defineProperty(ctx, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return setupState[key];
      },
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
}

var emptyAppContext = createAppContext();
var uid$1 = 0;

function createComponentInstance(vnode, parent, suspense) {
  var type = vnode.type; // inherit parent app context - or - if root, adopt from root vnode

  var appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  var instance = {
    uid: uid$1++,
    vnode: vnode,
    type: type,
    parent: parent,
    appContext: appContext,
    root: null,
    next: null,
    subTree: null,
    update: null,
    render: null,
    proxy: null,
    exposed: null,
    withProxy: null,
    effects: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resovled assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense: suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };

  if (true) {
    instance.ctx = createRenderContext(instance);
  } else {}

  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  return instance;
}

var currentInstance = null;

var getCurrentInstance = function getCurrentInstance() {
  return currentInstance || currentRenderingInstance;
};

var setCurrentInstance = function setCurrentInstance(instance) {
  currentInstance = instance;
};

var isBuiltInTag = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');

function validateComponentName(name, config) {
  var appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;

  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component id: ' + name);
  }
}

function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ;
}

var isInSSRComponentSetup = false;

function setupComponent(instance) {
  var isSSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  isInSSRComponentSetup = isSSR;
  var _instance$vnode = instance.vnode,
      props = _instance$vnode.props,
      children = _instance$vnode.children;
  var isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  var setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;
  isInSSRComponentSetup = false;
  return setupResult;
}

function setupStatefulComponent(instance, isSSR) {
  var Component = instance.type;

  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }

    if (Component.components) {
      var names = Object.keys(Component.components);

      for (var i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }

    if (Component.directives) {
      var _names = Object.keys(Component.directives);

      for (var _i5 = 0; _i5 < _names.length; _i5++) {
        validateDirectiveName(_names[_i5]);
      }
    }

    if (Component.compilerOptions && isRuntimeOnly()) {
      warn("\"compilerOptions\" is only supported when using a build of Vue that " + "includes the runtime compiler. Since you are using a runtime-only " + "build, the options should be passed via your build tool config instead.");
    }
  } // 0. create render proxy property access cache


  instance.accessCache = Object.create(null); // 1. create public instance / render proxy
  // also mark it raw so it's never observed

  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);

  if (true) {
    exposePropsOnRenderContext(instance);
  } // 2. call setup()


  var setup = Component.setup;

  if (setup) {
    var setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    currentInstance = instance;
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    var setupResult = callWithErrorHandling(setup, instance, 0
    /* SETUP_FUNCTION */
    , [ true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    currentInstance = null;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
      if (isSSR) {
        // return the promise so server-renderer can wait on it
        return setupResult.then(function (resolvedResult) {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch(function (e) {
          handleError(e, instance, 0
          /* SETUP_FUNCTION */
          );
        });
      } else {
        // async setup returned Promise.
        // bail here and wait for re-entry.
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}

function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
    // setup returned an inline render function
    {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
    if ( true && isVNode(setupResult)) {
      warn("setup() should not return VNodes directly - " + "return a render function instead.");
    } // setup returned bindings.
    // assuming a render function compiled from template is present.


    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }

    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);

    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if ( true && setupResult !== undefined) {
    warn("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : _typeof(setupResult)));
  }

  finishComponentSetup(instance, isSSR);
}

var compile; // dev only

var isRuntimeOnly = function isRuntimeOnly() {
  return !compile;
};
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */


function registerRuntimeCompiler(_compile) {
  compile = _compile;
}

function finishComponentSetup(instance, isSSR, skipOptions) {
  var Component = instance.type; // template / render function normalization

  if (!instance.render) {
    // could be set from setup()
    if (compile && !Component.render) {
      var template = Component.template;

      if (template) {
        if (true) {
          startMeasure(instance, "compile");
        }

        var _instance$appContext$ = instance.appContext.config,
            isCustomElement = _instance$appContext$.isCustomElement,
            compilerOptions = _instance$appContext$.compilerOptions;
        var delimiters = Component.delimiters,
            componentCompilerOptions = Component.compilerOptions;
        var finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
          isCustomElement: isCustomElement,
          delimiters: delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);

        if (true) {
          endMeasure(instance, "compile");
        }
      }
    }

    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP; // for runtime-compiled render functions using `with` blocks, the render
    // proxy used needs a different `has` handler which is more performant and
    // also only allows a whitelist of globals to fallthrough.

    if (instance.render._rc) {
      instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  } // support for 2.x options


  if (true) {
    currentInstance = instance;
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    applyOptions(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    currentInstance = null;
  } // warn missing template/render
  // the runtime compilation of template in SSR is done by server-render


  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
    /* istanbul ignore if */
    if (!compile && Component.template) {
      warn("Component provided template option but " + "runtime compilation is not supported in this build of Vue." + " Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\"."
      /* should not happen */
      );
    } else {
      warn("Component is missing template or render function.");
    }
  }
}

var attrHandlers = {
  get: function get(target, key) {
    if (true) {
      markAttrsAccessed();
    }

    return target[key];
  },
  set: function set() {
    warn("setupContext.attrs is readonly.");
    return false;
  },
  deleteProperty: function deleteProperty() {
    warn("setupContext.attrs is readonly.");
    return false;
  }
};

function createSetupContext(instance) {
  var expose = function expose(exposed) {
    if ( true && instance.exposed) {
      warn("expose() should be called only once per setup().");
    }

    instance.exposed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(exposed);
  };

  if (true) {
    // We use getters in dev in case libs like test-utils overwrite instance
    // properties (overwrites should not be done in prod)
    return Object.freeze({
      get attrs() {
        return new Proxy(instance.attrs, attrHandlers);
      },

      get slots() {
        return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
      },

      get emit() {
        return function (event) {
          for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key16 = 1; _key16 < _len8; _key16++) {
            args[_key16 - 1] = arguments[_key16];
          }

          return instance.emit.apply(instance, [event].concat(args));
        };
      },

      expose: expose
    });
  } else {}
} // record effects created during a component's setup() so that they can be
// stopped when the component unmounts


function recordInstanceBoundEffect(effect) {
  var instance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;

  if (instance) {
    (instance.effects || (instance.effects = [])).push(effect);
  }
}

var classifyRE = /(?:^|[-_])(\w)/g;

var classify = function classify(str) {
  return str.replace(classifyRE, function (c) {
    return c.toUpperCase();
  }).replace(/[-_]/g, '');
};

function getComponentName(Component) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name;
}
/* istanbul ignore next */


function formatComponentName(instance, Component) {
  var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var name = getComponentName(Component);

  if (!name && Component.__file) {
    var match = Component.__file.match(/([^/\\]+)\.\w+$/);

    if (match) {
      name = match[1];
    }
  }

  if (!name && instance && instance.parent) {
    // try to infer the name based on reverse resolution
    var inferFromRegistry = function inferFromRegistry(registry) {
      for (var key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };

    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }

  return name ? classify(name) : isRoot ? "App" : "Anonymous";
}

function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

function computed(getterOrOptions) {
  var c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions);
  recordInstanceBoundEffect(c.effect);
  return c;
} // implementation


function defineProps() {
  if (true) {
    warn("defineProps() is a compiler-hint helper that is only usable inside " + "<script setup> of a single file component. Its arguments should be " + "compiled away and passing it at runtime has no effect.");
  }

  return null;
} // implementation


function defineEmit() {
  if (true) {
    warn("defineEmit() is a compiler-hint helper that is only usable inside " + "<script setup> of a single file component. Its arguments should be " + "compiled away and passing it at runtime has no effect.");
  }

  return null;
}

function useContext() {
  var i = getCurrentInstance();

  if ( true && !i) {
    warn("useContext() called without active instance.");
  }

  return i.setupContext || (i.setupContext = createSetupContext(i));
} // Actual implementation


function h(type, propsOrChildren, children) {
  var l = arguments.length;

  if (l === 2) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
      // single vnode without props
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      } // props without children


      return createVNode(type, propsOrChildren);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }

    return createVNode(type, propsOrChildren, children);
  }
}

var ssrContextKey = Symbol( true ? "ssrContext" : 0);

var useSSRContext = function useSSRContext() {
  {
    var ctx = inject(ssrContextKey);

    if (!ctx) {
      warn("Server rendering context not provided. Make sure to only call " + "useSSRContext() conditionally in the server build.");
    }

    return ctx;
  }
};

function initCustomFormatter() {
  /* eslint-disable no-restricted-globals */
  if ( false || typeof window === 'undefined') {
    return;
  }

  var vueStyle = {
    style: 'color:#3ba776'
  };
  var numberStyle = {
    style: 'color:#0b1bc9'
  };
  var stringStyle = {
    style: 'color:#b62e24'
  };
  var keywordStyle = {
    style: 'color:#9d288c'
  }; // custom formatter for Chrome
  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html

  var formatter = {
    header: function header(obj) {
      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
      }

      if (obj.__isVue) {
        return ['div', vueStyle, "VueInstance"];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
        return ['div', {}, ['span', vueStyle, genRefFlag(obj)], '<', formatValue(obj.value), ">"];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
        return ['div', {}, ['span', vueStyle, 'Reactive'], '<', formatValue(obj), ">".concat((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? " (readonly)" : "")];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
        return ['div', {}, ['span', vueStyle, 'Readonly'], '<', formatValue(obj), '>'];
      }

      return null;
    },
    hasBody: function hasBody(obj) {
      return obj && obj.__isVue;
    },
    body: function body(obj) {
      if (obj && obj.__isVue) {
        return ['div', {}].concat(_toConsumableArray(formatInstance(obj.$)));
      }
    }
  };

  function formatInstance(instance) {
    var blocks = [];

    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
    }

    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('setup', instance.setupState));
    }

    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
    }

    var computed = extractKeys(instance, 'computed');

    if (computed) {
      blocks.push(createInstanceBlock('computed', computed));
    }

    var injected = extractKeys(instance, 'inject');

    if (injected) {
      blocks.push(createInstanceBlock('injected', injected));
    }

    blocks.push(['div', {}, ['span', {
      style: keywordStyle.style + ';opacity:0.66'
    }, '$ (internal): '], ['object', {
      object: instance
    }]]);
    return blocks;
  }

  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);

    if (!Object.keys(target).length) {
      return ['span', {}];
    }

    return ['div', {
      style: 'line-height:1.25em;margin-bottom:0.6em'
    }, ['div', {
      style: 'color:#476582'
    }, type], ['div', {
      style: 'padding-left:1.25em'
    }].concat(_toConsumableArray(Object.keys(target).map(function (key) {
      return ['div', {}, ['span', keywordStyle, key + ': '], formatValue(target[key], false)];
    })))];
  }

  function formatValue(v) {
    var asRaw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (typeof v === 'number') {
      return ['span', numberStyle, v];
    } else if (typeof v === 'string') {
      return ['span', stringStyle, JSON.stringify(v)];
    } else if (typeof v === 'boolean') {
      return ['span', keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
      return ['object', {
        object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v
      }];
    } else {
      return ['span', stringStyle, String(v)];
    }
  }

  function extractKeys(instance, type) {
    var Comp = instance.type;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
      return;
    }

    var extracted = {};

    for (var key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }

    return extracted;
  }

  function isKeyOfType(Comp, key, type) {
    var opts = Comp[type];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {
      return true;
    }

    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }

    if (Comp.mixins && Comp.mixins.some(function (m) {
      return isKeyOfType(m, key, type);
    })) {
      return true;
    }
  }

  function genRefFlag(v) {
    if (v._shallow) {
      return "ShallowRef";
    }

    if (v.effect) {
      return "ComputedRef";
    }

    return "Ref";
  }

  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
} // Core API ------------------------------------------------------------------


var version = "3.1.1";
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */

var ssrUtils = null;
/**
 * @internal only exposed in compat builds
 */

var resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */

var compatUtils = null;


/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




var svgNS = 'http://www.w3.org/2000/svg';
var doc = typeof document !== 'undefined' ? document : null;
var tempContainer;
var tempSVGContainer;
var nodeOps = {
  insert: function insert(child, parent, anchor) {
    parent.insertBefore(child, anchor || null);
  },
  remove: function remove(child) {
    var parent = child.parentNode;

    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: function createElement(tag, isSVG, is, props) {
    var el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
      is: is
    } : undefined);

    if (tag === 'select' && props && props.multiple != null) {
      el.setAttribute('multiple', props.multiple);
    }

    return el;
  },
  createText: function createText(text) {
    return doc.createTextNode(text);
  },
  createComment: function createComment(text) {
    return doc.createComment(text);
  },
  setText: function setText(node, text) {
    node.nodeValue = text;
  },
  setElementText: function setElementText(el, text) {
    el.textContent = text;
  },
  parentNode: function parentNode(node) {
    return node.parentNode;
  },
  nextSibling: function nextSibling(node) {
    return node.nextSibling;
  },
  querySelector: function querySelector(selector) {
    return doc.querySelector(selector);
  },
  setScopeId: function setScopeId(el, id) {
    el.setAttribute(id, '');
  },
  cloneNode: function cloneNode(el) {
    var cloned = el.cloneNode(true); // #3072
    // - in `patchDOMProp`, we store the actual value in the `el._value` property.
    // - normally, elements using `:value` bindings will not be hoisted, but if
    //   the bound value is a constant, e.g. `:value="true"` - they do get
    //   hoisted.
    // - in production, hoisted nodes are cloned when subsequent inserts, but
    //   cloneNode() does not copy the custom property we attached.
    // - This may need to account for other custom DOM properties we attach to
    //   elements in addition to `_value` in the future.

    if ("_value" in el) {
      cloned._value = el._value;
    }

    return cloned;
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent: function insertStaticContent(content, parent, anchor, isSVG) {
    var temp = isSVG ? tempSVGContainer || (tempSVGContainer = doc.createElementNS(svgNS, 'svg')) : tempContainer || (tempContainer = doc.createElement('div'));
    temp.innerHTML = content;
    var first = temp.firstChild;
    var node = first;
    var last = node;

    while (node) {
      last = node;
      nodeOps.insert(node, parent, anchor);
      node = temp.firstChild;
    }

    return [first, last];
  }
}; // compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]

function patchClass(el, value, isSVG) {
  if (value == null) {
    value = '';
  }

  if (isSVG) {
    el.setAttribute('class', value);
  } else {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    var transitionClasses = el._vtc;

    if (transitionClasses) {
      value = (value ? [value].concat(_toConsumableArray(transitionClasses)) : _toConsumableArray(transitionClasses)).join(' ');
    }

    el.className = value;
  }
}

function patchStyle(el, prev, next) {
  var style = el.style;

  if (!next) {
    el.removeAttribute('style');
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next)) {
    if (prev !== next) {
      var current = style.display;
      style.cssText = next; // indicates that the `display` of the element is controlled by `v-show`,
      // so we always keep the current `display` value regardless of the `style` value,
      // thus handing over control to `v-show`.

      if ('_vod' in el) {
        style.display = current;
      }
    }
  } else {
    for (var key in next) {
      setStyle(style, key, next[key]);
    }

    if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
      for (var _key in prev) {
        if (next[_key] == null) {
          setStyle(style, _key, '');
        }
      }
    }
  }
}

var importantRE = /\s*!important$/;

function setStyle(style, name, val) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
    val.forEach(function (v) {
      return setStyle(style, name, v);
    });
  } else {
    if (name.startsWith('--')) {
      // custom property definition
      style.setProperty(name, val);
    } else {
      var prefixed = autoPrefix(style, name);

      if (importantRE.test(val)) {
        // !important
        style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
      } else {
        style[prefixed] = val;
      }
    }
  }
}

var prefixes = ['Webkit', 'Moz', 'ms'];
var prefixCache = {};

function autoPrefix(style, rawName) {
  var cached = prefixCache[rawName];

  if (cached) {
    return cached;
  }

  var name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);

  if (name !== 'filter' && name in style) {
    return prefixCache[rawName] = name;
  }

  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);

  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + name;

    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }

  return rawName;
}

var xlinkNS = 'http://www.w3.org/1999/xlink';

function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith('xlink:')) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    // note we are only checking boolean attributes that don't have a
    // corresponding dom prop of the same name here.
    var isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);

    if (value == null || isBoolean && value === false) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? '' : value);
    }
  }
} // __UNSAFE__
// functions. The user is responsible for using them with only trusted content.


function patchDOMProp(el, key, value, // the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === 'innerHTML' || key === 'textContent') {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }

    el[key] = value == null ? '' : value;
    return;
  }

  if (key === 'value' && el.tagName !== 'PROGRESS') {
    // store value as _value as well since
    // non-string values will be stringified.
    el._value = value;
    var newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }

    if (value == null) {
      el.removeAttribute(key);
    }

    return;
  }

  if (value === '' || value == null) {
    var type = _typeof(el[key]);

    if (value === '' && type === 'boolean') {
      // e.g. <select multiple> compiles to { multiple: '' }
      el[key] = true;
      return;
    } else if (value == null && type === 'string') {
      // e.g. <div :id="null">
      el[key] = '';
      el.removeAttribute(key);
      return;
    } else if (type === 'number') {
      // e.g. <img :width="null">
      el[key] = 0;
      el.removeAttribute(key);
      return;
    }
  } // some properties perform value validation and throw


  try {
    el[key] = value;
  } catch (e) {
    if (true) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Failed setting prop \"".concat(key, "\" on <").concat(el.tagName.toLowerCase(), ">: ") + "value ".concat(value, " is invalid."), e);
    }
  }
} // Async edge case fix requires storing an event listener's attach timestamp.


var _getNow = Date.now;
var skipTimestampCheck = false;

if (typeof window !== 'undefined') {
  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  if (_getNow() > document.createEvent('Event').timeStamp) {
    // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    _getNow = function _getNow() {
      return performance.now();
    };
  } // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
  // and does not fire microtasks in between event propagation, so safe to exclude.


  var ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
} // To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.


var cachedNow = 0;
var p = Promise.resolve();

var reset = function reset() {
  cachedNow = 0;
};

var getNow = function getNow() {
  return cachedNow || (p.then(reset), cachedNow = _getNow());
};

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}

function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}

function patchEvent(el, rawName, prevValue, nextValue) {
  var instance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  // vei = vue event invokers
  var invokers = el._vei || (el._vei = {});
  var existingInvoker = invokers[rawName];

  if (nextValue && existingInvoker) {
    // patch
    existingInvoker.value = nextValue;
  } else {
    var _parseName = parseName(rawName),
        _parseName2 = _slicedToArray(_parseName, 2),
        name = _parseName2[0],
        options = _parseName2[1];

    if (nextValue) {
      // add
      var invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      // remove
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = undefined;
    }
  }
}

var optionsModifierRE = /(?:Once|Passive|Capture)$/;

function parseName(name) {
  var options;

  if (optionsModifierRE.test(name)) {
    options = {};
    var m;

    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }

  return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}

function createInvoker(initialValue, instance) {
  var invoker = function invoker(e) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    var timeStamp = e.timeStamp || _getNow();

    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5
      /* NATIVE_EVENT_HANDLER */
      , [e]);
    }
  };

  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}

function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    var originalStop = e.stopImmediatePropagation;

    e.stopImmediatePropagation = function () {
      originalStop.call(e);
      e._stopped = true;
    };

    return value.map(function (fn) {
      return function (e) {
        return !e._stopped && fn(e);
      };
    });
  } else {
    return value;
  }
}

var nativeOnRE = /^on[a-z]/;

var forcePatchProp = function forcePatchProp(_, key) {
  return key === 'value';
};

var patchProp = function patchProp(el, key, prevValue, nextValue) {
  var isSVG = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var prevChildren = arguments.length > 5 ? arguments[5] : undefined;
  var parentComponent = arguments.length > 6 ? arguments[6] : undefined;
  var parentSuspense = arguments.length > 7 ? arguments[7] : undefined;
  var unmountChildren = arguments.length > 8 ? arguments[8] : undefined;

  switch (key) {
    // special
    case 'class':
      patchClass(el, nextValue, isSVG);
      break;

    case 'style':
      patchStyle(el, prevValue, nextValue);
      break;

    default:
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        // ignore v-model listeners
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
      } else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
          el._trueValue = nextValue;
        } else if (key === 'false-value') {
          el._falseValue = nextValue;
        }

        patchAttr(el, key, nextValue, isSVG);
      }

      break;
  }
};

function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    // most keys must be set as attribute on svg elements to work
    // ...except innerHTML
    if (key === 'innerHTML') {
      return true;
    } // or native onclick with function values


    if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      return true;
    }

    return false;
  } // spellcheck and draggable are numerated attrs, however their
  // corresponding DOM properties are actually booleans - this leads to
  // setting it with a string "false" value leading it to be coerced to
  // `true`, so we need to always treat them as attributes.
  // Note that `contentEditable` doesn't have this problem: its DOM
  // property is also enumerated string values.


  if (key === 'spellcheck' || key === 'draggable') {
    return false;
  } // #1787, #2840 form property on form elements is readonly and must be set as
  // attribute.


  if (key === 'form') {
    return false;
  } // #1526 <input list> must be set as attribute


  if (key === 'list' && el.tagName === 'INPUT') {
    return false;
  } // #2766 <textarea type> must be set as attribute


  if (key === 'type' && el.tagName === 'TEXTAREA') {
    return false;
  } // native onclick with string value, must be set as attribute


  if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    return false;
  }

  return key in el;
}

function useCssModule() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$style';

  /* istanbul ignore else */
  {
    var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();

    if (!instance) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("useCssModule must be called inside setup()");
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    var modules = instance.type.__cssModules;

    if (!modules) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Current instance does not have CSS modules injected.");
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    var mod = modules[name];

    if (!mod) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Current instance does not have CSS module named \"".concat(name, "\"."));
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    return mod;
  }
}
/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */


function useCssVars(getter) {
  var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  /* istanbul ignore next */

  if (!instance) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("useCssVars is called without current active component instance.");
    return;
  }

  var setVars = function setVars() {
    return setVarsOnVNode(instance.subTree, getter(instance.proxy));
  };

  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(function () {
    return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(setVars, {
      flush: 'post'
    });
  });
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(setVars);
}

function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
      var suspense = vnode.suspense;
      vnode = suspense.activeBranch;

      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(function () {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    } // drill down HOCs until it's a non-component vnode


  while (vnode.component) {
    vnode = vnode.component.subTree;
  }

  if (vnode.shapeFlag & 1
  /* ELEMENT */
  && vnode.el) {
    var style = vnode.el.style;

    for (var key in vars) {
      style.setProperty("--".concat(key), vars[key]);
    }
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
    vnode.children.forEach(function (c) {
      return setVarsOnVNode(c, vars);
    });
  }
}

var TRANSITION = 'transition';
var ANIMATION = 'animation'; // DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.

var Transition = function Transition(props, _ref) {
  var slots = _ref.slots;
  return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
};

Transition.displayName = 'Transition';
var DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
var TransitionPropsValidators = Transition.props = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators);
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */

var callHook = function callHook(hook) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
    hook.forEach(function (h) {
      return h.apply(void 0, _toConsumableArray(args));
    });
  } else if (hook) {
    hook.apply(void 0, _toConsumableArray(args));
  }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */


var hasExplicitCallback = function hasExplicitCallback(hook) {
  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.some(function (h) {
    return h.length > 1;
  }) : hook.length > 1 : false;
};

function resolveTransitionProps(rawProps) {
  var baseProps = {};

  for (var key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }

  if (rawProps.css === false) {
    return baseProps;
  }

  var _rawProps$name = rawProps.name,
      name = _rawProps$name === void 0 ? 'v' : _rawProps$name,
      type = rawProps.type,
      duration = rawProps.duration,
      _rawProps$enterFromCl = rawProps.enterFromClass,
      enterFromClass = _rawProps$enterFromCl === void 0 ? "".concat(name, "-enter-from") : _rawProps$enterFromCl,
      _rawProps$enterActive = rawProps.enterActiveClass,
      enterActiveClass = _rawProps$enterActive === void 0 ? "".concat(name, "-enter-active") : _rawProps$enterActive,
      _rawProps$enterToClas = rawProps.enterToClass,
      enterToClass = _rawProps$enterToClas === void 0 ? "".concat(name, "-enter-to") : _rawProps$enterToClas,
      _rawProps$appearFromC = rawProps.appearFromClass,
      appearFromClass = _rawProps$appearFromC === void 0 ? enterFromClass : _rawProps$appearFromC,
      _rawProps$appearActiv = rawProps.appearActiveClass,
      appearActiveClass = _rawProps$appearActiv === void 0 ? enterActiveClass : _rawProps$appearActiv,
      _rawProps$appearToCla = rawProps.appearToClass,
      appearToClass = _rawProps$appearToCla === void 0 ? enterToClass : _rawProps$appearToCla,
      _rawProps$leaveFromCl = rawProps.leaveFromClass,
      leaveFromClass = _rawProps$leaveFromCl === void 0 ? "".concat(name, "-leave-from") : _rawProps$leaveFromCl,
      _rawProps$leaveActive = rawProps.leaveActiveClass,
      leaveActiveClass = _rawProps$leaveActive === void 0 ? "".concat(name, "-leave-active") : _rawProps$leaveActive,
      _rawProps$leaveToClas = rawProps.leaveToClass,
      leaveToClass = _rawProps$leaveToClas === void 0 ? "".concat(name, "-leave-to") : _rawProps$leaveToClas;
  var durations = normalizeDuration(duration);
  var enterDuration = durations && durations[0];
  var leaveDuration = durations && durations[1];

  var _onBeforeEnter = baseProps.onBeforeEnter,
      onEnter = baseProps.onEnter,
      _onEnterCancelled = baseProps.onEnterCancelled,
      _onLeave = baseProps.onLeave,
      _onLeaveCancelled = baseProps.onLeaveCancelled,
      _baseProps$onBeforeAp = baseProps.onBeforeAppear,
      _onBeforeAppear = _baseProps$onBeforeAp === void 0 ? _onBeforeEnter : _baseProps$onBeforeAp,
      _baseProps$onAppear = baseProps.onAppear,
      onAppear = _baseProps$onAppear === void 0 ? onEnter : _baseProps$onAppear,
      _baseProps$onAppearCa = baseProps.onAppearCancelled,
      _onAppearCancelled = _baseProps$onAppearCa === void 0 ? _onEnterCancelled : _baseProps$onAppearCa;

  var finishEnter = function finishEnter(el, isAppear, done) {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };

  var finishLeave = function finishLeave(el, done) {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };

  var makeEnterHook = function makeEnterHook(isAppear) {
    return function (el, done) {
      var hook = isAppear ? onAppear : onEnter;

      var resolve = function resolve() {
        return finishEnter(el, isAppear, done);
      };

      callHook(hook, [el, resolve]);
      nextFrame(function () {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);

        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };

  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
    onBeforeEnter: function onBeforeEnter(el) {
      callHook(_onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear: function onBeforeAppear(el) {
      callHook(_onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave: function onLeave(el, done) {
      var resolve = function resolve() {
        return finishLeave(el, done);
      };

      addTransitionClass(el, leaveFromClass); // force reflow so *-leave-from classes immediately take effect (#2593)

      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);

        if (!hasExplicitCallback(_onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(_onLeave, [el, resolve]);
    },
    onEnterCancelled: function onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(_onEnterCancelled, [el]);
    },
    onAppearCancelled: function onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(_onAppearCancelled, [el]);
    },
    onLeaveCancelled: function onLeaveCancelled(el) {
      finishLeave(el);
      callHook(_onLeaveCancelled, [el]);
    }
  });
}

function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    var n = NumberOf(duration);
    return [n, n];
  }
}

function NumberOf(val) {
  var res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
  if (true) validateDuration(res);
  return res;
}

function validateDuration(val) {
  if (typeof val !== 'number') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<transition> explicit duration is not a valid number - " + "got ".concat(JSON.stringify(val), "."));
  } else if (isNaN(val)) {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<transition> explicit duration is NaN - " + 'the duration expression might be incorrect.');
  }
}

function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(function (c) {
    return c && el.classList.add(c);
  });
  (el._vtc || (el._vtc = new Set())).add(cls);
}

function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(function (c) {
    return c && el.classList.remove(c);
  });
  var _vtc = el._vtc;

  if (_vtc) {
    _vtc.delete(cls);

    if (!_vtc.size) {
      el._vtc = undefined;
    }
  }
}

function nextFrame(cb) {
  requestAnimationFrame(function () {
    requestAnimationFrame(cb);
  });
}

var endId = 0;

function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  var id = el._endId = ++endId;

  var resolveIfNotStale = function resolveIfNotStale() {
    if (id === el._endId) {
      resolve();
    }
  };

  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }

  var _getTransitionInfo = getTransitionInfo(el, expectedType),
      type = _getTransitionInfo.type,
      timeout = _getTransitionInfo.timeout,
      propCount = _getTransitionInfo.propCount;

  if (!type) {
    return resolve();
  }

  var endEvent = type + 'end';
  var ended = 0;

  var end = function end() {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };

  var onEnd = function onEnd(e) {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var getStyleProperties = function getStyleProperties(key) {
    return (styles[key] || '').split(', ');
  };

  var transitionDelays = getStyleProperties(TRANSITION + 'Delay');
  var transitionDurations = getStyleProperties(TRANSITION + 'Duration');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = getStyleProperties(ANIMATION + 'Delay');
  var animationDurations = getStyleProperties(ANIMATION + 'Duration');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type = null;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(Math, _toConsumableArray(durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  })));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
} // synchronously force layout to put elements into a certain state


function forceReflow() {
  return document.body.offsetHeight;
}

var positionMap = new WeakMap();
var newPositionMap = new WeakMap();
var TransitionGroupImpl = {
  name: 'TransitionGroup',
  props: /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup: function setup(props, _ref2) {
    var slots = _ref2.slots;
    var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    var state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
    var prevChildren;
    var children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(function () {
      // children is guaranteed to exist after initial render
      if (!prevChildren.length) {
        return;
      }

      var moveClass = props.moveClass || "".concat(props.name || 'v', "-move");

      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      } // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.


      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      var movedChildren = prevChildren.filter(applyTranslation); // force reflow to put everything in position

      forceReflow();
      movedChildren.forEach(function (c) {
        var el = c.el;
        var style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = '';

        var cb = el._moveCb = function (e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener('transitionend', cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };

        el.addEventListener('transitionend', cb);
      });
    });
    return function () {
      var rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
      var cssTransitionProps = resolveTransitionProps(rawProps);
      var tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
      prevChildren = children;
      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
        } else if (true) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<TransitionGroup> children must be keyed.");
        }
      }

      if (prevChildren) {
        for (var _i2 = 0; _i2 < prevChildren.length; _i2++) {
          var _child = prevChildren[_i2];
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(_child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(_child, cssTransitionProps, state, instance));
          positionMap.set(_child, _child.el.getBoundingClientRect());
        }
      }

      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
    };
  }
};
var TransitionGroup = TransitionGroupImpl;

function callPendingCbs(c) {
  var el = c.el;

  if (el._moveCb) {
    el._moveCb();
  }

  if (el._enterCb) {
    el._enterCb();
  }
}

function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}

function applyTranslation(c) {
  var oldPos = positionMap.get(c);
  var newPos = newPositionMap.get(c);
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    var s = c.el.style;
    s.transform = s.webkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
    s.transitionDuration = '0s';
    return c;
  }
}

function hasCSSTransform(el, root, moveClass) {
  // Detect whether an element with the move class applied has
  // CSS transitions. Since the element may be inside an entering
  // transition at this very moment, we make a clone of it and remove
  // all other transition classes applied to ensure only the move class
  // is applied.
  var clone = el.cloneNode();

  if (el._vtc) {
    el._vtc.forEach(function (cls) {
      cls.split(/\s+/).forEach(function (c) {
        return c && clone.classList.remove(c);
      });
    });
  }

  moveClass.split(/\s+/).forEach(function (c) {
    return c && clone.classList.add(c);
  });
  clone.style.display = 'none';
  var container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);

  var _getTransitionInfo2 = getTransitionInfo(clone),
      hasTransform = _getTransitionInfo2.hasTransform;

  container.removeChild(clone);
  return hasTransform;
}

var getModelAssigner = function getModelAssigner(vnode) {
  var fn = vnode.props['onUpdate:modelValue'];
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? function (value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value);
  } : fn;
};

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  var target = e.target;

  if (target.composing) {
    target.composing = false;
    trigger(target, 'input');
  }
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
} // We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.


var vModelText = {
  created: function created(el, _ref3, vnode) {
    var _ref3$modifiers = _ref3.modifiers,
        lazy = _ref3$modifiers.lazy,
        trim = _ref3$modifiers.trim,
        number = _ref3$modifiers.number;
    el._assign = getModelAssigner(vnode);
    var castToNumber = number || el.type === 'number';
    addEventListener(el, lazy ? 'change' : 'input', function (e) {
      if (e.target.composing) return;
      var domValue = el.value;

      if (trim) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
      }

      el._assign(domValue);
    });

    if (trim) {
      addEventListener(el, 'change', function () {
        el.value = el.value.trim();
      });
    }

    if (!lazy) {
      addEventListener(el, 'compositionstart', onCompositionStart);
      addEventListener(el, 'compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
      // switching focus before confirming composition choice
      // this also fixes the issue where some browsers e.g. iOS Chrome
      // fires "change" instead of "input" on autocomplete.

      addEventListener(el, 'change', onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted: function mounted(el, _ref4) {
    var value = _ref4.value;
    el.value = value == null ? '' : value;
  },
  beforeUpdate: function beforeUpdate(el, _ref5, vnode) {
    var value = _ref5.value,
        _ref5$modifiers = _ref5.modifiers,
        trim = _ref5$modifiers.trim,
        number = _ref5$modifiers.number;
    el._assign = getModelAssigner(vnode); // avoid clearing unresolved text. #2302

    if (el.composing) return;

    if (document.activeElement === el) {
      if (trim && el.value.trim() === value) {
        return;
      }

      if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
        return;
      }
    }

    var newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
var vModelCheckbox = {
  created: function created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', function () {
      var modelValue = el._modelValue;
      var elementValue = getValue(el);
      var checked = el.checked;
      var assign = el._assign;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
        var index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
        var found = index !== -1;

        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          var filtered = _toConsumableArray(modelValue);

          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
        var cloned = new Set(modelValue);

        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }

        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate: function beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};

function setChecked(el, _ref6, vnode) {
  var value = _ref6.value,
      oldValue = _ref6.oldValue;
  el._modelValue = value;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
  }
}

var vModelRadio = {
  created: function created(el, _ref7, vnode) {
    var value = _ref7.value;
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', function () {
      el._assign(getValue(el));
    });
  },
  beforeUpdate: function beforeUpdate(el, _ref8, vnode) {
    var value = _ref8.value,
        oldValue = _ref8.oldValue;
    el._assign = getModelAssigner(vnode);

    if (value !== oldValue) {
      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    }
  }
};
var vModelSelect = {
  created: function created(el, _ref9, vnode) {
    var value = _ref9.value,
        number = _ref9.modifiers.number;
    var isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
    addEventListener(el, 'change', function () {
      var selectedVal = Array.prototype.filter.call(el.options, function (o) {
        return o.selected;
      }).map(function (o) {
        return number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o);
      });

      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted: function mounted(el, _ref10) {
    var value = _ref10.value;
    setSelected(el, value);
  },
  beforeUpdate: function beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated: function updated(el, _ref11) {
    var value = _ref11.value;
    setSelected(el, value);
  }
};

function setSelected(el, value) {
  var isMultiple = el.multiple;

  if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<select multiple v-model> expects an Array or Set value for its binding, " + "but got ".concat(Object.prototype.toString.call(value).slice(8, -1), "."));
    return;
  }

  for (var i = 0, l = el.options.length; i < l; i++) {
    var option = el.options[i];
    var optionValue = getValue(option);

    if (isMultiple) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
  }

  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
} // retrieve raw value set via :value bindings


function getValue(el) {
  return '_value' in el ? el._value : el.value;
} // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings


function getCheckboxValue(el, checked) {
  var key = checked ? '_trueValue' : '_falseValue';
  return key in el ? el[key] : checked;
}

var vModelDynamic = {
  created: function created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'created');
  },
  mounted: function mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'mounted');
  },
  beforeUpdate: function beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
  },
  updated: function updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'updated');
  }
};

function callModelHook(el, binding, vnode, prevVNode, hook) {
  var modelToUse;

  switch (el.tagName) {
    case 'SELECT':
      modelToUse = vModelSelect;
      break;

    case 'TEXTAREA':
      modelToUse = vModelText;
      break;

    default:
      switch (vnode.props && vnode.props.type) {
        case 'checkbox':
          modelToUse = vModelCheckbox;
          break;

        case 'radio':
          modelToUse = vModelRadio;
          break;

        default:
          modelToUse = vModelText;
      }

  }

  var fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}

var systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
var modifierGuards = {
  stop: function stop(e) {
    return e.stopPropagation();
  },
  prevent: function prevent(e) {
    return e.preventDefault();
  },
  self: function self(e) {
    return e.target !== e.currentTarget;
  },
  ctrl: function ctrl(e) {
    return !e.ctrlKey;
  },
  shift: function shift(e) {
    return !e.shiftKey;
  },
  alt: function alt(e) {
    return !e.altKey;
  },
  meta: function meta(e) {
    return !e.metaKey;
  },
  left: function left(e) {
    return 'button' in e && e.button !== 0;
  },
  middle: function middle(e) {
    return 'button' in e && e.button !== 1;
  },
  right: function right(e) {
    return 'button' in e && e.button !== 2;
  },
  exact: function exact(e, modifiers) {
    return systemModifiers.some(function (m) {
      return e["".concat(m, "Key")] && !modifiers.includes(m);
    });
  }
};
/**
 * @private
 */

var withModifiers = function withModifiers(fn, modifiers) {
  return function (event) {
    for (var i = 0; i < modifiers.length; i++) {
      var guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return fn.apply(void 0, [event].concat(args));
  };
}; // Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.


var keyNames = {
  esc: 'escape',
  space: ' ',
  up: 'arrow-up',
  left: 'arrow-left',
  right: 'arrow-right',
  down: 'arrow-down',
  delete: 'backspace'
};
/**
 * @private
 */

var withKeys = function withKeys(fn, modifiers) {
  return function (event) {
    if (!('key' in event)) {
      return;
    }

    var eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);

    if (modifiers.some(function (k) {
      return k === eventKey || keyNames[k] === eventKey;
    })) {
      return fn(event);
    }
  };
};

var vShow = {
  beforeMount: function beforeMount(el, _ref12, _ref13) {
    var value = _ref12.value;
    var transition = _ref13.transition;
    el._vod = el.style.display === 'none' ? '' : el.style.display;

    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted: function mounted(el, _ref14, _ref15) {
    var value = _ref14.value;
    var transition = _ref15.transition;

    if (transition && value) {
      transition.enter(el);
    }
  },
  updated: function updated(el, _ref16, _ref17) {
    var value = _ref16.value,
        oldValue = _ref16.oldValue;
    var transition = _ref17.transition;
    if (!value === !oldValue) return;

    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, function () {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount: function beforeUnmount(el, _ref18) {
    var value = _ref18.value;
    setDisplay(el, value);
  }
};

function setDisplay(el, value) {
  el.style.display = value ? el._vod : 'none';
}

var rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
  patchProp: patchProp,
  forcePatchProp: forcePatchProp
}, nodeOps); // lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.

var renderer;
var enabledHydration = false;

function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}

function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
  enabledHydration = true;
  return renderer;
} // use explicit type casts here to avoid import() calls in rolled-up d.ts


var render = function render() {
  var _ensureRenderer;

  (_ensureRenderer = ensureRenderer()).render.apply(_ensureRenderer, arguments);
};

var hydrate = function hydrate() {
  var _ensureHydrationRende;

  (_ensureHydrationRende = ensureHydrationRenderer()).hydrate.apply(_ensureHydrationRende, arguments);
};

var createApp = function createApp() {
  var _ensureRenderer2;

  var app = (_ensureRenderer2 = ensureRenderer()).createApp.apply(_ensureRenderer2, arguments);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  var mount = app.mount;

  app.mount = function (containerOrSelector) {
    var container = normalizeContainer(containerOrSelector);
    if (!container) return;
    var component = app._component;

    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
      // __UNSAFE__
      // Reason: potential execution of JS expressions in in-DOM template.
      // The user must make sure the in-DOM template is trusted. If it's
      // rendered by the server, the template should not contain any user data.
      component.template = container.innerHTML;
    } // clear content before mounting


    container.innerHTML = '';
    var proxy = mount(container, false, container instanceof SVGElement);

    if (container instanceof Element) {
      container.removeAttribute('v-cloak');
      container.setAttribute('data-v-app', '');
    }

    return proxy;
  };

  return app;
};

var createSSRApp = function createSSRApp() {
  var _ensureHydrationRende2;

  var app = (_ensureHydrationRende2 = ensureHydrationRenderer()).createApp.apply(_ensureHydrationRende2, arguments);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  var mount = app.mount;

  app.mount = function (containerOrSelector) {
    var container = normalizeContainer(containerOrSelector);

    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };

  return app;
};

function injectNativeTagCheck(app) {
  // Inject `isNativeTag`
  // this is used for component name validation (dev only)
  Object.defineProperty(app.config, 'isNativeTag', {
    value: function value(tag) {
      return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag);
    },
    writable: false
  });
} // dev only


function injectCompilerOptionsCheck(app) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
    var isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, 'isCustomElement', {
      get: function get() {
        return isCustomElement;
      },
      set: function set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("The `isCustomElement` config option is deprecated. Use " + "`compilerOptions.isCustomElement` instead.");
      }
    });
    var compilerOptions = app.config.compilerOptions;
    var msg = "The `compilerOptions` config option is only respected when using " + "a build of Vue.js that includes the runtime compiler (aka \"full build\"). " + "Since you are using the runtime-only build, `compilerOptions` " + "must be passed to `@vue/compiler-dom` in the build setup instead.\n" + "- For vue-loader: pass it via vue-loader's `compilerOptions` loader option.\n" + "- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n" + "- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom";
    Object.defineProperty(app.config, 'compilerOptions', {
      get: function get() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
        return compilerOptions;
      },
      set: function set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
      }
    });
  }
}

function normalizeContainer(container) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
    var res = document.querySelector(container);

    if ( true && !res) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Failed to mount app: mount target selector \"".concat(container, "\" returned null."));
    }

    return res;
  }

  if ( true && container instanceof window.ShadowRoot && container.mode === 'closed') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("mounting on a ShadowRoot with `{mode: \"closed\"}` may lead to unpredictable bugs");
  }

  return container;
}



/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "babelParserDefaultPlugins": () => (/* binding */ babelParserDefaultPlugins),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownAttr": () => (/* binding */ isKnownAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
var _PatchFlagNames, _slotFlagsText;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return !!map[val.toLowerCase()];
  } : function (val) {
    return !!map[val];
  };
}
/**
 * dev only flag -> name mapping
 */


var PatchFlagNames = (_PatchFlagNames = {}, _defineProperty(_PatchFlagNames, 1
/* TEXT */
, "TEXT"), _defineProperty(_PatchFlagNames, 2
/* CLASS */
, "CLASS"), _defineProperty(_PatchFlagNames, 4
/* STYLE */
, "STYLE"), _defineProperty(_PatchFlagNames, 8
/* PROPS */
, "PROPS"), _defineProperty(_PatchFlagNames, 16
/* FULL_PROPS */
, "FULL_PROPS"), _defineProperty(_PatchFlagNames, 32
/* HYDRATE_EVENTS */
, "HYDRATE_EVENTS"), _defineProperty(_PatchFlagNames, 64
/* STABLE_FRAGMENT */
, "STABLE_FRAGMENT"), _defineProperty(_PatchFlagNames, 128
/* KEYED_FRAGMENT */
, "KEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 256
/* UNKEYED_FRAGMENT */
, "UNKEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 512
/* NEED_PATCH */
, "NEED_PATCH"), _defineProperty(_PatchFlagNames, 1024
/* DYNAMIC_SLOTS */
, "DYNAMIC_SLOTS"), _defineProperty(_PatchFlagNames, 2048
/* DEV_ROOT_FRAGMENT */
, "DEV_ROOT_FRAGMENT"), _defineProperty(_PatchFlagNames, -1
/* HOISTED */
, "HOISTED"), _defineProperty(_PatchFlagNames, -2
/* BAIL */
, "BAIL"), _PatchFlagNames);
/**
 * Dev only
 */

var slotFlagsText = (_slotFlagsText = {}, _defineProperty(_slotFlagsText, 1
/* STABLE */
, 'STABLE'), _defineProperty(_slotFlagsText, 2
/* DYNAMIC */
, 'DYNAMIC'), _defineProperty(_slotFlagsText, 3
/* FORWARDED */
, 'FORWARDED'), _slotFlagsText);
var GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
var isGloballyWhitelisted = /*#__PURE__*/makeMap(GLOBALS_WHITE_LISTED);
var range = 2;

function generateCodeFrame(source) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        var line = j + 1;
        res.push("".concat(line).concat(' '.repeat(Math.max(3 - String(line).length, 0)), "|  ").concat(lines[j]));
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push("   |  " + ' '.repeat(pad) + '^'.repeat(length));
        } else if (j > i) {
          if (end > count) {
            var _length = Math.max(Math.min(end - count, lineLength), 1);

            res.push("   |  " + '^'.repeat(_length));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}
/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */


var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
var isSpecialBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */

var isBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden," + "loop,open,required,reversed,scoped,seamless," + "checked,muted,multiple,selected");
var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
var attrValidationCache = {};

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }

  var isUnsafe = unsafeAttrCharRE.test(name);

  if (isUnsafe) {
    console.error("unsafe attribute name: ".concat(name));
  }

  return attrValidationCache[name] = !isUnsafe;
}

var propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */

var isNoUnitNumericStyleProp = /*#__PURE__*/makeMap("animation-iteration-count,border-image-outset,border-image-slice," + "border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count," + "columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order," + "grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column," + "grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp," + "line-height,opacity,order,orphans,tab-size,widows,z-index,zoom," + // SVG
"fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset," + "stroke-miterlimit,stroke-opacity,stroke-width");
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */

var isKnownAttr = /*#__PURE__*/makeMap("accept,accept-charset,accesskey,action,align,allow,alt,async," + "autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor," + "border,buffered,capture,challenge,charset,checked,cite,class,code," + "codebase,color,cols,colspan,content,contenteditable,contextmenu,controls," + "coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname," + "disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form," + "formaction,formenctype,formmethod,formnovalidate,formtarget,headers," + "height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity," + "ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low," + "manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate," + "open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly," + "referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped," + "selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset," + "start,step,style,summary,tabindex,target,title,translate,type,usemap," + "value,width,wrap");

function normalizeStyle(value) {
  if (isArray(value)) {
    var res = {};

    for (var i = 0; i < value.length; i++) {
      var item = value[i];
      var normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);

      if (normalized) {
        for (var key in normalized) {
          res[key] = normalized[key];
        }
      }
    }

    return res;
  } else if (isObject(value)) {
    return value;
  }
}

var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:(.+)/;

function parseStringStyle(cssText) {
  var ret = {};
  cssText.split(listDelimiterRE).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}

function stringifyStyle(styles) {
  var ret = '';

  if (!styles) {
    return ret;
  }

  for (var key in styles) {
    var value = styles[key];
    var normalizedKey = key.startsWith("--") ? key : hyphenate(key);

    if (isString(value) || typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey)) {
      // only render valid values
      ret += "".concat(normalizedKey, ":").concat(value, ";");
    }
  }

  return ret;
}

function normalizeClass(value) {
  var res = '';

  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      var normalized = normalizeClass(value[i]);

      if (normalized) {
        res += normalized + ' ';
      }
    }
  } else if (isObject(value)) {
    for (var name in value) {
      if (value[name]) {
        res += name + ' ';
      }
    }
  }

  return res.trim();
} // These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element


var HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot'; // https://developer.mozilla.org/en-US/docs/Web/SVG/Element

var SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' + 'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' + 'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' + 'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' + 'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' + 'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' + 'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' + 'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' + 'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' + 'text,textPath,title,tspan,unknown,use,view';
var VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
var isHTMLTag = /*#__PURE__*/makeMap(HTML_TAGS);
var isSVGTag = /*#__PURE__*/makeMap(SVG_TAGS);
var isVoidTag = /*#__PURE__*/makeMap(VOID_TAGS);
var escapeRE = /["'&<>]/;

function escapeHtml(string) {
  var str = '' + string;
  var match = escapeRE.exec(str);

  if (!match) {
    return str;
  }

  var html = '';
  var escaped;
  var index;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escaped = '&quot;';
        break;

      case 38:
        // &
        escaped = '&amp;';
        break;

      case 39:
        // '
        escaped = '&#39;';
        break;

      case 60:
        // <
        escaped = '&lt;';
        break;

      case 62:
        // >
        escaped = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escaped;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
} // https://www.w3.org/TR/html52/syntax.html#comments


var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  var equal = true;

  for (var i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }

  return equal;
}

function looseEqual(a, b) {
  if (a === b) return true;
  var aValidType = isDate(a);
  var bValidType = isDate(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }

  aValidType = isArray(a);
  bValidType = isArray(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }

  aValidType = isObject(a);
  bValidType = isObject(b);

  if (aValidType || bValidType) {
    /* istanbul ignore if: this if will probably never be called */
    if (!aValidType || !bValidType) {
      return false;
    }

    var aKeysCount = Object.keys(a).length;
    var bKeysCount = Object.keys(b).length;

    if (aKeysCount !== bKeysCount) {
      return false;
    }

    for (var key in a) {
      var aHasKey = a.hasOwnProperty(key);
      var bHasKey = b.hasOwnProperty(key);

      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }

  return String(a) === String(b);
}

function looseIndexOf(arr, val) {
  return arr.findIndex(function (item) {
    return looseEqual(item, val);
  });
}
/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */


var toDisplayString = function toDisplayString(val) {
  return val == null ? '' : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);
};

var replacer = function replacer(_key, val) {
  if (isMap(val)) {
    return _defineProperty({}, "Map(".concat(val.size, ")"), _toConsumableArray(val.entries()).reduce(function (entries, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          val = _ref2[1];

      entries["".concat(key, " =>")] = val;
      return entries;
    }, {}));
  } else if (isSet(val)) {
    return _defineProperty({}, "Set(".concat(val.size, ")"), _toConsumableArray(val.values()));
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }

  return val;
};
/**
 * List of @babel/parser plugins that are used for template expression
 * transforms and SFC script transforms. By default we enable proposals slated
 * for ES2020. This will need to be updated as the spec moves forward.
 * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins
 */


var babelParserDefaultPlugins = ['bigInt', 'optionalChaining', 'nullishCoalescingOperator'];
var EMPTY_OBJ =  true ? Object.freeze({}) : 0;
var EMPTY_ARR =  true ? Object.freeze([]) : 0;

var NOOP = function NOOP() {};
/**
 * Always return false.
 */


var NO = function NO() {
  return false;
};

var onRE = /^on[^a-z]/;

var isOn = function isOn(key) {
  return onRE.test(key);
};

var isModelListener = function isModelListener(key) {
  return key.startsWith('onUpdate:');
};

var extend = Object.assign;

var remove = function remove(arr, el) {
  var i = arr.indexOf(el);

  if (i > -1) {
    arr.splice(i, 1);
  }
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var hasOwn = function hasOwn(val, key) {
  return hasOwnProperty.call(val, key);
};

var isArray = Array.isArray;

var isMap = function isMap(val) {
  return toTypeString(val) === '[object Map]';
};

var isSet = function isSet(val) {
  return toTypeString(val) === '[object Set]';
};

var isDate = function isDate(val) {
  return val instanceof Date;
};

var isFunction = function isFunction(val) {
  return typeof val === 'function';
};

var isString = function isString(val) {
  return typeof val === 'string';
};

var isSymbol = function isSymbol(val) {
  return _typeof(val) === 'symbol';
};

var isObject = function isObject(val) {
  return val !== null && _typeof(val) === 'object';
};

var isPromise = function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};

var objectToString = Object.prototype.toString;

var toTypeString = function toTypeString(value) {
  return objectToString.call(value);
};

var toRawType = function toRawType(value) {
  // extract "RawType" from strings like "[object RawType]"
  return toTypeString(value).slice(8, -1);
};

var isPlainObject = function isPlainObject(val) {
  return toTypeString(val) === '[object Object]';
};

var isIntegerKey = function isIntegerKey(key) {
  return isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;
};

var isReservedProp = /*#__PURE__*/makeMap( // the leading comma is intentional so empty string "" is also included
',key,ref,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted');

var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

var camelizeRE = /-(\w)/g;
/**
 * @private
 */

var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
var hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */

var hyphenate = cacheStringFunction(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * @private
 */

var capitalize = cacheStringFunction(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * @private
 */

var toHandlerKey = cacheStringFunction(function (str) {
  return str ? "on".concat(capitalize(str)) : "";
}); // compare whether a value has changed, accounting for NaN.

var hasChanged = function hasChanged(value, oldValue) {
  return value !== oldValue && (value === value || oldValue === oldValue);
};

var invokeArrayFns = function invokeArrayFns(fns, arg) {
  for (var i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};

var def = function def(obj, key, value) {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value: value
  });
};

var toNumber = function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
};

var _globalThis;

var getGlobalThis = function getGlobalThis() {
  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});
};



/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "compile": () => (/* binding */ compileToFunction)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");






function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.initCustomFormatter)();
  }
} // This entry is the "full-build" that includes both the runtime


if (true) {
  initDev();
}

var compileCache = Object.create(null);

function compileToFunction(template, options) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
       true && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)("invalid template option: ", template);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    }
  }

  var key = template;
  var cached = compileCache[key];

  if (cached) {
    return cached;
  }

  if (template[0] === '#') {
    var el = document.querySelector(template);

    if ( true && !el) {
      (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)("Template element not found or is empty: ".concat(template));
    } // __UNSAFE__
    // Reason: potential execution of JS expressions in in-DOM template.
    // The user must make sure the in-DOM template is trusted. If it's rendered
    // by the server, the template should not contain any user data.


    template = el ? el.innerHTML : "";
  }

  var _compile = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
    hoistStatic: true,
    onError:  true ? onError : 0,
    onWarn:  true ? function (e) {
      return onError(e, true);
    } : 0
  }, options)),
      code = _compile.code;

  function onError(err) {
    var asWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var message = asWarning ? err.message : "Template compilation error: ".concat(err.message);
    var codeFrame = err.loc && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(codeFrame ? "".concat(message, "\n").concat(codeFrame) : message);
  } // The wildcard import results in a huge object with every export
  // with keys that cannot be mangled, and can be quite heavy size-wise.
  // In the global build we know `Vue` is available globally so we can avoid
  // the wildcard object.


  var render = new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__);
  render._rc = true;
  return compileCache[key] = render;
}

(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.registerRuntimeCompiler)(compileToFunction);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!****************************!*\
  !*** ./public/js/index.js ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var app = (0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)({
  data: function data() {
    return {
      webcamStatus: '',
      TFCAM: undefined
    };
  },
  methods: {
    startCam: function startCam() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var snapshots;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                snapshots = [0];
                _context2.t0 = _this.TFCAM;

                if (_context2.t0) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 5;
                return tf.data.webcam(_this.$refs.webcam);

              case 5:
                _context2.t0 = _context2.sent;

              case 6:
                _this.TFCAM = _context2.t0;
                snapshots.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_) {
                    var capture;
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return _this.TFCAM.capture();

                          case 2:
                            capture = _context.sent;

                            _this.imageFromCapture(capture, function (dataUrl) {
                              return _this.uploadDataUrl(dataUrl);
                            }).then(function (_) {
                              return _this.webcamStatus = 'Started';
                            });

                          case 4:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }());

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    stopCam: function stopCam() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (_this2.TFCAM) {
                  _this2.TFCAM.stop();

                  _this2.TFCAM = undefined;
                  _this2.webcamStatus = "Stopped";
                } else {
                  _this2.webcamStatus = "Not started";
                }

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    imageFromCapture: function imageFromCapture(data, fn) {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", tf.browser.toPixels(data, _this3.$refs.hiddenCanvas).then( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_) {
                    var dataUrl;
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            dataUrl = _this3.$refs.hiddenCanvas.toDataURL('image/png');
                            fn(dataUrl);

                          case 2:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x2) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    },
    uploadDataUrl: function uploadDataUrl(dataUrl) {
      var _this4 = this;

      var data = new FormData();
      data.append('image', dataUrl);
      fetch('/uploadImage', {
        method: 'POST',
        body: data
      }).then( /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(res) {
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return res.text();

                case 2:
                  return _context6.abrupt("return", _this4.webcamStatus = _context6.sent);

                case 3:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x3) {
          return _ref3.apply(this, arguments);
        };
      }()).catch(function (err) {
        return _this4.webcamStatus = err;
      });
    }
  }
});
app.mount('#app');
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJjYW0tY2FwdHVyZXMvLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly93ZWJjYW0tY2FwdHVyZXMvLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vZGlzdC9jb21waWxlci1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzLy4vbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3dlYmNhbS1jYXB0dXJlcy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzLy4vbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3dlYmNhbS1jYXB0dXJlcy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYmNhbS1jYXB0dXJlcy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vd2ViY2FtLWNhcHR1cmVzLy4vcHVibGljL2pzL2luZGV4LmpzIl0sIm5hbWVzIjpbImRlZmF1bHRPbkVycm9yIiwiZXJyb3IiLCJkZWZhdWx0T25XYXJuIiwibXNnIiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsImNyZWF0ZUNvbXBpbGVyRXJyb3IiLCJjb2RlIiwibG9jIiwibWVzc2FnZXMiLCJhZGRpdGlvbmFsTWVzc2FnZSIsImVycm9yTWVzc2FnZXMiLCJTeW50YXhFcnJvciIsIlN0cmluZyIsIkZSQUdNRU5UIiwiU3ltYm9sIiwiVEVMRVBPUlQiLCJTVVNQRU5TRSIsIktFRVBfQUxJVkUiLCJCQVNFX1RSQU5TSVRJT04iLCJPUEVOX0JMT0NLIiwiQ1JFQVRFX0JMT0NLIiwiQ1JFQVRFX1ZOT0RFIiwiQ1JFQVRFX0NPTU1FTlQiLCJDUkVBVEVfVEVYVCIsIkNSRUFURV9TVEFUSUMiLCJSRVNPTFZFX0NPTVBPTkVOVCIsIlJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQiLCJSRVNPTFZFX0RJUkVDVElWRSIsIlJFU09MVkVfRklMVEVSIiwiV0lUSF9ESVJFQ1RJVkVTIiwiUkVOREVSX0xJU1QiLCJSRU5ERVJfU0xPVCIsIkNSRUFURV9TTE9UUyIsIlRPX0RJU1BMQVlfU1RSSU5HIiwiTUVSR0VfUFJPUFMiLCJUT19IQU5ETEVSUyIsIkNBTUVMSVpFIiwiQ0FQSVRBTElaRSIsIlRPX0hBTkRMRVJfS0VZIiwiU0VUX0JMT0NLX1RSQUNLSU5HIiwiUFVTSF9TQ09QRV9JRCIsIlBPUF9TQ09QRV9JRCIsIldJVEhfU0NPUEVfSUQiLCJXSVRIX0NUWCIsIlVOUkVGIiwiSVNfUkVGIiwiaGVscGVyTmFtZU1hcCIsInJlZ2lzdGVyUnVudGltZUhlbHBlcnMiLCJoZWxwZXJzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZm9yRWFjaCIsInMiLCJsb2NTdHViIiwic291cmNlIiwic3RhcnQiLCJsaW5lIiwiY29sdW1uIiwib2Zmc2V0IiwiZW5kIiwiY3JlYXRlUm9vdCIsImNoaWxkcmVuIiwidHlwZSIsImNvbXBvbmVudHMiLCJkaXJlY3RpdmVzIiwiaG9pc3RzIiwiaW1wb3J0cyIsImNhY2hlZCIsInRlbXBzIiwiY29kZWdlbk5vZGUiLCJ1bmRlZmluZWQiLCJjcmVhdGVWTm9kZUNhbGwiLCJjb250ZXh0IiwidGFnIiwicHJvcHMiLCJwYXRjaEZsYWciLCJkeW5hbWljUHJvcHMiLCJpc0Jsb2NrIiwiZGlzYWJsZVRyYWNraW5nIiwiaGVscGVyIiwiY3JlYXRlQXJyYXlFeHByZXNzaW9uIiwiZWxlbWVudHMiLCJjcmVhdGVPYmplY3RFeHByZXNzaW9uIiwicHJvcGVydGllcyIsImNyZWF0ZU9iamVjdFByb3BlcnR5Iiwia2V5IiwidmFsdWUiLCJpc1N0cmluZyIsImNyZWF0ZVNpbXBsZUV4cHJlc3Npb24iLCJjb250ZW50IiwiaXNTdGF0aWMiLCJjb25zdFR5cGUiLCJjcmVhdGVJbnRlcnBvbGF0aW9uIiwiY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uIiwiY3JlYXRlQ2FsbEV4cHJlc3Npb24iLCJjYWxsZWUiLCJhcmdzIiwiYXJndW1lbnRzIiwiY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uIiwicGFyYW1zIiwicmV0dXJucyIsIm5ld2xpbmUiLCJpc1Nsb3QiLCJjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24iLCJ0ZXN0IiwiY29uc2VxdWVudCIsImFsdGVybmF0ZSIsImNyZWF0ZUNhY2hlRXhwcmVzc2lvbiIsImluZGV4IiwiaXNWTm9kZSIsImNyZWF0ZUJsb2NrU3RhdGVtZW50IiwiYm9keSIsImNyZWF0ZVRlbXBsYXRlTGl0ZXJhbCIsImNyZWF0ZUlmU3RhdGVtZW50IiwiY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24iLCJsZWZ0IiwicmlnaHQiLCJjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24iLCJleHByZXNzaW9ucyIsImNyZWF0ZVJldHVyblN0YXRlbWVudCIsImlzU3RhdGljRXhwIiwicCIsImlzQnVpbHRJblR5cGUiLCJleHBlY3RlZCIsImh5cGhlbmF0ZSIsImlzQ29yZUNvbXBvbmVudCIsIm5vbklkZW50aWZpZXJSRSIsImlzU2ltcGxlSWRlbnRpZmllciIsIm5hbWUiLCJtZW1iZXJFeHBSRSIsImlzTWVtYmVyRXhwcmVzc2lvbiIsInBhdGgiLCJtYXRjaGVkIiwiZXhlYyIsInRyaW0iLCJnZXRJbm5lclJhbmdlIiwibGVuZ3RoIiwic3Vic3RyIiwibmV3TG9jIiwiYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lIiwicG9zIiwibnVtYmVyT2ZDaGFyYWN0ZXJzIiwiYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uIiwiZXh0ZW5kIiwibGluZXNDb3VudCIsImxhc3ROZXdMaW5lUG9zIiwiaSIsImNoYXJDb2RlQXQiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJFcnJvciIsImZpbmREaXIiLCJub2RlIiwiYWxsb3dFbXB0eSIsImV4cCIsImZpbmRQcm9wIiwiZHluYW1pY09ubHkiLCJpc0JpbmRLZXkiLCJhcmciLCJoYXNEeW5hbWljS2V5VkJpbmQiLCJzb21lIiwiaXNUZXh0IiwiaXNWU2xvdCIsImlzVGVtcGxhdGVOb2RlIiwidGFnVHlwZSIsImlzU2xvdE91dGxldCIsImluamVjdFByb3AiLCJwcm9wIiwicHJvcHNXaXRoSW5qZWN0aW9uIiwiZmlyc3QiLCJ1bnNoaWZ0IiwiYWxyZWFkeUV4aXN0cyIsInByb3BLZXlOYW1lIiwidG9WYWxpZEFzc2V0SWQiLCJyZXBsYWNlIiwiaGFzU2NvcGVSZWYiLCJpZHMiLCJrZXlzIiwiYyIsImJyYW5jaGVzIiwiYiIsImlzT2JqZWN0IiwiZGVwcmVjYXRpb25EYXRhIiwibGluayIsImdldENvbXBhdFZhbHVlIiwiY29uZmlnIiwib3B0aW9ucyIsImNvbXBhdENvbmZpZyIsImlzQ29tcGF0RW5hYmxlZCIsIm1vZGUiLCJjaGVja0NvbXBhdEVuYWJsZWQiLCJlbmFibGVkIiwid2FybkRlcHJlY2F0aW9uIiwidmFsIiwiZXJyIiwib25XYXJuIiwiZGVjb2RlUkUiLCJkZWNvZGVNYXAiLCJndCIsImx0IiwiYW1wIiwiYXBvcyIsInF1b3QiLCJkZWZhdWx0UGFyc2VyT3B0aW9ucyIsImRlbGltaXRlcnMiLCJnZXROYW1lc3BhY2UiLCJnZXRUZXh0TW9kZSIsImlzVm9pZFRhZyIsIk5PIiwiaXNQcmVUYWciLCJpc0N1c3RvbUVsZW1lbnQiLCJkZWNvZGVFbnRpdGllcyIsInJhd1RleHQiLCJfIiwicDEiLCJvbkVycm9yIiwiY29tbWVudHMiLCJiYXNlUGFyc2UiLCJjcmVhdGVQYXJzZXJDb250ZXh0IiwiZ2V0Q3Vyc29yIiwicGFyc2VDaGlsZHJlbiIsImdldFNlbGVjdGlvbiIsInJhd09wdGlvbnMiLCJvcmlnaW5hbFNvdXJjZSIsImluUHJlIiwiaW5WUHJlIiwiYW5jZXN0b3JzIiwicGFyZW50IiwibGFzdCIsIm5zIiwibm9kZXMiLCJpc0VuZCIsInN0YXJ0c1dpdGgiLCJwYXJzZUludGVycG9sYXRpb24iLCJlbWl0RXJyb3IiLCJwYXJzZUNvbW1lbnQiLCJwYXJzZUJvZ3VzQ29tbWVudCIsInBhcnNlQ0RBVEEiLCJhZHZhbmNlQnkiLCJwYXJzZVRhZyIsInBhcnNlRWxlbWVudCIsImlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlIiwicGFyc2VUZXh0IiwiaXNBcnJheSIsInB1c2hOb2RlIiwicmVtb3ZlZFdoaXRlc3BhY2UiLCJwcmVzZXJ2ZSIsIndoaXRlc3BhY2UiLCJwcmV2IiwibmV4dCIsImZpbHRlciIsIkJvb2xlYW4iLCJwdXNoIiwibWF0Y2giLCJzbGljZSIsInByZXZJbmRleCIsIm5lc3RlZEluZGV4IiwiaW5kZXhPZiIsImNvbnRlbnRTdGFydCIsImNsb3NlSW5kZXgiLCJ3YXNJblByZSIsIndhc0luVlByZSIsImVsZW1lbnQiLCJpc1ByZUJvdW5kYXJ5IiwiaXNWUHJlQm91bmRhcnkiLCJpc1NlbGZDbG9zaW5nIiwicG9wIiwiaW5saW5lVGVtcGxhdGVQcm9wIiwiZmluZCIsInN0YXJ0c1dpdGhFbmRUYWdPcGVuIiwidG9Mb3dlckNhc2UiLCJtYWtlTWFwIiwiYWR2YW5jZVNwYWNlcyIsImN1cnNvciIsImN1cnJlbnRTb3VyY2UiLCJwYXJzZUF0dHJpYnV0ZXMiLCJoYXNJZiIsImhhc0ZvciIsImhhc1ZJcyIsImlzTmF0aXZlVGFnIiwiaXNCdWlsdEluQ29tcG9uZW50IiwiYXR0cmlidXRlTmFtZXMiLCJTZXQiLCJhdHRyIiwicGFyc2VBdHRyaWJ1dGUiLCJuYW1lU2V0IiwiaGFzIiwiYWRkIiwicGF0dGVybiIsIm0iLCJwYXJzZUF0dHJpYnV0ZVZhbHVlIiwiZGlyTmFtZSIsInN0YXJ0T2Zmc2V0IiwibGFzdEluZGV4T2YiLCJnZXROZXdQb3NpdGlvbiIsImVuZHNXaXRoIiwiaXNRdW90ZWQiLCJ2YWx1ZUxvYyIsIm1vZGlmaWVycyIsInNwbGl0IiwiaW5jbHVkZXMiLCJzcGxpY2UiLCJxdW90ZSIsImVuZEluZGV4IiwicGFyc2VUZXh0RGF0YSIsInVuZXhwZWN0ZWRDaGFycyIsIm9wZW4iLCJjbG9zZSIsImlubmVyU3RhcnQiLCJpbm5lckVuZCIsInJhd0NvbnRlbnRMZW5ndGgiLCJyYXdDb250ZW50IiwicHJlVHJpbUNvbnRlbnQiLCJlbmRPZmZzZXQiLCJlbmRUb2tlbnMiLCJ4cyIsInNlYXJjaFN0cmluZyIsImhvaXN0U3RhdGljIiwicm9vdCIsIndhbGsiLCJpc1NpbmdsZUVsZW1lbnRSb290IiwiY2hpbGQiLCJkb05vdEhvaXN0Tm9kZSIsImhhc0hvaXN0ZWROb2RlIiwiY2FuU3RyaW5naWZ5IiwiY29uc3RhbnRUeXBlIiwiZ2V0Q29uc3RhbnRUeXBlIiwiaG9pc3QiLCJmbGFnIiwiZ2V0UGF0Y2hGbGFnIiwiZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUiLCJnZXROb2RlUHJvcHMiLCJjb250ZW50VHlwZSIsImlzQ29tcG9uZW50Iiwic2NvcGVzIiwidlNsb3QiLCJ0cmFuc2Zvcm1Ib2lzdCIsImNvbnN0YW50Q2FjaGUiLCJnZXQiLCJyZXR1cm5UeXBlIiwiZ2VuZXJhdGVkUHJvcHNUeXBlIiwic2V0IiwiY2hpbGRUeXBlIiwiZXhwVHlwZSIsInJlbW92ZUhlbHBlciIsImlzU3ltYm9sIiwia2V5VHlwZSIsInZhbHVlVHlwZSIsInBhcnNlSW50IiwiY3JlYXRlVHJhbnNmb3JtQ29udGV4dCIsImZpbGVuYW1lIiwicHJlZml4SWRlbnRpZmllcnMiLCJjYWNoZUhhbmRsZXJzIiwibm9kZVRyYW5zZm9ybXMiLCJkaXJlY3RpdmVUcmFuc2Zvcm1zIiwiTk9PUCIsImV4cHJlc3Npb25QbHVnaW5zIiwic2NvcGVJZCIsInNsb3R0ZWQiLCJzc3IiLCJzc3JDc3NWYXJzIiwiYmluZGluZ01ldGFkYXRhIiwiRU1QVFlfT0JKIiwiaW5saW5lIiwiaXNUUyIsIm5hbWVNYXRjaCIsInNlbGZOYW1lIiwiY2FwaXRhbGl6ZSIsImNhbWVsaXplJDEiLCJNYXAiLCJpZGVudGlmaWVycyIsImNyZWF0ZSIsInZGb3IiLCJ2UHJlIiwidk9uY2UiLCJjdXJyZW50Tm9kZSIsImNoaWxkSW5kZXgiLCJjb3VudCIsImN1cnJlbnRDb3VudCIsImRlbGV0ZSIsImhlbHBlclN0cmluZyIsInJlcGxhY2VOb2RlIiwicmVtb3ZlTm9kZSIsImxpc3QiLCJyZW1vdmFsSW5kZXgiLCJvbk5vZGVSZW1vdmVkIiwiYWRkSWRlbnRpZmllcnMiLCJyZW1vdmVJZGVudGlmaWVycyIsImlkZW50aWZpZXIiLCJob2lzdGVkIiwiY2FjaGUiLCJmaWx0ZXJzIiwidHJhbnNmb3JtIiwidHJhdmVyc2VOb2RlIiwiY3JlYXRlUm9vdENvZGVnZW4iLCJwYXRjaEZsYWdUZXh0IiwiUGF0Y2hGbGFnTmFtZXMiLCJ0cmF2ZXJzZUNoaWxkcmVuIiwibm9kZVJlbW92ZWQiLCJleGl0Rm5zIiwib25FeGl0IiwiY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSIsImZuIiwibWF0Y2hlcyIsIm4iLCJQVVJFX0FOTk9UQVRJT04iLCJjcmVhdGVDb2RlZ2VuQ29udGV4dCIsImFzdCIsInNvdXJjZU1hcCIsIm9wdGltaXplSW1wb3J0cyIsInJ1bnRpbWVHbG9iYWxOYW1lIiwicnVudGltZU1vZHVsZU5hbWUiLCJpbmRlbnRMZXZlbCIsInB1cmUiLCJtYXAiLCJpbmRlbnQiLCJkZWluZGVudCIsIndpdGhvdXROZXdMaW5lIiwicmVwZWF0IiwiZ2VuZXJhdGUiLCJvbkNvbnRleHRDcmVhdGVkIiwiaGFzSGVscGVycyIsInVzZVdpdGhCbG9jayIsInByZWFtYmxlQ29udGV4dCIsImdlbkZ1bmN0aW9uUHJlYW1ibGUiLCJmdW5jdGlvbk5hbWUiLCJzaWduYXR1cmUiLCJqb2luIiwiZ2VuQXNzZXRzIiwiZ2VuTm9kZSIsInByZWFtYmxlIiwidG9KU09OIiwiVnVlQmluZGluZyIsImFsaWFzSGVscGVyIiwic3RhdGljSGVscGVycyIsImdlbkhvaXN0cyIsImFzc2V0cyIsInJlc29sdmVyIiwiaWQiLCJtYXliZVNlbGZSZWZlcmVuY2UiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNUZXh0JDEiLCJnZW5Ob2RlTGlzdEFzQXJyYXkiLCJtdWx0aWxpbmVzIiwiZ2VuTm9kZUxpc3QiLCJjb21tYSIsImdlblRleHQiLCJnZW5FeHByZXNzaW9uIiwiZ2VuSW50ZXJwb2xhdGlvbiIsImdlbkNvbXBvdW5kRXhwcmVzc2lvbiIsImdlbkNvbW1lbnQiLCJnZW5WTm9kZUNhbGwiLCJnZW5DYWxsRXhwcmVzc2lvbiIsImdlbk9iamVjdEV4cHJlc3Npb24iLCJnZW5BcnJheUV4cHJlc3Npb24iLCJnZW5GdW5jdGlvbkV4cHJlc3Npb24iLCJnZW5Db25kaXRpb25hbEV4cHJlc3Npb24iLCJnZW5DYWNoZUV4cHJlc3Npb24iLCJleGhhdXN0aXZlQ2hlY2siLCJnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleSIsInRleHQiLCJnZW5OdWxsYWJsZUFyZ3MiLCJpc05vblNjb3BlZFNsb3QiLCJuZWVkTmV3bGluZSIsIm5lZWRzUGFyZW5zIiwiaXNOZXN0ZWQiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwiUmVnRXhwIiwic3RyaXBTdHJpbmdSRSIsInZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24iLCJhc1BhcmFtcyIsImFzUmF3U3RhdGVtZW50cyIsIkZ1bmN0aW9uIiwiZSIsImtleXdvcmRNYXRjaCIsInRyYW5zZm9ybUV4cHJlc3Npb24iLCJwcm9jZXNzRXhwcmVzc2lvbiIsImRpciIsInRyYW5zZm9ybUlmIiwicHJvY2Vzc0lmIiwiaWZOb2RlIiwiYnJhbmNoIiwiaXNSb290Iiwic2libGluZ3MiLCJzaWJsaW5nIiwiY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2giLCJwYXJlbnRDb25kaXRpb24iLCJnZXRQYXJlbnRDb25kaXRpb24iLCJwcm9jZXNzQ29kZWdlbiIsImNyZWF0ZUlmQnJhbmNoIiwidXNlcktleSIsImlzU2FtZUtleSIsImtleUluZGV4IiwiY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZSIsImtleVByb3BlcnR5IiwiZmlyc3RDaGlsZCIsIm5lZWRGcmFnbWVudFdyYXBwZXIiLCJ2bm9kZUNhbGwiLCJhIiwiYnJhbmNoRXhwIiwidHJhbnNmb3JtRm9yIiwicHJvY2Vzc0ZvciIsImZvck5vZGUiLCJyZW5kZXJFeHAiLCJrZXlQcm9wIiwiaXNTdGFibGVGcmFnbWVudCIsImZyYWdtZW50RmxhZyIsImNoaWxkQmxvY2siLCJpc1RlbXBsYXRlIiwic2xvdE91dGxldCIsImNyZWF0ZUZvckxvb3BQYXJhbXMiLCJwYXJzZVJlc3VsdCIsInBhcnNlRm9yRXhwcmVzc2lvbiIsInZhbHVlQWxpYXMiLCJrZXlBbGlhcyIsIm9iamVjdEluZGV4QWxpYXMiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJpbnB1dCIsImluTWF0Y2giLCJMSFMiLCJSSFMiLCJyZXN1bHQiLCJjcmVhdGVBbGlhc0V4cHJlc3Npb24iLCJ2YWx1ZUNvbnRlbnQiLCJ0cmltbWVkT2Zmc2V0IiwiaXRlcmF0b3JNYXRjaCIsImtleUNvbnRlbnQiLCJrZXlPZmZzZXQiLCJpbmRleENvbnRlbnQiLCJyYW5nZSIsImRlZmF1bHRGYWxsYmFjayIsInRyYWNrU2xvdFNjb3BlcyIsInRyYWNrVkZvclNsb3RTY29wZXMiLCJidWlsZENsaWVudFNsb3RGbiIsImJ1aWxkU2xvdHMiLCJidWlsZFNsb3RGbiIsInNsb3RzUHJvcGVydGllcyIsImR5bmFtaWNTbG90cyIsImhhc0R5bmFtaWNTbG90cyIsIm9uQ29tcG9uZW50U2xvdCIsImhhc1RlbXBsYXRlU2xvdHMiLCJoYXNOYW1lZERlZmF1bHRTbG90IiwiaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4iLCJzZWVuU2xvdE5hbWVzIiwic2xvdEVsZW1lbnQiLCJzbG90RGlyIiwic2xvdENoaWxkcmVuIiwic2xvdExvYyIsInNsb3ROYW1lIiwic2xvdFByb3BzIiwiZGlyTG9jIiwic3RhdGljU2xvdE5hbWUiLCJzbG90RnVuY3Rpb24iLCJ2SWYiLCJ2RWxzZSIsImJ1aWxkRHluYW1pY1Nsb3QiLCJqIiwiY29uZGl0aW9uYWwiLCJidWlsZERlZmF1bHRTbG90UHJvcGVydHkiLCJpc05vbldoaXRlc3BhY2VDb250ZW50Iiwic2xvdEZsYWciLCJoYXNGb3J3YXJkZWRTbG90cyIsInNsb3RzIiwiY29uY2F0Iiwic2xvdEZsYWdzVGV4dCIsImRpcmVjdGl2ZUltcG9ydE1hcCIsIldlYWtNYXAiLCJ0cmFuc2Zvcm1FbGVtZW50IiwicG9zdFRyYW5zZm9ybUVsZW1lbnQiLCJ2bm9kZVRhZyIsInJlc29sdmVDb21wb25lbnRUeXBlIiwiaXNEeW5hbWljQ29tcG9uZW50Iiwidm5vZGVQcm9wcyIsInZub2RlQ2hpbGRyZW4iLCJ2bm9kZVBhdGNoRmxhZyIsInZub2RlRHluYW1pY1Byb3BzIiwiZHluYW1pY1Byb3BOYW1lcyIsInZub2RlRGlyZWN0aXZlcyIsInNob3VsZFVzZUJsb2NrIiwicHJvcHNCdWlsZFJlc3VsdCIsImJ1aWxkUHJvcHMiLCJidWlsZERpcmVjdGl2ZUFyZ3MiLCJzaG91bGRCdWlsZEFzU2xvdHMiLCJoYXNEeW5hbWljVGV4dENoaWxkIiwiZmxhZ05hbWVzIiwiTnVtYmVyIiwic3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyIsImlzRXhwbGljaXREeW5hbWljIiwiaXNDb21wb25lbnRUYWciLCJpc1Byb3AiLCJidWlsdEluIiwiZWxlbWVudExvYyIsIm1lcmdlQXJncyIsInJ1bnRpbWVEaXJlY3RpdmVzIiwiaGFzUmVmIiwiaGFzQ2xhc3NCaW5kaW5nIiwiaGFzU3R5bGVCaW5kaW5nIiwiaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nIiwiaGFzRHluYW1pY0tleXMiLCJoYXNWbm9kZUhvb2siLCJhbmFseXplUGF0Y2hGbGFnIiwiaXNFdmVudEhhbmRsZXIiLCJpc09uIiwiaXNSZXNlcnZlZFByb3AiLCJpc1ZCaW5kIiwiaXNWT24iLCJkZWR1cGVQcm9wZXJ0aWVzIiwiaGFzT3ZlcnJpZGFibGVLZXlzIiwiZGlyZWN0aXZlVHJhbnNmb3JtIiwibmVlZFJ1bnRpbWUiLCJwcm9wc0V4cHJlc3Npb24iLCJrbm93blByb3BzIiwiZGVkdXBlZCIsImV4aXN0aW5nIiwibWVyZ2VBc0FycmF5IiwiaW5jb21pbmciLCJkaXJBcmdzIiwicnVudGltZSIsInRydWVFeHByZXNzaW9uIiwibW9kaWZpZXIiLCJwcm9wc05hbWVzU3RyaW5nIiwibCIsImZyZWV6ZSIsImNhY2hlU3RyaW5nRnVuY3Rpb24iLCJzdHIiLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJ0b1VwcGVyQ2FzZSIsInRyYW5zZm9ybVNsb3RPdXRsZXQiLCJwcm9jZXNzU2xvdE91dGxldCIsInNsb3RBcmdzIiwibm9uTmFtZVByb3BzIiwiZm5FeHBSRSIsInRyYW5zZm9ybU9uIiwiYXVnbWVudG9yIiwiZXZlbnROYW1lIiwicmF3TmFtZSIsInRvSGFuZGxlcktleSIsInNob3VsZENhY2hlIiwiaXNNZW1iZXJFeHAiLCJpc0lubGluZVN0YXRlbWVudCIsImhhc011bHRpcGxlU3RhdGVtZW50cyIsInJldCIsInRyYW5zZm9ybUJpbmQiLCJfbm9kZSIsInRyYW5zZm9ybVRleHQiLCJjdXJyZW50Q29udGFpbmVyIiwiaGFzVGV4dCIsImNhbGxBcmdzIiwic2VlbiIsIldlYWtTZXQiLCJ0cmFuc2Zvcm1PbmNlIiwiY3VyIiwidHJhbnNmb3JtTW9kZWwiLCJjcmVhdGVUcmFuc2Zvcm1Qcm9wcyIsInJhd0V4cCIsImV4cFN0cmluZyIsIm1heWJlUmVmIiwicHJvcE5hbWUiLCJhc3NpZ25tZW50RXhwIiwiZXZlbnRBcmciLCJtb2RpZmllcnNLZXkiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwidHJhbnNmb3JtRmlsdGVyIiwicmV3cml0ZUZpbHRlciIsInBhcnNlRmlsdGVyIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsImV4cHJlc3Npb24iLCJwdXNoRmlsdGVyIiwiY2hhckF0Iiwid3JhcEZpbHRlciIsImdldEJhc2VUcmFuc2Zvcm1QcmVzZXQiLCJvbiIsImJpbmQiLCJtb2RlbCIsImJhc2VDb21waWxlIiwidGVtcGxhdGUiLCJpc01vZHVsZU1vZGUiLCJub29wRGlyZWN0aXZlVHJhbnNmb3JtIiwiVl9NT0RFTF9SQURJTyIsIlZfTU9ERUxfQ0hFQ0tCT1giLCJWX01PREVMX1RFWFQiLCJWX01PREVMX1NFTEVDVCIsIlZfTU9ERUxfRFlOQU1JQyIsIlZfT05fV0lUSF9NT0RJRklFUlMiLCJWX09OX1dJVEhfS0VZUyIsIlZfU0hPVyIsIlRSQU5TSVRJT04iLCJUUkFOU0lUSU9OX0dST1VQIiwiZGVjb2RlciIsImRlY29kZUh0bWxCcm93c2VyIiwicmF3IiwiYXNBdHRyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiZ2V0QXR0cmlidXRlIiwidGV4dENvbnRlbnQiLCJpc1Jhd1RleHRDb250YWluZXIiLCJwYXJzZXJPcHRpb25zIiwiaXNIVE1MVGFnIiwiaXNTVkdUYWciLCJ0cmFuc2Zvcm1TdHlsZSIsInBhcnNlSW5saW5lQ1NTIiwiY3NzVGV4dCIsIm5vcm1hbGl6ZWQiLCJwYXJzZVN0cmluZ1N0eWxlIiwiY3JlYXRlRE9NQ29tcGlsZXJFcnJvciIsIkRPTUVycm9yTWVzc2FnZXMiLCJ0cmFuc2Zvcm1WSHRtbCIsInRyYW5zZm9ybVZUZXh0IiwiYmFzZVJlc3VsdCIsInRyYW5zZm9ybU1vZGVsJDEiLCJjaGVja0R1cGxpY2F0ZWRWYWx1ZSIsImRpcmVjdGl2ZVRvVXNlIiwiaXNJbnZhbGlkVHlwZSIsImlzRXZlbnRPcHRpb25Nb2RpZmllciIsImlzTm9uS2V5TW9kaWZpZXIiLCJtYXliZUtleU1vZGlmaWVyIiwiaXNLZXlib2FyZEV2ZW50IiwicmVzb2x2ZU1vZGlmaWVycyIsImtleU1vZGlmaWVycyIsIm5vbktleU1vZGlmaWVycyIsImV2ZW50T3B0aW9uTW9kaWZpZXJzIiwidHJhbnNmb3JtQ2xpY2siLCJldmVudCIsImlzU3RhdGljQ2xpY2siLCJ0cmFuc2Zvcm1PbiQxIiwiaGFuZGxlckV4cCIsIm1vZGlmaWVyUG9zdGZpeCIsInRyYW5zZm9ybVNob3ciLCJ3YXJuVHJhbnNpdGlvbkNoaWxkcmVuIiwiY29tcG9uZW50IiwiaGFzTXVsdGlwbGVDaGlsZHJlbiIsImlnbm9yZVNpZGVFZmZlY3RUYWdzIiwiRE9NTm9kZVRyYW5zZm9ybXMiLCJET01EaXJlY3RpdmVUcmFuc2Zvcm1zIiwiY2xvYWsiLCJodG1sIiwic2hvdyIsImNvbXBpbGUiLCJwYXJzZSIsInRhcmdldE1hcCIsImVmZmVjdFN0YWNrIiwiYWN0aXZlRWZmZWN0IiwiSVRFUkFURV9LRVkiLCJNQVBfS0VZX0lURVJBVEVfS0VZIiwiaXNFZmZlY3QiLCJfaXNFZmZlY3QiLCJlZmZlY3QiLCJjcmVhdGVSZWFjdGl2ZUVmZmVjdCIsImxhenkiLCJzdG9wIiwiYWN0aXZlIiwiY2xlYW51cCIsIm9uU3RvcCIsInVpZCIsInJlYWN0aXZlRWZmZWN0IiwiZW5hYmxlVHJhY2tpbmciLCJyZXNldFRyYWNraW5nIiwiYWxsb3dSZWN1cnNlIiwiZGVwcyIsInNob3VsZFRyYWNrIiwidHJhY2tTdGFjayIsInBhdXNlVHJhY2tpbmciLCJ0cmFjayIsInRhcmdldCIsImRlcHNNYXAiLCJkZXAiLCJvblRyYWNrIiwidHJpZ2dlciIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJvbGRUYXJnZXQiLCJlZmZlY3RzIiwiZWZmZWN0c1RvQWRkIiwiaXNNYXAiLCJpc0ludGVnZXJLZXkiLCJydW4iLCJvblRyaWdnZXIiLCJzY2hlZHVsZXIiLCJpc05vblRyYWNrYWJsZUtleXMiLCJidWlsdEluU3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJjcmVhdGVHZXR0ZXIiLCJzaGFsbG93R2V0IiwicmVhZG9ubHlHZXQiLCJzaGFsbG93UmVhZG9ubHlHZXQiLCJhcnJheUluc3RydW1lbnRhdGlvbnMiLCJtZXRob2QiLCJBcnJheSIsInByb3RvdHlwZSIsImFyciIsInRvUmF3IiwicmVzIiwiYXBwbHkiLCJpc1JlYWRvbmx5Iiwic2hhbGxvdyIsInJlY2VpdmVyIiwic2hhbGxvd1JlYWRvbmx5TWFwIiwicmVhZG9ubHlNYXAiLCJzaGFsbG93UmVhY3RpdmVNYXAiLCJyZWFjdGl2ZU1hcCIsInRhcmdldElzQXJyYXkiLCJoYXNPd24iLCJSZWZsZWN0IiwiaXNSZWYiLCJzaG91bGRVbndyYXAiLCJyZWFkb25seSIsInJlYWN0aXZlIiwiY3JlYXRlU2V0dGVyIiwic2hhbGxvd1NldCIsImhhZEtleSIsImhhc0NoYW5nZWQiLCJkZWxldGVQcm9wZXJ0eSIsIm93bktleXMiLCJtdXRhYmxlSGFuZGxlcnMiLCJyZWFkb25seUhhbmRsZXJzIiwic2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMiLCJzaGFsbG93UmVhZG9ubHlIYW5kbGVycyIsInRvUmVhY3RpdmUiLCJ0b1JlYWRvbmx5IiwidG9TaGFsbG93IiwiZ2V0UHJvdG8iLCJ2IiwiZ2V0UHJvdG90eXBlT2YiLCJnZXQkMSIsImlzU2hhbGxvdyIsInJhd1RhcmdldCIsInJhd0tleSIsIndyYXAiLCJjYWxsIiwiaGFzJDEiLCJzaXplIiwicHJvdG8iLCJzZXQkMSIsImNoZWNrSWRlbnRpdHlLZXlzIiwiZGVsZXRlRW50cnkiLCJjbGVhciIsImhhZEl0ZW1zIiwiY3JlYXRlRm9yRWFjaCIsImNhbGxiYWNrIiwidGhpc0FyZyIsIm9ic2VydmVkIiwiY3JlYXRlSXRlcmFibGVNZXRob2QiLCJ0YXJnZXRJc01hcCIsImlzUGFpciIsIml0ZXJhdG9yIiwiaXNLZXlPbmx5IiwiaW5uZXJJdGVyYXRvciIsImRvbmUiLCJjcmVhdGVSZWFkb25seU1ldGhvZCIsIm11dGFibGVJbnN0cnVtZW50YXRpb25zIiwic2hhbGxvd0luc3RydW1lbnRhdGlvbnMiLCJyZWFkb25seUluc3RydW1lbnRhdGlvbnMiLCJzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIiwiaXRlcmF0b3JNZXRob2RzIiwiY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyIiwiaW5zdHJ1bWVudGF0aW9ucyIsIm11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMiLCJzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzIiwicmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMiLCJzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMiLCJ0b1Jhd1R5cGUiLCJ0YXJnZXRUeXBlTWFwIiwicmF3VHlwZSIsImdldFRhcmdldFR5cGUiLCJpc0V4dGVuc2libGUiLCJjcmVhdGVSZWFjdGl2ZU9iamVjdCIsInNoYWxsb3dSZWFjdGl2ZSIsInNoYWxsb3dSZWFkb25seSIsImJhc2VIYW5kbGVycyIsImNvbGxlY3Rpb25IYW5kbGVycyIsInByb3h5TWFwIiwiZXhpc3RpbmdQcm94eSIsInRhcmdldFR5cGUiLCJwcm94eSIsIlByb3h5IiwiaXNSZWFjdGl2ZSIsImlzUHJveHkiLCJtYXJrUmF3IiwiZGVmIiwiY29udmVydCIsInIiLCJfX3ZfaXNSZWYiLCJyZWYiLCJjcmVhdGVSZWYiLCJzaGFsbG93UmVmIiwiUmVmSW1wbCIsIl9yYXdWYWx1ZSIsIl9zaGFsbG93IiwiX3ZhbHVlIiwibmV3VmFsIiwicmF3VmFsdWUiLCJ0cmlnZ2VyUmVmIiwidW5yZWYiLCJzaGFsbG93VW53cmFwSGFuZGxlcnMiLCJwcm94eVJlZnMiLCJvYmplY3RXaXRoUmVmcyIsIkN1c3RvbVJlZkltcGwiLCJmYWN0b3J5IiwiX2dldCIsIl9zZXQiLCJjdXN0b21SZWYiLCJ0b1JlZnMiLCJvYmplY3QiLCJ0b1JlZiIsIk9iamVjdFJlZkltcGwiLCJfb2JqZWN0IiwiX2tleSIsIkNvbXB1dGVkUmVmSW1wbCIsImdldHRlciIsIl9zZXR0ZXIiLCJfZGlydHkiLCJzZWxmIiwiY29tcHV0ZWQiLCJnZXR0ZXJPck9wdGlvbnMiLCJzZXR0ZXIiLCJpc0Z1bmN0aW9uIiwic3RhY2siLCJwdXNoV2FybmluZ0NvbnRleHQiLCJ2bm9kZSIsInBvcFdhcm5pbmdDb250ZXh0IiwiaW5zdGFuY2UiLCJhcHBXYXJuSGFuZGxlciIsImFwcENvbnRleHQiLCJ3YXJuSGFuZGxlciIsInRyYWNlIiwiZ2V0Q29tcG9uZW50VHJhY2UiLCJjYWxsV2l0aEVycm9ySGFuZGxpbmciLCJmb3JtYXRDb21wb25lbnROYW1lIiwid2FybkFyZ3MiLCJmb3JtYXRUcmFjZSIsImN1cnJlbnRWTm9kZSIsIm5vcm1hbGl6ZWRTdGFjayIsInJlY3Vyc2VDb3VudCIsInBhcmVudEluc3RhbmNlIiwibG9ncyIsImVudHJ5IiwiZm9ybWF0VHJhY2VFbnRyeSIsInBvc3RmaXgiLCJmb3JtYXRQcm9wcyIsImZvcm1hdFByb3AiLCJFcnJvclR5cGVTdHJpbmdzIiwiaGFuZGxlRXJyb3IiLCJjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyIsImlzUHJvbWlzZSIsImNhdGNoIiwidmFsdWVzIiwidGhyb3dJbkRldiIsImNvbnRleHRWTm9kZSIsImV4cG9zZWRJbnN0YW5jZSIsImVycm9ySW5mbyIsImVycm9yQ2FwdHVyZWRIb29rcyIsImVjIiwiYXBwRXJyb3JIYW5kbGVyIiwiZXJyb3JIYW5kbGVyIiwibG9nRXJyb3IiLCJpbmZvIiwiaXNGbHVzaGluZyIsImlzRmx1c2hQZW5kaW5nIiwicXVldWUiLCJmbHVzaEluZGV4IiwicGVuZGluZ1ByZUZsdXNoQ2JzIiwiYWN0aXZlUHJlRmx1c2hDYnMiLCJwcmVGbHVzaEluZGV4IiwicGVuZGluZ1Bvc3RGbHVzaENicyIsImFjdGl2ZVBvc3RGbHVzaENicyIsInBvc3RGbHVzaEluZGV4IiwicmVzb2x2ZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjdXJyZW50Rmx1c2hQcm9taXNlIiwiY3VycmVudFByZUZsdXNoUGFyZW50Sm9iIiwiUkVDVVJTSU9OX0xJTUlUIiwibmV4dFRpY2siLCJ0aGVuIiwiZmluZEluc2VydGlvbkluZGV4Iiwiam9iIiwiam9iSWQiLCJnZXRJZCIsIm1pZGRsZSIsIm1pZGRsZUpvYklkIiwicXVldWVKb2IiLCJxdWV1ZUZsdXNoIiwiZmx1c2hKb2JzIiwiaW52YWxpZGF0ZUpvYiIsInF1ZXVlQ2IiLCJjYiIsImFjdGl2ZVF1ZXVlIiwicGVuZGluZ1F1ZXVlIiwicXVldWVQcmVGbHVzaENiIiwicXVldWVQb3N0Rmx1c2hDYiIsImZsdXNoUHJlRmx1c2hDYnMiLCJwYXJlbnRKb2IiLCJjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMiLCJmbHVzaFBvc3RGbHVzaENicyIsInNvcnQiLCJJbmZpbml0eSIsIm93bmVySW5zdGFuY2UiLCJjb21wb25lbnROYW1lIiwiZ2V0Q29tcG9uZW50TmFtZSIsImlzSG1yVXBkYXRpbmciLCJobXJEaXJ0eUNvbXBvbmVudHMiLCJnbG9iYWxPYmplY3QiLCJnbG9iYWwiLCJ3aW5kb3ciLCJfX1ZVRV9ITVJfUlVOVElNRV9fIiwiY3JlYXRlUmVjb3JkIiwidHJ5V3JhcCIsInJlcmVuZGVyIiwicmVsb2FkIiwicmVnaXN0ZXJITVIiLCJfX2htcklkIiwicmVjb3JkIiwiaW5zdGFuY2VzIiwidW5yZWdpc3RlckhNUiIsImlzQ2xhc3NDb21wb25lbnQiLCJfX3ZjY09wdHMiLCJuZXdSZW5kZXIiLCJyZW5kZXIiLCJmcm9tIiwicmVuZGVyQ2FjaGUiLCJ1cGRhdGUiLCJuZXdDb21wIiwibG9jYXRpb24iLCJkZXZ0b29scyIsInNldERldnRvb2xzSG9vayIsImhvb2siLCJkZXZ0b29sc0luaXRBcHAiLCJhcHAiLCJ2ZXJzaW9uIiwiZW1pdCIsIkZyYWdtZW50IiwiVGV4dCIsIkNvbW1lbnQiLCJDb21tZW50JDEiLCJTdGF0aWMiLCJkZXZ0b29sc1VubW91bnRBcHAiLCJkZXZ0b29sc0NvbXBvbmVudEFkZGVkIiwiY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rIiwiZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkIiwiZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkIiwiZGV2dG9vbHNQZXJmU3RhcnQiLCJjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayIsImRldnRvb2xzUGVyZkVuZCIsInRpbWUiLCJkZXZ0b29sc0NvbXBvbmVudEVtaXQiLCJpc1J1bnRpbWVPbmx5IiwibGVnYWN5SG9vayIsIm5ld0hvb2siLCJjb2VyY2VkIiwiY29tcCIsImNvbmZpZ01zZyIsImluc3RhbmNlV2FybmVkIiwid2FybkNvdW50IiwiZ2V0Q3VycmVudEluc3RhbmNlIiwiZ2V0Q29tcGF0Q29uZmlnRm9yS2V5IiwiZHVwS2V5IiwiY29tcElkIiwiY29tcG9uZW50RHVwS2V5IiwiZ2xvYmFsQ29tcGF0Q29uZmlnIiwiTU9ERSIsImluc3RhbmNlQ29uZmlnIiwiZW5hYmxlRm9yQnVpbHRJbiIsIl9faXNCdWlsdEluIiwicmF3TW9kZSIsInJhd0FyZ3MiLCJlbWl0c09wdGlvbnMiLCJwcm9wc09wdGlvbnMiLCJ2YWxpZGF0b3IiLCJpc1ZhbGlkIiwiaXNNb2RlbExpc3RlbmVyIiwibW9kZWxBcmciLCJudW1iZXIiLCJ0b051bWJlciIsImxvd2VyQ2FzZUV2ZW50IiwiaGFuZGxlck5hbWUiLCJoYW5kbGVyIiwib25jZUhhbmRsZXIiLCJlbWl0dGVkIiwibm9ybWFsaXplRW1pdHNPcHRpb25zIiwiYXNNaXhpbiIsImVtaXRzQ2FjaGUiLCJlbWl0cyIsImhhc0V4dGVuZHMiLCJfX1ZVRV9PUFRJT05TX0FQSV9fIiwiZXh0ZW5kRW1pdHMiLCJub3JtYWxpemVkRnJvbUV4dGVuZCIsIm1peGlucyIsImV4dGVuZHMiLCJpc0VtaXRMaXN0ZW5lciIsImN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsImN1cnJlbnRTY29wZUlkIiwic2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlIiwiX19zY29wZUlkIiwicHVzaFNjb3BlSWQiLCJwb3BTY29wZUlkIiwid2l0aFNjb3BlSWQiLCJfaWQiLCJ3aXRoQ3R4IiwiY3R4IiwiX24iLCJyZW5kZXJGbldpdGhDb250ZXh0IiwiX2QiLCJzZXRCbG9ja1RyYWNraW5nIiwicHJldkluc3RhbmNlIiwiX2MiLCJhY2Nlc3NlZEF0dHJzIiwibWFya0F0dHJzQWNjZXNzZWQiLCJyZW5kZXJDb21wb25lbnRSb290IiwiQ29tcG9uZW50Iiwid2l0aFByb3h5IiwiYXR0cnMiLCJkYXRhIiwic2V0dXBTdGF0ZSIsImluaGVyaXRBdHRycyIsImZhbGx0aHJvdWdoQXR0cnMiLCJzaGFwZUZsYWciLCJwcm94eVRvVXNlIiwibm9ybWFsaXplVk5vZGUiLCJnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2giLCJzZXRSb290IiwiZ2V0Q2hpbGRSb290IiwiZmlsdGVyTW9kZWxMaXN0ZW5lcnMiLCJjbG9uZVZOb2RlIiwiYWxsQXR0cnMiLCJldmVudEF0dHJzIiwiZXh0cmFBdHRycyIsImRpcnMiLCJpc0VsZW1lbnRSb290IiwidHJhbnNpdGlvbiIsImJsb2NrU3RhY2siLCJjcmVhdGVWTm9kZSIsInJhd0NoaWxkcmVuIiwiZHluYW1pY0NoaWxkcmVuIiwiY2hpbGRSb290IiwiZmlsdGVyU2luZ2xlUm9vdCIsImR5bmFtaWNJbmRleCIsInVwZGF0ZWRSb290Iiwic2luZ2xlUm9vdCIsInNob3VsZFVwZGF0ZUNvbXBvbmVudCIsInByZXZWTm9kZSIsIm5leHRWTm9kZSIsIm9wdGltaXplZCIsInByZXZQcm9wcyIsInByZXZDaGlsZHJlbiIsIm5leHRQcm9wcyIsIm5leHRDaGlsZHJlbiIsImhhc1Byb3BzQ2hhbmdlZCIsIiRzdGFibGUiLCJuZXh0S2V5cyIsInVwZGF0ZUhPQ0hvc3RFbCIsImVsIiwic3ViVHJlZSIsImlzU3VzcGVuc2UiLCJfX2lzU3VzcGVuc2UiLCJTdXNwZW5zZUltcGwiLCJuMSIsIm4yIiwiY29udGFpbmVyIiwiYW5jaG9yIiwicGFyZW50Q29tcG9uZW50IiwicGFyZW50U3VzcGVuc2UiLCJpc1NWRyIsInNsb3RTY29wZUlkcyIsInJlbmRlcmVySW50ZXJuYWxzIiwibW91bnRTdXNwZW5zZSIsInBhdGNoU3VzcGVuc2UiLCJoeWRyYXRlIiwiaHlkcmF0ZVN1c3BlbnNlIiwiY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSIsIm5vcm1hbGl6ZSIsIm5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4iLCJTdXNwZW5zZSIsInBhdGNoIiwibyIsImhpZGRlbkNvbnRhaW5lciIsInN1c3BlbnNlIiwicGVuZGluZ0JyYW5jaCIsInNzQ29udGVudCIsInNzRmFsbGJhY2siLCJzZXRBY3RpdmVCcmFuY2giLCJ1bm1vdW50IiwidW0iLCJuZXdCcmFuY2giLCJuZXdGYWxsYmFjayIsImFjdGl2ZUJyYW5jaCIsImlzSW5GYWxsYmFjayIsImlzSHlkcmF0aW5nIiwiaXNTYW1lVk5vZGVUeXBlIiwicGVuZGluZ0lkIiwib25QZW5kaW5nIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJmYWxsYmFjayIsImhhc1dhcm5lZCIsIm1vdmUiLCJwYXJlbnROb2RlIiwicmVtb3ZlIiwiaXNVbm1vdW50ZWQiLCJyZXN1bWUiLCJkZWxheUVudGVyIiwiYWZ0ZXJMZWF2ZSIsImhhc1VucmVzb2x2ZWRBbmNlc3RvciIsIm9uUmVzb2x2ZSIsImZhbGxiYWNrVk5vZGUiLCJvbkZhbGxiYWNrIiwibW91bnRGYWxsYmFjayIsInJlZ2lzdGVyRGVwIiwic2V0dXBSZW5kZXJFZmZlY3QiLCJpc0luUGVuZGluZ1N1c3BlbnNlIiwiaHlkcmF0ZWRFbCIsImFzeW5jRGVwIiwiYXN5bmNTZXR1cFJlc3VsdCIsInN1c3BlbnNlSWQiLCJhc3luY1Jlc29sdmVkIiwiaGFuZGxlU2V0dXBSZXN1bHQiLCJwbGFjZWhvbGRlciIsImRvUmVtb3ZlIiwiaHlkcmF0ZU5vZGUiLCJpc1Nsb3RDaGlsZHJlbiIsIm5vcm1hbGl6ZVN1c3BlbnNlU2xvdCIsImRlZmF1bHQiLCJibG9jayIsImlzQ29tcGlsZWRTbG90Iiwib3BlbkJsb2NrIiwiY3VycmVudEJsb2NrIiwiY2xvc2VCbG9jayIsInNpbmdsZUNoaWxkIiwicXVldWVFZmZlY3RXaXRoU3VzcGVuc2UiLCJwcm92aWRlIiwiY3VycmVudEluc3RhbmNlIiwicHJvdmlkZXMiLCJwYXJlbnRQcm92aWRlcyIsImluamVjdCIsImRlZmF1bHRWYWx1ZSIsInRyZWF0RGVmYXVsdEFzRmFjdG9yeSIsIndhdGNoRWZmZWN0IiwiZG9XYXRjaCIsIklOSVRJQUxfV0FUQ0hFUl9WQUxVRSIsIndhdGNoIiwiaW1tZWRpYXRlIiwiZGVlcCIsImZsdXNoIiwid2FybkludmFsaWRTb3VyY2UiLCJmb3JjZVRyaWdnZXIiLCJpc011bHRpU291cmNlIiwidHJhdmVyc2UiLCJvbkludmFsaWRhdGUiLCJiYXNlR2V0dGVyIiwicnVubmVyIiwicXVldWVQb3N0UmVuZGVyRWZmZWN0IiwiaXNNb3VudGVkIiwicmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdCIsImluc3RhbmNlV2F0Y2giLCJwdWJsaWNUaGlzIiwiY3JlYXRlUGF0aEdldHRlciIsInNlZ21lbnRzIiwiaXNTZXQiLCJpc1BsYWluT2JqZWN0IiwidXNlVHJhbnNpdGlvblN0YXRlIiwic3RhdGUiLCJpc0xlYXZpbmciLCJpc1VubW91bnRpbmciLCJsZWF2aW5nVk5vZGVzIiwib25Nb3VudGVkIiwib25CZWZvcmVVbm1vdW50IiwiVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IiLCJCYXNlVHJhbnNpdGlvbkltcGwiLCJhcHBlYXIiLCJwZXJzaXN0ZWQiLCJvbkJlZm9yZUVudGVyIiwib25FbnRlciIsIm9uQWZ0ZXJFbnRlciIsIm9uRW50ZXJDYW5jZWxsZWQiLCJvbkJlZm9yZUxlYXZlIiwib25MZWF2ZSIsIm9uQWZ0ZXJMZWF2ZSIsIm9uTGVhdmVDYW5jZWxsZWQiLCJvbkJlZm9yZUFwcGVhciIsIm9uQXBwZWFyIiwib25BZnRlckFwcGVhciIsIm9uQXBwZWFyQ2FuY2VsbGVkIiwic2V0dXAiLCJwcmV2VHJhbnNpdGlvbktleSIsImdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiIsInJhd1Byb3BzIiwiZW1wdHlQbGFjZWhvbGRlciIsImlubmVyQ2hpbGQiLCJnZXRLZWVwQWxpdmVDaGlsZCIsImVudGVySG9va3MiLCJyZXNvbHZlVHJhbnNpdGlvbkhvb2tzIiwic2V0VHJhbnNpdGlvbkhvb2tzIiwib2xkQ2hpbGQiLCJvbGRJbm5lckNoaWxkIiwidHJhbnNpdGlvbktleUNoYW5nZWQiLCJnZXRUcmFuc2l0aW9uS2V5IiwibGVhdmluZ0hvb2tzIiwiZGVsYXlMZWF2ZSIsImVhcmx5UmVtb3ZlIiwiZGVsYXllZExlYXZlIiwibGVhdmluZ1ZOb2Rlc0NhY2hlIiwiZ2V0TGVhdmluZ05vZGVzRm9yVHlwZSIsIl9sZWF2ZUNiIiwiQmFzZVRyYW5zaXRpb24iLCJjYWxsSG9vayIsImhvb2tzIiwiYmVmb3JlRW50ZXIiLCJsZWF2aW5nVk5vZGUiLCJlbnRlciIsImFmdGVySG9vayIsImNhbmNlbEhvb2siLCJjYWxsZWQiLCJfZW50ZXJDYiIsImNhbmNlbGxlZCIsImxlYXZlIiwiY2xvbmUiLCJpc0tlZXBBbGl2ZSIsImtlZXBDb21tZW50Iiwia2V5ZWRGcmFnbWVudENvdW50IiwiZGVmaW5lQ29tcG9uZW50IiwiaXNBc3luY1dyYXBwZXIiLCJfX2FzeW5jTG9hZGVyIiwiZGVmaW5lQXN5bmNDb21wb25lbnQiLCJsb2FkZXIiLCJsb2FkaW5nQ29tcG9uZW50IiwiZXJyb3JDb21wb25lbnQiLCJkZWxheSIsInN1c3BlbnNpYmxlIiwidXNlck9uRXJyb3IiLCJwZW5kaW5nUmVxdWVzdCIsInJlc29sdmVkQ29tcCIsInJldHJpZXMiLCJyZXRyeSIsImxvYWQiLCJ0aGlzUmVxdWVzdCIsInJlamVjdCIsInVzZXJSZXRyeSIsInVzZXJGYWlsIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiX19hc3luY1Jlc29sdmVkIiwiY3JlYXRlSW5uZXJDb21wIiwibG9hZGVkIiwiZGVsYXllZCIsIl9faXNLZWVwQWxpdmUiLCJLZWVwQWxpdmVJbXBsIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJtYXgiLCJzaGFyZWRDb250ZXh0IiwicmVuZGVyZXIiLCJjdXJyZW50IiwiX192X2NhY2hlIiwiX3VubW91bnQiLCJzdG9yYWdlQ29udGFpbmVyIiwiYWN0aXZhdGUiLCJpc0RlYWN0aXZhdGVkIiwiaW52b2tlQXJyYXlGbnMiLCJ2bm9kZUhvb2siLCJvblZub2RlTW91bnRlZCIsImludm9rZVZOb2RlSG9vayIsImRlYWN0aXZhdGUiLCJkYSIsIm9uVm5vZGVVbm1vdW50ZWQiLCJyZXNldFNoYXBlRmxhZyIsInBydW5lQ2FjaGUiLCJwcnVuZUNhY2hlRW50cnkiLCJwZW5kaW5nQ2FjaGVLZXkiLCJjYWNoZVN1YnRyZWUiLCJnZXRJbm5lckNoaWxkIiwib25VcGRhdGVkIiwicmF3Vk5vZGUiLCJjYWNoZWRWTm9kZSIsIktlZXBBbGl2ZSIsIm9uQWN0aXZhdGVkIiwicmVnaXN0ZXJLZWVwQWxpdmVIb29rIiwib25EZWFjdGl2YXRlZCIsIndyYXBwZWRIb29rIiwiX193ZGMiLCJpbmplY3RIb29rIiwiaW5qZWN0VG9LZWVwQWxpdmVSb290Iiwia2VlcEFsaXZlUm9vdCIsImluamVjdGVkIiwib25Vbm1vdW50ZWQiLCJwcmVwZW5kIiwiX193ZWgiLCJzZXRDdXJyZW50SW5zdGFuY2UiLCJhcGlOYW1lIiwiY3JlYXRlSG9vayIsImxpZmVjeWNsZSIsImlzSW5TU1JDb21wb25lbnRTZXR1cCIsIm9uQmVmb3JlTW91bnQiLCJvbkJlZm9yZVVwZGF0ZSIsIm9uU2VydmVyUHJlZmV0Y2giLCJvblJlbmRlclRyaWdnZXJlZCIsIm9uUmVuZGVyVHJhY2tlZCIsIm9uRXJyb3JDYXB0dXJlZCIsImNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIiLCJzaG91bGRDYWNoZUFjY2VzcyIsImFwcGx5T3B0aW9ucyIsInJlc29sdmVNZXJnZWRPcHRpb25zIiwiYmVmb3JlQ3JlYXRlIiwiZGF0YU9wdGlvbnMiLCJjb21wdXRlZE9wdGlvbnMiLCJtZXRob2RzIiwid2F0Y2hPcHRpb25zIiwicHJvdmlkZU9wdGlvbnMiLCJpbmplY3RPcHRpb25zIiwiY3JlYXRlZCIsImJlZm9yZU1vdW50IiwibW91bnRlZCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJhY3RpdmF0ZWQiLCJkZWFjdGl2YXRlZCIsImJlZm9yZURlc3Ryb3kiLCJiZWZvcmVVbm1vdW50IiwiZGVzdHJveWVkIiwidW5tb3VudGVkIiwicmVuZGVyVHJhY2tlZCIsInJlbmRlclRyaWdnZXJlZCIsImVycm9yQ2FwdHVyZWQiLCJzZXJ2ZXJQcmVmZXRjaCIsImV4cG9zZSIsImNoZWNrRHVwbGljYXRlUHJvcGVydGllcyIsInJlc29sdmVJbmplY3Rpb25zIiwibWV0aG9kSGFuZGxlciIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwib3B0IiwiY3JlYXRlV2F0Y2hlciIsInJlZ2lzdGVyTGlmZWN5Y2xlSG9vayIsInJlZ2lzdGVyIiwiX2hvb2siLCJleHBvc2VkIiwibm9ybWFsaXplSW5qZWN0IiwiaCIsImJhc2UiLCJleHRlbmRzT3B0aW9ucyIsImdsb2JhbE1peGlucyIsIm9wdGlvbnNDYWNoZSIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInJlc29sdmVkIiwibWVyZ2VPcHRpb25zIiwidG8iLCJzdHJhdHMiLCJzdHJhdCIsImludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMiLCJtZXJnZURhdGFGbiIsIm1lcmdlT2JqZWN0T3B0aW9ucyIsIm1lcmdlSG9vayIsIm1lcmdlSW5qZWN0IiwibWVyZ2VkRGF0YUZuIiwiaW5pdFByb3BzIiwiaXNTdGF0ZWZ1bCIsImlzU1NSIiwiSW50ZXJuYWxPYmplY3RLZXkiLCJwcm9wc0RlZmF1bHRzIiwic2V0RnVsbFByb3BzIiwidmFsaWRhdGVQcm9wcyIsInVwZGF0ZVByb3BzIiwicmF3UHJldlByb3BzIiwicmF3Q3VycmVudFByb3BzIiwiaGFzQXR0cnNDaGFuZ2VkIiwicHJvcHNUb1VwZGF0ZSIsImNhbWVsaXplZEtleSIsInJlc29sdmVQcm9wVmFsdWUiLCJrZWJhYktleSIsIm5lZWRDYXN0S2V5cyIsInJhd0Nhc3RWYWx1ZXMiLCJjYW1lbEtleSIsImNhc3RWYWx1ZXMiLCJpc0Fic2VudCIsImhhc0RlZmF1bHQiLCJub3JtYWxpemVQcm9wc09wdGlvbnMiLCJwcm9wc0NhY2hlIiwiZXh0ZW5kUHJvcHMiLCJFTVBUWV9BUlIiLCJub3JtYWxpemVkS2V5IiwidmFsaWRhdGVQcm9wTmFtZSIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsInN0cmluZ0luZGV4IiwiZ2V0VHlwZSIsImN0b3IiLCJ0b1N0cmluZyIsImlzU2FtZVR5cGUiLCJleHBlY3RlZFR5cGVzIiwiZmluZEluZGV4IiwidCIsInJlc29sdmVkVmFsdWVzIiwidmFsaWRhdGVQcm9wIiwicmVxdWlyZWQiLCJ0eXBlcyIsImFzc2VydFR5cGUiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsImlzU2ltcGxlVHlwZSIsInJlY2VpdmVkVHlwZSIsImV4cGVjdGVkVmFsdWUiLCJzdHlsZVZhbHVlIiwicmVjZWl2ZWRWYWx1ZSIsImlzRXhwbGljYWJsZSIsImlzQm9vbGVhbiIsImV4cGxpY2l0VHlwZXMiLCJlbGVtIiwiaXNJbnRlcm5hbEtleSIsIm5vcm1hbGl6ZVNsb3RWYWx1ZSIsIm5vcm1hbGl6ZVNsb3QiLCJyYXdTbG90Iiwibm9ybWFsaXplT2JqZWN0U2xvdHMiLCJyYXdTbG90cyIsIl9jdHgiLCJub3JtYWxpemVWTm9kZVNsb3RzIiwiaW5pdFNsb3RzIiwidXBkYXRlU2xvdHMiLCJuZWVkRGVsZXRpb25DaGVjayIsImRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCIsImlzQnVpbHRJbkRpcmVjdGl2ZSIsInZhbGlkYXRlRGlyZWN0aXZlTmFtZSIsIndpdGhEaXJlY3RpdmVzIiwiaW50ZXJuYWxJbnN0YW5jZSIsImJpbmRpbmdzIiwiaW52b2tlRGlyZWN0aXZlSG9vayIsIm9sZEJpbmRpbmdzIiwiYmluZGluZyIsImNyZWF0ZUFwcENvbnRleHQiLCJwZXJmb3JtYW5jZSIsImdsb2JhbFByb3BlcnRpZXMiLCJjb21waWxlck9wdGlvbnMiLCJjcmVhdGVBcHBBUEkiLCJjcmVhdGVBcHAiLCJyb290Q29tcG9uZW50Iiwicm9vdFByb3BzIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl91aWQiLCJfY29tcG9uZW50IiwiX3Byb3BzIiwiX2NvbnRhaW5lciIsIl9jb250ZXh0IiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbCIsIm1peGluIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwiZGlyZWN0aXZlIiwibW91bnQiLCJyb290Q29udGFpbmVyIiwiaXNIeWRyYXRlIiwiX192dWVfYXBwX18iLCJoYXNNaXNtYXRjaCIsImlzU1ZHQ29udGFpbmVyIiwibmFtZXNwYWNlVVJJIiwidGFnTmFtZSIsImlzQ29tbWVudCIsIm5vZGVUeXBlIiwiY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zIiwibW91bnRDb21wb25lbnQiLCJtdCIsInBhdGNoUHJvcCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0IiwiY3JlYXRlQ29tbWVudCIsImhhc0NoaWxkTm9kZXMiLCJpc0ZyYWdtZW50U3RhcnQiLCJvbk1pc21hdGNoIiwiaGFuZGxlTWlzbWF0Y2giLCJkb21UeXBlIiwibmV4dE5vZGUiLCJuZWVkVG9BZG9wdENvbnRlbnQiLCJzdGF0aWNDb3VudCIsIm91dGVySFRNTCIsImh5ZHJhdGVGcmFnbWVudCIsImh5ZHJhdGVFbGVtZW50IiwibG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yIiwicHJldmlvdXNTaWJsaW5nIiwibGFzdENoaWxkIiwiY3JlYXRlVGV4dFZOb2RlIiwiaHlkcmF0ZUNoaWxkcmVuIiwic2V0UmVmIiwib25DbGljayIsInZub2RlSG9va3MiLCJvblZub2RlQmVmb3JlTW91bnQiLCJwYXJlbnRWTm9kZSIsImZyYWdtZW50U2xvdFNjb3BlSWRzIiwiaXNGcmFnbWVudCIsInN1cHBvcnRlZCIsInBlcmYiLCJzdGFydE1lYXN1cmUiLCJpc1N1cHBvcnRlZCIsIm1hcmsiLCJub3ciLCJEYXRlIiwiZW5kTWVhc3VyZSIsInN0YXJ0VGFnIiwiZW5kVGFnIiwibWVhc3VyZSIsImNsZWFyTWFya3MiLCJpbml0RmVhdHVyZUZsYWdzIiwibmVlZFdhcm4iLCJwcm9kRWZmZWN0T3B0aW9ucyIsImNyZWF0ZURldkVmZmVjdE9wdGlvbnMiLCJydGMiLCJydGciLCJyYXdSZWYiLCJvbGRSYXdSZWYiLCJpc1VubW91bnQiLCJyZWZWYWx1ZSIsIm93bmVyIiwib2xkUmVmIiwicmVmcyIsImRvU2V0IiwiY3JlYXRlUmVuZGVyZXIiLCJiYXNlQ3JlYXRlUmVuZGVyZXIiLCJjcmVhdGVIeWRyYXRpb25SZW5kZXJlciIsImNyZWF0ZUh5ZHJhdGlvbkZucyIsImdldEdsb2JhbFRoaXMiLCJfX1ZVRV9fIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImhvc3RJbnNlcnQiLCJob3N0UmVtb3ZlIiwiaG9zdFBhdGNoUHJvcCIsImhvc3RGb3JjZVBhdGNoUHJvcCIsImZvcmNlUGF0Y2hQcm9wIiwiaG9zdENyZWF0ZUVsZW1lbnQiLCJob3N0Q3JlYXRlVGV4dCIsImNyZWF0ZVRleHQiLCJob3N0Q3JlYXRlQ29tbWVudCIsImhvc3RTZXRUZXh0Iiwic2V0VGV4dCIsImhvc3RTZXRFbGVtZW50VGV4dCIsInNldEVsZW1lbnRUZXh0IiwiaG9zdFBhcmVudE5vZGUiLCJob3N0TmV4dFNpYmxpbmciLCJzZXRTY29wZUlkIiwiaG9zdFNldFNjb3BlSWQiLCJob3N0Q2xvbmVOb2RlIiwiY2xvbmVOb2RlIiwiaG9zdEluc2VydFN0YXRpY0NvbnRlbnQiLCJpbnNlcnRTdGF0aWNDb250ZW50IiwiZ2V0TmV4dEhvc3ROb2RlIiwicHJvY2Vzc1RleHQiLCJwcm9jZXNzQ29tbWVudE5vZGUiLCJtb3VudFN0YXRpY05vZGUiLCJwYXRjaFN0YXRpY05vZGUiLCJwcm9jZXNzRnJhZ21lbnQiLCJwcm9jZXNzRWxlbWVudCIsInByb2Nlc3NDb21wb25lbnQiLCJpbnRlcm5hbHMiLCJyZW1vdmVTdGF0aWNOb2RlIiwibW92ZVN0YXRpY05vZGUiLCJtb3VudEVsZW1lbnQiLCJwYXRjaEVsZW1lbnQiLCJpcyIsIm1vdW50Q2hpbGRyZW4iLCJ1bm1vdW50Q2hpbGRyZW4iLCJuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyIsImNsb25lSWZNb3VudGVkIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsIm9uVm5vZGVCZWZvcmVVcGRhdGUiLCJwYXRjaFByb3BzIiwiY2xhc3MiLCJzdHlsZSIsImFyZUNoaWxkcmVuU1ZHIiwicGF0Y2hCbG9ja0NoaWxkcmVuIiwidHJhdmVyc2VTdGF0aWNDaGlsZHJlbiIsInBhdGNoQ2hpbGRyZW4iLCJvblZub2RlVXBkYXRlZCIsIm9sZENoaWxkcmVuIiwibmV3Q2hpbGRyZW4iLCJmYWxsYmFja0NvbnRhaW5lciIsIm9sZFZOb2RlIiwibmV3Vk5vZGUiLCJmcmFnbWVudFN0YXJ0QW5jaG9yIiwiZnJhZ21lbnRFbmRBbmNob3IiLCJ1cGRhdGVDb21wb25lbnQiLCJpbml0aWFsVk5vZGUiLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZSIsInNldHVwQ29tcG9uZW50IiwidXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyIiwiY29tcG9uZW50RWZmZWN0IiwiYm0iLCJoeWRyYXRlU3ViVHJlZSIsInNjb3BlZEluaXRpYWxWTm9kZSIsImJ1IiwidSIsIm9yaWdpbk5leHQiLCJuZXh0VHJlZSIsInByZXZUcmVlIiwiYzEiLCJwcmV2U2hhcGVGbGFnIiwiYzIiLCJwYXRjaEtleWVkQ2hpbGRyZW4iLCJwYXRjaFVua2V5ZWRDaGlsZHJlbiIsIm9sZExlbmd0aCIsIm5ld0xlbmd0aCIsImNvbW1vbkxlbmd0aCIsIk1hdGgiLCJtaW4iLCJuZXh0Q2hpbGQiLCJwYXJlbnRBbmNob3IiLCJsMiIsImUxIiwiZTIiLCJuZXh0UG9zIiwiczEiLCJzMiIsImtleVRvTmV3SW5kZXhNYXAiLCJwYXRjaGVkIiwidG9CZVBhdGNoZWQiLCJtb3ZlZCIsIm1heE5ld0luZGV4U29GYXIiLCJuZXdJbmRleFRvT2xkSW5kZXhNYXAiLCJwcmV2Q2hpbGQiLCJuZXdJbmRleCIsImluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlIiwiZ2V0U2VxdWVuY2UiLCJuZXh0SW5kZXgiLCJtb3ZlVHlwZSIsIm5lZWRUcmFuc2l0aW9uIiwicGVyZm9ybUxlYXZlIiwic2hvdWxkSW52b2tlRGlycyIsIm9uVm5vZGVCZWZvcmVVbm1vdW50IiwidW5tb3VudENvbXBvbmVudCIsInJlbW92ZUZyYWdtZW50IiwicGVyZm9ybVJlbW92ZSIsImJ1bSIsIl92bm9kZSIsIm1jIiwicGMiLCJwYmMiLCJjaDEiLCJjaDIiLCJsZW4iLCJhcnJJIiwiaXNUZWxlcG9ydCIsIl9faXNUZWxlcG9ydCIsImlzVGVsZXBvcnREaXNhYmxlZCIsImRpc2FibGVkIiwiaXNUYXJnZXRTVkciLCJTVkdFbGVtZW50IiwicmVzb2x2ZVRhcmdldCIsInNlbGVjdCIsInRhcmdldFNlbGVjdG9yIiwiVGVsZXBvcnRJbXBsIiwicXVlcnlTZWxlY3RvciIsIm1haW5BbmNob3IiLCJ0YXJnZXRBbmNob3IiLCJ3YXNEaXNhYmxlZCIsImN1cnJlbnRBbmNob3IiLCJtb3ZlVGVsZXBvcnQiLCJuZXh0VGFyZ2V0IiwiaHlkcmF0ZVRlbGVwb3J0IiwiaXNSZW9yZGVyIiwidGFyZ2V0Tm9kZSIsIl9scGEiLCJUZWxlcG9ydCIsIkNPTVBPTkVOVFMiLCJESVJFQ1RJVkVTIiwicmVzb2x2ZUNvbXBvbmVudCIsInJlc29sdmVBc3NldCIsIk5VTExfRFlOQU1JQ19DT01QT05FTlQiLCJyZXNvbHZlRHluYW1pY0NvbXBvbmVudCIsInJlc29sdmVEaXJlY3RpdmUiLCJ3YXJuTWlzc2luZyIsInJlZ2lzdHJ5IiwiaXNCbG9ja1RyZWVFbmFibGVkIiwiY3JlYXRlQmxvY2siLCJfX3ZfaXNWTm9kZSIsInZub2RlQXJnc1RyYW5zZm9ybWVyIiwidHJhbnNmb3JtVk5vZGVBcmdzIiwidHJhbnNmb3JtZXIiLCJjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIiwiX2NyZWF0ZVZOb2RlIiwibm9ybWFsaXplS2V5Iiwibm9ybWFsaXplUmVmIiwiaXNCbG9ja05vZGUiLCJjbG9uZWQiLCJub3JtYWxpemVDaGlsZHJlbiIsImtsYXNzIiwibm9ybWFsaXplQ2xhc3MiLCJub3JtYWxpemVTdHlsZSIsIl9fdl9za2lwIiwiZXh0cmFQcm9wcyIsIm1lcmdlUmVmIiwibWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzIiwiZGVlcENsb25lVk5vZGUiLCJjcmVhdGVTdGF0aWNWTm9kZSIsIm51bWJlck9mTm9kZXMiLCJjcmVhdGVDb21tZW50Vk5vZGUiLCJhc0Jsb2NrIiwic2xvdCIsInRvTWVyZ2UiLCJyZW5kZXJMaXN0IiwicmVuZGVySXRlbSIsImlzSW50ZWdlciIsImNyZWF0ZVNsb3RzIiwicmVuZGVyU2xvdCIsIm5vU2xvdHRlZCIsInZhbGlkU2xvdENvbnRlbnQiLCJlbnN1cmVWYWxpZFZOb2RlIiwicmVuZGVyZWQiLCJ2bm9kZXMiLCJ0b0hhbmRsZXJzIiwib2JqIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJpc1N0YXRlZnVsQ29tcG9uZW50IiwicHVibGljUHJvcGVydGllc01hcCIsIiQiLCIkZWwiLCIkZGF0YSIsIiRwcm9wcyIsIiRhdHRycyIsIiRzbG90cyIsIiRyZWZzIiwiJHBhcmVudCIsIiRyb290IiwiJGVtaXQiLCIkb3B0aW9ucyIsIiRmb3JjZVVwZGF0ZSIsIiRuZXh0VGljayIsIiR3YXRjaCIsIlB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyIsImFjY2Vzc0NhY2hlIiwibm9ybWFsaXplZFByb3BzIiwicHVibGljR2V0dGVyIiwiY3NzTW9kdWxlIiwiX19jc3NNb2R1bGVzIiwiUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzIiwidW5zY29wYWJsZXMiLCJpc0dsb2JhbGx5V2hpdGVsaXN0ZWQiLCJjcmVhdGVSZW5kZXJDb250ZXh0IiwiZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQiLCJleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0IiwiZW1wdHlBcHBDb250ZXh0IiwidWlkJDEiLCJzZXR1cENvbnRleHQiLCJiYyIsInNwIiwiaXNCdWlsdEluVGFnIiwiYXBwSXNOYXRpdmVUYWciLCJzZXR1cFJlc3VsdCIsInNldHVwU3RhdGVmdWxDb21wb25lbnQiLCJuYW1lcyIsImNyZWF0ZVNldHVwQ29udGV4dCIsInJlc29sdmVkUmVzdWx0IiwiZmluaXNoQ29tcG9uZW50U2V0dXAiLCJkZXZ0b29sc1Jhd1NldHVwU3RhdGUiLCJyZWdpc3RlclJ1bnRpbWVDb21waWxlciIsIl9jb21waWxlIiwic2tpcE9wdGlvbnMiLCJjb21wb25lbnRDb21waWxlck9wdGlvbnMiLCJmaW5hbENvbXBpbGVyT3B0aW9ucyIsIl9yYyIsImF0dHJIYW5kbGVycyIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsImRpc3BsYXlOYW1lIiwiX19maWxlIiwiaW5mZXJGcm9tUmVnaXN0cnkiLCJjb21wdXRlZCQxIiwiZGVmaW5lUHJvcHMiLCJkZWZpbmVFbWl0IiwidXNlQ29udGV4dCIsInByb3BzT3JDaGlsZHJlbiIsInNzckNvbnRleHRLZXkiLCJ1c2VTU1JDb250ZXh0IiwiaW5pdEN1c3RvbUZvcm1hdHRlciIsInZ1ZVN0eWxlIiwibnVtYmVyU3R5bGUiLCJzdHJpbmdTdHlsZSIsImtleXdvcmRTdHlsZSIsImZvcm1hdHRlciIsImhlYWRlciIsIl9faXNWdWUiLCJnZW5SZWZGbGFnIiwiZm9ybWF0VmFsdWUiLCJoYXNCb2R5IiwiZm9ybWF0SW5zdGFuY2UiLCJibG9ja3MiLCJjcmVhdGVJbnN0YW5jZUJsb2NrIiwiZXh0cmFjdEtleXMiLCJhc1JhdyIsIkNvbXAiLCJleHRyYWN0ZWQiLCJpc0tleU9mVHlwZSIsIm9wdHMiLCJkZXZ0b29sc0Zvcm1hdHRlcnMiLCJzc3JVdGlscyIsInJlc29sdmVGaWx0ZXIiLCJjb21wYXRVdGlscyIsInN2Z05TIiwiZG9jIiwidGVtcENvbnRhaW5lciIsInRlbXBTVkdDb250YWluZXIiLCJub2RlT3BzIiwiaW5zZXJ0QmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVFbGVtZW50TlMiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZVRleHROb2RlIiwibm9kZVZhbHVlIiwic2VsZWN0b3IiLCJ0ZW1wIiwicGF0Y2hDbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwiX3Z0YyIsImNsYXNzTmFtZSIsInBhdGNoU3R5bGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJkaXNwbGF5Iiwic2V0U3R5bGUiLCJpbXBvcnRhbnRSRSIsInNldFByb3BlcnR5IiwicHJlZml4ZWQiLCJhdXRvUHJlZml4IiwicHJlZml4ZXMiLCJwcmVmaXhDYWNoZSIsInhsaW5rTlMiLCJwYXRjaEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwiaXNTcGVjaWFsQm9vbGVhbkF0dHIiLCJwYXRjaERPTVByb3AiLCJfZ2V0Tm93Iiwic2tpcFRpbWVzdGFtcENoZWNrIiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmZk1hdGNoIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiY2FjaGVkTm93IiwicmVzZXQiLCJnZXROb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBhdGNoRXZlbnQiLCJwcmV2VmFsdWUiLCJuZXh0VmFsdWUiLCJpbnZva2VycyIsIl92ZWkiLCJleGlzdGluZ0ludm9rZXIiLCJwYXJzZU5hbWUiLCJpbnZva2VyIiwiY3JlYXRlSW52b2tlciIsIm9wdGlvbnNNb2RpZmllclJFIiwiaW5pdGlhbFZhbHVlIiwiYXR0YWNoZWQiLCJwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm9yaWdpbmFsU3RvcCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIl9zdG9wcGVkIiwibmF0aXZlT25SRSIsInNob3VsZFNldEFzUHJvcCIsIl90cnVlVmFsdWUiLCJfZmFsc2VWYWx1ZSIsInVzZUNzc01vZHVsZSIsIm1vZHVsZXMiLCJtb2QiLCJ1c2VDc3NWYXJzIiwic2V0VmFycyIsInNldFZhcnNPblZOb2RlIiwidmFycyIsIkFOSU1BVElPTiIsIlRyYW5zaXRpb24iLCJyZXNvbHZlVHJhbnNpdGlvblByb3BzIiwiRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyIsImNzcyIsImR1cmF0aW9uIiwiZW50ZXJGcm9tQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiYXBwZWFyRnJvbUNsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwibGVhdmVGcm9tQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwiVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyIsImhhc0V4cGxpY2l0Q2FsbGJhY2siLCJiYXNlUHJvcHMiLCJkdXJhdGlvbnMiLCJub3JtYWxpemVEdXJhdGlvbiIsImVudGVyRHVyYXRpb24iLCJsZWF2ZUR1cmF0aW9uIiwiZmluaXNoRW50ZXIiLCJpc0FwcGVhciIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsImZpbmlzaExlYXZlIiwibWFrZUVudGVySG9vayIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImZvcmNlUmVmbG93IiwiTnVtYmVyT2YiLCJ2YWxpZGF0ZUR1cmF0aW9uIiwiaXNOYU4iLCJjbHMiLCJjbGFzc0xpc3QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJlbmRJZCIsImV4cGxpY2l0VGltZW91dCIsIl9lbmRJZCIsInJlc29sdmVJZk5vdFN0YWxlIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRFdmVudCIsImVuZGVkIiwib25FbmQiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0U3R5bGVQcm9wZXJ0aWVzIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZCIsInRvTXMiLCJvZmZzZXRIZWlnaHQiLCJwb3NpdGlvbk1hcCIsIm5ld1Bvc2l0aW9uTWFwIiwiVHJhbnNpdGlvbkdyb3VwSW1wbCIsIm1vdmVDbGFzcyIsImhhc0NTU1RyYW5zZm9ybSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJtb3ZlZENoaWxkcmVuIiwiYXBwbHlUcmFuc2xhdGlvbiIsIndlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJjc3NUcmFuc2l0aW9uUHJvcHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJUcmFuc2l0aW9uR3JvdXAiLCJvbGRQb3MiLCJuZXdQb3MiLCJkeCIsImR5IiwidG9wIiwiYXBwZW5kQ2hpbGQiLCJnZXRNb2RlbEFzc2lnbmVyIiwib25Db21wb3NpdGlvblN0YXJ0IiwiY29tcG9zaW5nIiwib25Db21wb3NpdGlvbkVuZCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJ2TW9kZWxUZXh0IiwiX2Fzc2lnbiIsImNhc3RUb051bWJlciIsImRvbVZhbHVlIiwiYWN0aXZlRWxlbWVudCIsInZNb2RlbENoZWNrYm94IiwibW9kZWxWYWx1ZSIsIl9tb2RlbFZhbHVlIiwiZWxlbWVudFZhbHVlIiwiZ2V0VmFsdWUiLCJjaGVja2VkIiwiYXNzaWduIiwibG9vc2VJbmRleE9mIiwiZm91bmQiLCJmaWx0ZXJlZCIsImdldENoZWNrYm94VmFsdWUiLCJzZXRDaGVja2VkIiwibG9vc2VFcXVhbCIsInZNb2RlbFJhZGlvIiwidk1vZGVsU2VsZWN0IiwiaXNTZXRNb2RlbCIsInNlbGVjdGVkVmFsIiwic2VsZWN0ZWQiLCJzZXRTZWxlY3RlZCIsIl9iaW5kaW5nIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsIm9wdGlvblZhbHVlIiwic2VsZWN0ZWRJbmRleCIsInZNb2RlbER5bmFtaWMiLCJjYWxsTW9kZWxIb29rIiwibW9kZWxUb1VzZSIsInN5c3RlbU1vZGlmaWVycyIsIm1vZGlmaWVyR3VhcmRzIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudCIsInByZXZlbnREZWZhdWx0IiwiY3VycmVudFRhcmdldCIsImN0cmwiLCJjdHJsS2V5Iiwic2hpZnQiLCJzaGlmdEtleSIsImFsdCIsImFsdEtleSIsIm1ldGEiLCJtZXRhS2V5IiwiYnV0dG9uIiwiZXhhY3QiLCJ3aXRoTW9kaWZpZXJzIiwiZ3VhcmQiLCJrZXlOYW1lcyIsImVzYyIsInNwYWNlIiwidXAiLCJkb3duIiwid2l0aEtleXMiLCJldmVudEtleSIsImsiLCJ2U2hvdyIsIl92b2QiLCJzZXREaXNwbGF5IiwicmVuZGVyZXJPcHRpb25zIiwiZW5hYmxlZEh5ZHJhdGlvbiIsImVuc3VyZVJlbmRlcmVyIiwiZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIiLCJpbmplY3ROYXRpdmVUYWdDaGVjayIsImluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrIiwiY29udGFpbmVyT3JTZWxlY3RvciIsIm5vcm1hbGl6ZUNvbnRhaW5lciIsIkVsZW1lbnQiLCJjcmVhdGVTU1JBcHAiLCJTaGFkb3dSb290IiwiZXhwZWN0c0xvd2VyQ2FzZSIsIkdMT0JBTFNfV0hJVEVfTElTVEVEIiwiZ2VuZXJhdGVDb2RlRnJhbWUiLCJsaW5lcyIsImxpbmVMZW5ndGgiLCJwYWQiLCJzcGVjaWFsQm9vbGVhbkF0dHJzIiwiaXNCb29sZWFuQXR0ciIsInVuc2FmZUF0dHJDaGFyUkUiLCJhdHRyVmFsaWRhdGlvbkNhY2hlIiwiaXNTU1JTYWZlQXR0ck5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzVW5zYWZlIiwicHJvcHNUb0F0dHJNYXAiLCJhY2NlcHRDaGFyc2V0IiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCIsImlzS25vd25BdHRyIiwiaXRlbSIsImxpc3REZWxpbWl0ZXJSRSIsInByb3BlcnR5RGVsaW1pdGVyUkUiLCJ0bXAiLCJzdHJpbmdpZnlTdHlsZSIsIkhUTUxfVEFHUyIsIlNWR19UQUdTIiwiVk9JRF9UQUdTIiwiZXNjYXBlUkUiLCJlc2NhcGVIdG1sIiwic3RyaW5nIiwiZXNjYXBlZCIsImxhc3RJbmRleCIsInN1YnN0cmluZyIsImNvbW1lbnRTdHJpcFJFIiwiZXNjYXBlSHRtbENvbW1lbnQiLCJzcmMiLCJsb29zZUNvbXBhcmVBcnJheXMiLCJlcXVhbCIsImFWYWxpZFR5cGUiLCJpc0RhdGUiLCJiVmFsaWRUeXBlIiwiZ2V0VGltZSIsImFLZXlzQ291bnQiLCJiS2V5c0NvdW50IiwiYUhhc0tleSIsImJIYXNLZXkiLCJ0b0Rpc3BsYXlTdHJpbmciLCJyZXBsYWNlciIsImVudHJpZXMiLCJyZWR1Y2UiLCJiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zIiwib25SRSIsInRvVHlwZVN0cmluZyIsIm9iamVjdFRvU3RyaW5nIiwiaHlwaGVuYXRlUkUiLCJmbnMiLCJwYXJzZUZsb2F0IiwiX2dsb2JhbFRoaXMiLCJnbG9iYWxUaGlzIiwiaW5pdERldiIsImNvbXBpbGVDYWNoZSIsImNvbXBpbGVUb0Z1bmN0aW9uIiwiYXNXYXJuaW5nIiwiY29kZUZyYW1lIiwicnVudGltZURvbSIsIndlYmNhbVN0YXR1cyIsIlRGQ0FNIiwic3RhcnRDYW0iLCJzbmFwc2hvdHMiLCJ0ZiIsIndlYmNhbSIsImNhcHR1cmUiLCJpbWFnZUZyb21DYXB0dXJlIiwiZGF0YVVybCIsInVwbG9hZERhdGFVcmwiLCJzdG9wQ2FtIiwiYnJvd3NlciIsInRvUGl4ZWxzIiwiaGlkZGVuQ2FudmFzIiwidG9EYXRhVVJMIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJmZXRjaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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RCxZQUFMLEdBQW9COTlELEdBQXhCO0FBQUEsT0FMVjtBQU1EO0FBekNNO0FBUFcsQ0FBRCxDQUFyQjtBQW9EQSswQixHQUFHLENBQUN5Z0IsS0FBSixDQUFVLE1BQVYsRSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU3RyaW5nLCBoeXBoZW5hdGUsIGV4dGVuZCwgaXNPYmplY3QsIGlzQXJyYXksIG1ha2VNYXAsIE5PLCBpc1N5bWJvbCwgTk9PUCwgRU1QVFlfT0JKLCBjYXBpdGFsaXplLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBQYXRjaEZsYWdOYW1lcywgc2xvdEZsYWdzVGV4dCwgaXNPbiwgaXNSZXNlcnZlZFByb3AsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGdlbmVyYXRlQ29kZUZyYW1lIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdE9uV2Fybihtc2cpIHtcclxuICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2cubWVzc2FnZX1gKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgbWVzc2FnZXMsIGFkZGl0aW9uYWxNZXNzYWdlKSB7XHJcbiAgICBjb25zdCBtc2cgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWVcclxuICAgICAgICA/IChtZXNzYWdlcyB8fCBlcnJvck1lc3NhZ2VzKVtjb2RlXSArIChhZGRpdGlvbmFsTWVzc2FnZSB8fCBgYClcclxuICAgICAgICA6IGNvZGU7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihTdHJpbmcobXNnKSk7XHJcbiAgICBlcnJvci5jb2RlID0gY29kZTtcclxuICAgIGVycm9yLmxvYyA9IGxvYztcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgLy8gcGFyc2UgZXJyb3JzXHJcbiAgICBbMCAvKiBBQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovXTogJ0lsbGVnYWwgY29tbWVudC4nLFxyXG4gICAgWzEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovXTogJ0NEQVRBIHNlY3Rpb24gaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LicsXHJcbiAgICBbMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovXTogJ0R1cGxpY2F0ZSBhdHRyaWJ1dGUuJyxcclxuICAgIFszIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovXTogJ0VuZCB0YWcgY2Fubm90IGhhdmUgYXR0cmlidXRlcy4nLFxyXG4gICAgWzQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXHJcbiAgICBbNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxyXG4gICAgWzYgLyogRU9GX0lOX0NEQVRBICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIENEQVRBIHNlY3Rpb24uJyxcclxuICAgIFs3IC8qIEVPRl9JTl9DT01NRU5UICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIGNvbW1lbnQuJyxcclxuICAgIFs4IC8qIEVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBzY3JpcHQuJyxcclxuICAgIFs5IC8qIEVPRl9JTl9UQUcgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXHJcbiAgICBbMTAgLyogSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgY2xvc2VkIGNvbW1lbnQuJyxcclxuICAgIFsxMSAvKiBJTkNPUlJFQ1RMWV9PUEVORURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBvcGVuZWQgY29tbWVudC4nLFxyXG4gICAgWzEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovXTogXCJJbGxlZ2FsIHRhZyBuYW1lLiBVc2UgJyZsdDsnIHRvIHByaW50ICc8Jy5cIixcclxuICAgIFsxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqL106ICdBdHRyaWJ1dGUgdmFsdWUgd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi9dOiAnRW5kIHRhZyBuYW1lIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi9dOiAnV2hpdGVzcGFjZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNiAvKiBORVNURURfQ09NTUVOVCAqL106IFwiVW5leHBlY3RlZCAnPCEtLScgaW4gY29tbWVudC5cIixcclxuICAgIFsxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqL106ICdBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBhbmQgVSswMDNDICg8KS4nLFxyXG4gICAgWzE4IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqL106ICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgVSswMDNDICg8KSwgVSswMDNEICg9KSwgYW5kIFUrMDA2MCAoYCkuJyxcclxuICAgIFsxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqL106IFwiQXR0cmlidXRlIG5hbWUgY2Fubm90IHN0YXJ0IHdpdGggJz0nLlwiLFxyXG4gICAgWzIxIC8qIFVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovXTogXCInPD8nIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC5cIixcclxuICAgIFsyMCAvKiBVTkVYUEVDVEVEX05VTExfQ0hBUkFDVEVSICovXTogYFVuZXhwZWN0ZWQgbnVsbCBjYWhyYWN0ZXIuYCxcclxuICAgIFsyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gICAgLy8gVnVlLXNwZWNpZmljIHBhcnNlIGVycm9yc1xyXG4gICAgWzIzIC8qIFhfSU5WQUxJRF9FTkRfVEFHICovXTogJ0ludmFsaWQgZW5kIHRhZy4nLFxyXG4gICAgWzI0IC8qIFhfTUlTU0lOR19FTkRfVEFHICovXTogJ0VsZW1lbnQgaXMgbWlzc2luZyBlbmQgdGFnLicsXHJcbiAgICBbMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovXTogJ0ludGVycG9sYXRpb24gZW5kIHNpZ24gd2FzIG5vdCBmb3VuZC4nLFxyXG4gICAgWzI2IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi9dOiAnRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuICcgK1xyXG4gICAgICAgICdOb3RlIHRoYXQgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgY2Fubm90IGNvbnRhaW4gc3BhY2VzLicsXHJcbiAgICAvLyB0cmFuc2Zvcm0gZXJyb3JzXHJcbiAgICBbMjcgLyogWF9WX0lGX05PX0VYUFJFU1NJT04gKi9dOiBgdi1pZi92LWVsc2UtaWYgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMjggLyogWF9WX0lGX1NBTUVfS0VZICovXTogYHYtaWYvZWxzZSBicmFuY2hlcyBtdXN0IHVzZSB1bmlxdWUga2V5cy5gLFxyXG4gICAgWzI5IC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovXTogYHYtZWxzZS92LWVsc2UtaWYgaGFzIG5vIGFkamFjZW50IHYtaWYuYCxcclxuICAgIFszMCAvKiBYX1ZfRk9SX05PX0VYUFJFU1NJT04gKi9dOiBgdi1mb3IgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzEgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqL106IGB2LWZvciBoYXMgaW52YWxpZCBleHByZXNzaW9uLmAsXHJcbiAgICBbMzIgLyogWF9WX0ZPUl9URU1QTEFURV9LRVlfUExBQ0VNRU5UICovXTogYDx0ZW1wbGF0ZSB2LWZvcj4ga2V5IHNob3VsZCBiZSBwbGFjZWQgb24gdGhlIDx0ZW1wbGF0ZT4gdGFnLmAsXHJcbiAgICBbMzMgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqL106IGB2LWJpbmQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzQgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi9dOiBgdi1vbiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszNSAvKiBYX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVCAqL106IGBVbmV4cGVjdGVkIGN1c3RvbSBkaXJlY3RpdmUgb24gPHNsb3Q+IG91dGxldC5gLFxyXG4gICAgWzM2IC8qIFhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0UgKi9dOiBgTWl4ZWQgdi1zbG90IHVzYWdlIG9uIGJvdGggdGhlIGNvbXBvbmVudCBhbmQgbmVzdGVkIDx0ZW1wbGF0ZT4uYCArXHJcbiAgICAgICAgYFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIG5hbWVkIHNsb3RzLCBhbGwgc2xvdHMgc2hvdWxkIHVzZSA8dGVtcGxhdGU+IGAgK1xyXG4gICAgICAgIGBzeW50YXggdG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LmAsXHJcbiAgICBbMzcgLyogWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi9dOiBgRHVwbGljYXRlIHNsb3QgbmFtZXMgZm91bmQuIGAsXHJcbiAgICBbMzggLyogWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU4gKi9dOiBgRXh0cmFuZW91cyBjaGlsZHJlbiBmb3VuZCB3aGVuIGNvbXBvbmVudCBhbHJlYWR5IGhhcyBleHBsaWNpdGx5IG5hbWVkIGAgK1xyXG4gICAgICAgIGBkZWZhdWx0IHNsb3QuIFRoZXNlIGNoaWxkcmVuIHdpbGwgYmUgaWdub3JlZC5gLFxyXG4gICAgWzM5IC8qIFhfVl9TTE9UX01JU1BMQUNFRCAqL106IGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4gdGFncy5gLFxyXG4gICAgWzQwIC8qIFhfVl9NT0RFTF9OT19FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNDEgLyogWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgbWVtYmVyIGV4cHJlc3Npb24uYCxcclxuICAgIFs0MiAvKiBYX1ZfTU9ERUxfT05fU0NPUEVfVkFSSUFCTEUgKi9dOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiB2LWZvciBvciB2LXNsb3Qgc2NvcGUgdmFyaWFibGVzIGJlY2F1c2UgdGhleSBhcmUgbm90IHdyaXRhYmxlLmAsXHJcbiAgICBbNDMgLyogWF9JTlZBTElEX0VYUFJFU1NJT04gKi9dOiBgRXJyb3IgcGFyc2luZyBKYXZhU2NyaXB0IGV4cHJlc3Npb246IGAsXHJcbiAgICBbNDQgLyogWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPEtlZXBBbGl2ZT4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuYCxcclxuICAgIC8vIGdlbmVyaWMgZXJyb3JzXHJcbiAgICBbNDUgLyogWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRCAqL106IGBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxyXG4gICAgWzQ2IC8qIFhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqL106IGBFUyBtb2R1bGUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcclxuICAgIFs0NyAvKiBYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqL106IGBcImNhY2hlSGFuZGxlcnNcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB0aGUgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBlbmFibGVkLmAsXHJcbiAgICBbNDggLyogWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwic2NvcGVJZFwiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBtb2R1bGUgbW9kZS5gLFxyXG4gICAgLy8ganVzdCB0byBmdWxsZmlsbCB0eXBlc1xyXG4gICAgWzQ5IC8qIF9fRVhURU5EX1BPSU5UX18gKi9dOiBgYFxyXG59O1xuXG5jb25zdCBGUkFHTUVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgRnJhZ21lbnRgIDogYGApO1xyXG5jb25zdCBURUxFUE9SVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVGVsZXBvcnRgIDogYGApO1xyXG5jb25zdCBTVVNQRU5TRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgU3VzcGVuc2VgIDogYGApO1xyXG5jb25zdCBLRUVQX0FMSVZFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBLZWVwQWxpdmVgIDogYGApO1xyXG5jb25zdCBCQVNFX1RSQU5TSVRJT04gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEJhc2VUcmFuc2l0aW9uYCA6IGBgKTtcclxuY29uc3QgT1BFTl9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgb3BlbkJsb2NrYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX0JMT0NLID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVCbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9WTk9ERSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlVk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfQ09NTUVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQ29tbWVudFZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVRleHRWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TVEFUSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVN0YXRpY1ZOb2RlYCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9DT01QT05FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVDb21wb25lbnRgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfRElSRUNUSVZFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRGlyZWN0aXZlYCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9GSUxURVIgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVGaWx0ZXJgIDogYGApO1xyXG5jb25zdCBXSVRIX0RJUkVDVElWRVMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhEaXJlY3RpdmVzYCA6IGBgKTtcclxuY29uc3QgUkVOREVSX0xJU1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlckxpc3RgIDogYGApO1xyXG5jb25zdCBSRU5ERVJfU0xPVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVuZGVyU2xvdGAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TTE9UUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlU2xvdHNgIDogYGApO1xyXG5jb25zdCBUT19ESVNQTEFZX1NUUklORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9EaXNwbGF5U3RyaW5nYCA6IGBgKTtcclxuY29uc3QgTUVSR0VfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG1lcmdlUHJvcHNgIDogYGApO1xyXG5jb25zdCBUT19IQU5ETEVSUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9IYW5kbGVyc2AgOiBgYCk7XHJcbmNvbnN0IENBTUVMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYW1lbGl6ZWAgOiBgYCk7XHJcbmNvbnN0IENBUElUQUxJWkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNhcGl0YWxpemVgIDogYGApO1xyXG5jb25zdCBUT19IQU5ETEVSX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9IYW5kbGVyS2V5YCA6IGBgKTtcclxuY29uc3QgU0VUX0JMT0NLX1RSQUNLSU5HID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzZXRCbG9ja1RyYWNraW5nYCA6IGBgKTtcclxuY29uc3QgUFVTSF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcHVzaFNjb3BlSWRgIDogYGApO1xyXG5jb25zdCBQT1BfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHBvcFNjb3BlSWRgIDogYGApO1xyXG5jb25zdCBXSVRIX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoU2NvcGVJZGAgOiBgYCk7XHJcbmNvbnN0IFdJVEhfQ1RYID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoQ3R4YCA6IGBgKTtcclxuY29uc3QgVU5SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHVucmVmYCA6IGBgKTtcclxuY29uc3QgSVNfUkVGID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBpc1JlZmAgOiBgYCk7XHJcbi8vIE5hbWUgbWFwcGluZyBmb3IgcnVudGltZSBoZWxwZXJzIHRoYXQgbmVlZCB0byBiZSBpbXBvcnRlZCBmcm9tICd2dWUnIGluXHJcbi8vIGdlbmVyYXRlZCBjb2RlLiBNYWtlIHN1cmUgdGhlc2UgYXJlIGNvcnJlY3RseSBleHBvcnRlZCBpbiB0aGUgcnVudGltZSFcclxuLy8gVXNpbmcgYGFueWAgaGVyZSBiZWNhdXNlIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9scyBhcyBpbmRleCB0eXBlLlxyXG5jb25zdCBoZWxwZXJOYW1lTWFwID0ge1xyXG4gICAgW0ZSQUdNRU5UXTogYEZyYWdtZW50YCxcclxuICAgIFtURUxFUE9SVF06IGBUZWxlcG9ydGAsXHJcbiAgICBbU1VTUEVOU0VdOiBgU3VzcGVuc2VgLFxyXG4gICAgW0tFRVBfQUxJVkVdOiBgS2VlcEFsaXZlYCxcclxuICAgIFtCQVNFX1RSQU5TSVRJT05dOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgW09QRU5fQkxPQ0tdOiBgb3BlbkJsb2NrYCxcclxuICAgIFtDUkVBVEVfQkxPQ0tdOiBgY3JlYXRlQmxvY2tgLFxyXG4gICAgW0NSRUFURV9WTk9ERV06IGBjcmVhdGVWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX0NPTU1FTlRdOiBgY3JlYXRlQ29tbWVudFZOb2RlYCxcclxuICAgIFtDUkVBVEVfVEVYVF06IGBjcmVhdGVUZXh0Vk5vZGVgLFxyXG4gICAgW0NSRUFURV9TVEFUSUNdOiBgY3JlYXRlU3RhdGljVk5vZGVgLFxyXG4gICAgW1JFU09MVkVfQ09NUE9ORU5UXTogYHJlc29sdmVDb21wb25lbnRgLFxyXG4gICAgW1JFU09MVkVfRFlOQU1JQ19DT01QT05FTlRdOiBgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnRgLFxyXG4gICAgW1JFU09MVkVfRElSRUNUSVZFXTogYHJlc29sdmVEaXJlY3RpdmVgLFxyXG4gICAgW1JFU09MVkVfRklMVEVSXTogYHJlc29sdmVGaWx0ZXJgLFxyXG4gICAgW1dJVEhfRElSRUNUSVZFU106IGB3aXRoRGlyZWN0aXZlc2AsXHJcbiAgICBbUkVOREVSX0xJU1RdOiBgcmVuZGVyTGlzdGAsXHJcbiAgICBbUkVOREVSX1NMT1RdOiBgcmVuZGVyU2xvdGAsXHJcbiAgICBbQ1JFQVRFX1NMT1RTXTogYGNyZWF0ZVNsb3RzYCxcclxuICAgIFtUT19ESVNQTEFZX1NUUklOR106IGB0b0Rpc3BsYXlTdHJpbmdgLFxyXG4gICAgW01FUkdFX1BST1BTXTogYG1lcmdlUHJvcHNgLFxyXG4gICAgW1RPX0hBTkRMRVJTXTogYHRvSGFuZGxlcnNgLFxyXG4gICAgW0NBTUVMSVpFXTogYGNhbWVsaXplYCxcclxuICAgIFtDQVBJVEFMSVpFXTogYGNhcGl0YWxpemVgLFxyXG4gICAgW1RPX0hBTkRMRVJfS0VZXTogYHRvSGFuZGxlcktleWAsXHJcbiAgICBbU0VUX0JMT0NLX1RSQUNLSU5HXTogYHNldEJsb2NrVHJhY2tpbmdgLFxyXG4gICAgW1BVU0hfU0NPUEVfSURdOiBgcHVzaFNjb3BlSWRgLFxyXG4gICAgW1BPUF9TQ09QRV9JRF06IGBwb3BTY29wZUlkYCxcclxuICAgIFtXSVRIX1NDT1BFX0lEXTogYHdpdGhTY29wZUlkYCxcclxuICAgIFtXSVRIX0NUWF06IGB3aXRoQ3R4YCxcclxuICAgIFtVTlJFRl06IGB1bnJlZmAsXHJcbiAgICBbSVNfUkVGXTogYGlzUmVmYFxyXG59O1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVIZWxwZXJzKGhlbHBlcnMpIHtcclxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVscGVycykuZm9yRWFjaChzID0+IHtcclxuICAgICAgICBoZWxwZXJOYW1lTWFwW3NdID0gaGVscGVyc1tzXTtcclxuICAgIH0pO1xyXG59XG5cbi8vIEFTVCBVdGlsaXRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFNvbWUgZXhwcmVzc2lvbnMsIGUuZy4gc2VxdWVuY2UgYW5kIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLCBhcmUgbmV2ZXJcclxuLy8gYXNzb2NpYXRlZCB3aXRoIHRlbXBsYXRlIG5vZGVzLCBzbyB0aGVpciBzb3VyY2UgbG9jYXRpb25zIGFyZSBqdXN0IGEgc3R1Yi5cclxuLy8gQ29udGFpbmVyIHR5cGVzIGxpa2UgQ29tcG91bmRFeHByZXNzaW9uIGFsc28gZG9uJ3QgbmVlZCBhIHJlYWwgbG9jYXRpb24uXHJcbmNvbnN0IGxvY1N0dWIgPSB7XHJcbiAgICBzb3VyY2U6ICcnLFxyXG4gICAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcclxuICAgIGVuZDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMCAvKiBST09UICovLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGhlbHBlcnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IFtdLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IFtdLFxyXG4gICAgICAgIGhvaXN0czogW10sXHJcbiAgICAgICAgaW1wb3J0czogW10sXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIHRlbXBzOiAwLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2sgPSBmYWxzZSwgZGlzYWJsZVRyYWNraW5nID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihXSVRIX0RJUkVDVElWRVMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTMgLyogVk5PREVfQ0FMTCAqLyxcclxuICAgICAgICB0YWcsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkaXJlY3RpdmVzLFxyXG4gICAgICAgIGlzQmxvY2ssXHJcbiAgICAgICAgZGlzYWJsZVRyYWNraW5nLFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUV4cHJlc3Npb24oZWxlbWVudHMsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgZWxlbWVudHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBwcm9wZXJ0aWVzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTYgLyogSlNfUFJPUEVSVFkgKi8sXHJcbiAgICAgICAgbG9jOiBsb2NTdHViLFxyXG4gICAgICAgIGtleTogaXNTdHJpbmcoa2V5KSA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oa2V5LCB0cnVlKSA6IGtleSxcclxuICAgICAgICB2YWx1ZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGlzU3RhdGljLCBsb2MgPSBsb2NTdHViLCBjb25zdFR5cGUgPSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGlzU3RhdGljLFxyXG4gICAgICAgIGNvbnN0VHlwZTogaXNTdGF0aWMgPyAzIC8qIENBTl9TVFJJTkdJRlkgKi8gOiBjb25zdFR5cGVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW50ZXJwb2xhdGlvbihjb250ZW50LCBsb2MpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNSAvKiBJTlRFUlBPTEFUSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjb250ZW50OiBpc1N0cmluZyhjb250ZW50KVxyXG4gICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgZmFsc2UsIGxvYylcclxuICAgICAgICAgICAgOiBjb250ZW50XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihjaGlsZHJlbiwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNoaWxkcmVuXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncyA9IFtdLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY2FsbGVlLFxyXG4gICAgICAgIGFyZ3VtZW50czogYXJnc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCByZXR1cm5zID0gdW5kZWZpbmVkLCBuZXdsaW5lID0gZmFsc2UsIGlzU2xvdCA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE4IC8qIEpTX0ZVTkNUSU9OX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgIHJldHVybnMsXHJcbiAgICAgICAgbmV3bGluZSxcclxuICAgICAgICBpc1Nsb3QsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmUgPSB0cnVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgdGVzdCxcclxuICAgICAgICBjb25zZXF1ZW50LFxyXG4gICAgICAgIGFsdGVybmF0ZSxcclxuICAgICAgICBuZXdsaW5lLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDYWNoZUV4cHJlc3Npb24oaW5kZXgsIHZhbHVlLCBpc1ZOb2RlID0gZmFsc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBpbmRleCxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBpc1ZOb2RlLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVCbG9ja1N0YXRlbWVudChib2R5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIxIC8qIEpTX0JMT0NLX1NUQVRFTUVOVCAqLyxcclxuICAgICAgICBib2R5LFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUxpdGVyYWwoZWxlbWVudHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjIgLyogSlNfVEVNUExBVEVfTElURVJBTCAqLyxcclxuICAgICAgICBlbGVtZW50cyxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIzIC8qIEpTX0lGX1NUQVRFTUVOVCAqLyxcclxuICAgICAgICB0ZXN0LFxyXG4gICAgICAgIGNvbnNlcXVlbnQsXHJcbiAgICAgICAgYWx0ZXJuYXRlLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNCAvKiBKU19BU1NJR05NRU5UX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbGVmdCxcclxuICAgICAgICByaWdodCxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDI1IC8qIEpTX1NFUVVFTkNFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgZXhwcmVzc2lvbnMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJldHVyblN0YXRlbWVudChyZXR1cm5zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDI2IC8qIEpTX1JFVFVSTl9TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgcmV0dXJucyxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cblxuY29uc3QgaXNTdGF0aWNFeHAgPSAocCkgPT4gcC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmIHAuaXNTdGF0aWM7XHJcbmNvbnN0IGlzQnVpbHRJblR5cGUgPSAodGFnLCBleHBlY3RlZCkgPT4gdGFnID09PSBleHBlY3RlZCB8fCB0YWcgPT09IGh5cGhlbmF0ZShleHBlY3RlZCk7XHJcbmZ1bmN0aW9uIGlzQ29yZUNvbXBvbmVudCh0YWcpIHtcclxuICAgIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1RlbGVwb3J0JykpIHtcclxuICAgICAgICByZXR1cm4gVEVMRVBPUlQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1N1c3BlbnNlJykpIHtcclxuICAgICAgICByZXR1cm4gU1VTUEVOU0U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0tlZXBBbGl2ZScpKSB7XHJcbiAgICAgICAgcmV0dXJuIEtFRVBfQUxJVkU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0Jhc2VUcmFuc2l0aW9uJykpIHtcclxuICAgICAgICByZXR1cm4gQkFTRV9UUkFOU0lUSU9OO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IG5vbklkZW50aWZpZXJSRSA9IC9eXFxkfFteXFwkXFx3XS87XHJcbmNvbnN0IGlzU2ltcGxlSWRlbnRpZmllciA9IChuYW1lKSA9PiAhbm9uSWRlbnRpZmllclJFLnRlc3QobmFtZSk7XHJcbmNvbnN0IG1lbWJlckV4cFJFID0gL15bQS1aYS16XyRcXHhBMC1cXHVGRkZGXVtcXHckXFx4QTAtXFx1RkZGRl0qKD86XFxzKlxcLlxccypbQS1aYS16XyRcXHhBMC1cXHVGRkZGXVtcXHckXFx4QTAtXFx1RkZGRl0qfFxcWyguKylcXF0pKiQvO1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb24gPSAocGF0aCkgPT4ge1xyXG4gICAgaWYgKCFwYXRoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGNvbnN0IG1hdGNoZWQgPSBtZW1iZXJFeHBSRS5leGVjKHBhdGgudHJpbSgpKTtcclxuICAgIGlmICghbWF0Y2hlZClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIW1hdGNoZWRbMV0pXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoIS9bXFxbXFxdXS8udGVzdChtYXRjaGVkWzFdKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBpc01lbWJlckV4cHJlc3Npb24obWF0Y2hlZFsxXS50cmltKCkpO1xyXG59O1xyXG5mdW5jdGlvbiBnZXRJbm5lclJhbmdlKGxvYywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IGxvYy5zb3VyY2Uuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcclxuICAgIGNvbnN0IG5ld0xvYyA9IHtcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgc3RhcnQ6IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShsb2Muc3RhcnQsIGxvYy5zb3VyY2UsIG9mZnNldCksXHJcbiAgICAgICAgZW5kOiBsb2MuZW5kXHJcbiAgICB9O1xyXG4gICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgbmV3TG9jLmVuZCA9IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShsb2Muc3RhcnQsIGxvYy5zb3VyY2UsIG9mZnNldCArIGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3TG9jO1xyXG59XHJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihleHRlbmQoe30sIHBvcyksIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG4vLyBhZHZhbmNlIGJ5IG11dGF0aW9uIHdpdGhvdXQgY2xvbmluZyAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLCBzaW5jZSB0aGlzXHJcbi8vIGdldHMgY2FsbGVkIGEgbG90IGluIHRoZSBwYXJzZXJcclxuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICBsZXQgbGluZXNDb3VudCA9IDA7XHJcbiAgICBsZXQgbGFzdE5ld0xpbmVQb3MgPSAtMTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDaGFyYWN0ZXJzOyBpKyspIHtcclxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaSkgPT09IDEwIC8qIG5ld2xpbmUgY2hhciBjb2RlICovKSB7XHJcbiAgICAgICAgICAgIGxpbmVzQ291bnQrKztcclxuICAgICAgICAgICAgbGFzdE5ld0xpbmVQb3MgPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvcy5vZmZzZXQgKz0gbnVtYmVyT2ZDaGFyYWN0ZXJzO1xyXG4gICAgcG9zLmxpbmUgKz0gbGluZXNDb3VudDtcclxuICAgIHBvcy5jb2x1bW4gPVxyXG4gICAgICAgIGxhc3ROZXdMaW5lUG9zID09PSAtMVxyXG4gICAgICAgICAgICA/IHBvcy5jb2x1bW4gKyBudW1iZXJPZkNoYXJhY3RlcnNcclxuICAgICAgICAgICAgOiBudW1iZXJPZkNoYXJhY3RlcnMgLSBsYXN0TmV3TGluZVBvcztcclxuICAgIHJldHVybiBwb3M7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCBgdW5leHBlY3RlZCBjb21waWxlciBjb25kaXRpb25gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kRGlyKG5vZGUsIG5hbWUsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgKGFsbG93RW1wdHkgfHwgcC5leHApICYmXHJcbiAgICAgICAgICAgIChpc1N0cmluZyhuYW1lKSA/IHAubmFtZSA9PT0gbmFtZSA6IG5hbWUudGVzdChwLm5hbWUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZFByb3Aobm9kZSwgbmFtZSwgZHluYW1pY09ubHkgPSBmYWxzZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY09ubHkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gbmFtZSAmJiAocC52YWx1ZSB8fCBhbGxvd0VtcHR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAgICAgKHAuZXhwIHx8IGFsbG93RW1wdHkpICYmXHJcbiAgICAgICAgICAgIGlzQmluZEtleShwLmFyZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQmluZEtleShhcmcsIG5hbWUpIHtcclxuICAgIHJldHVybiAhIShhcmcgJiYgaXNTdGF0aWNFeHAoYXJnKSAmJiBhcmcuY29udGVudCA9PT0gbmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgcC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAoIXAuYXJnIHx8IC8vIHYtYmluZD1cIm9ialwiXHJcbiAgICAgICAgICAgIHAuYXJnLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHwgLy8gdi1iaW5kOltfY3R4LmZvb11cclxuICAgICAgICAgICAgIXAuYXJnLmlzU3RhdGljKSAvLyB2LWJpbmQ6W2Zvb11cclxuICAgICk7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fCBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLztcclxufVxyXG5mdW5jdGlvbiBpc1ZTbG90KHApIHtcclxuICAgIHJldHVybiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3Nsb3QnO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGVtcGxhdGVOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiYgbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovKTtcclxufVxyXG5mdW5jdGlvbiBpc1Nsb3RPdXRsZXQobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMiAvKiBTTE9UICovO1xyXG59XHJcbmZ1bmN0aW9uIGluamVjdFByb3Aobm9kZSwgcHJvcCwgY29udGV4dCkge1xyXG4gICAgbGV0IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgIGNvbnN0IHByb3BzID0gbm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovID8gbm9kZS5wcm9wcyA6IG5vZGUuYXJndW1lbnRzWzJdO1xyXG4gICAgaWYgKHByb3BzID09IG51bGwgfHwgaXNTdHJpbmcocHJvcHMpKSB7XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgLy8gbWVyZ2VkIHByb3BzLi4uIGFkZCBvdXJzXHJcbiAgICAgICAgLy8gb25seSBpbmplY3Qga2V5IHRvIG9iamVjdCBsaXRlcmFsIGlmIGl0J3MgdGhlIGZpcnN0IGFyZ3VtZW50IHNvIHRoYXRcclxuICAgICAgICAvLyBpZiBkb2Vzbid0IG92ZXJyaWRlIHVzZXIgcHJvdmlkZWQga2V5c1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gcHJvcHMuYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoZmlyc3QpICYmIGZpcnN0LnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGZpcnN0LnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5jYWxsZWUgPT09IFRPX0hBTkRMRVJTKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjM2NlxyXG4gICAgICAgICAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmFyZ3VtZW50cy51bnNoaWZ0KGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgIXByb3BzV2l0aEluamVjdGlvbiAmJiAocHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBsZXQgYWxyZWFkeUV4aXN0cyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGNoZWNrIGV4aXN0aW5nIGtleSB0byBhdm9pZCBvdmVycmlkaW5nIHVzZXIgcHJvdmlkZWQga2V5c1xyXG4gICAgICAgIGlmIChwcm9wLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BLZXlOYW1lID0gcHJvcC5rZXkuY29udGVudDtcclxuICAgICAgICAgICAgYWxyZWFkeUV4aXN0cyA9IHByb3BzLnByb3BlcnRpZXMuc29tZShwID0+IHAua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgICAgIHAua2V5LmNvbnRlbnQgPT09IHByb3BLZXlOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhbHJlYWR5RXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggZXhwcmVzc2lvbiwgcmV0dXJuIGEgbWVyZ2VkIHJlcGxhY2VtZW50XHJcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcclxuICAgICAgICAgICAgcHJvcHNcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICBub2RlLnByb3BzID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbm9kZS5hcmd1bWVudHNbMl0gPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9WYWxpZEFzc2V0SWQobmFtZSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIGBfJHt0eXBlfV8ke25hbWUucmVwbGFjZSgvW15cXHddL2csICdfJyl9YDtcclxufVxyXG4vLyBDaGVjayBpZiBhIG5vZGUgY29udGFpbnMgZXhwcmVzc2lvbnMgdGhhdCByZWZlcmVuY2UgY3VycmVudCBjb250ZXh0IHNjb3BlIGlkc1xyXG5mdW5jdGlvbiBoYXNTY29wZVJlZihub2RlLCBpZHMpIHtcclxuICAgIGlmICghbm9kZSB8fCBPYmplY3Qua2V5cyhpZHMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChoYXNTY29wZVJlZihwLmFyZywgaWRzKSB8fCBoYXNTY29wZVJlZihwLmV4cCwgaWRzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLnNvdXJjZSwgaWRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYnJhbmNoZXMuc29tZShiID0+IGhhc1Njb3BlUmVmKGIsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICBpZiAoaGFzU2NvcGVSZWYobm9kZS5jb25kaXRpb24sIGlkcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiAoIW5vZGUuaXNTdGF0aWMgJiZcclxuICAgICAgICAgICAgICAgIGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpICYmXHJcbiAgICAgICAgICAgICAgICAhIWlkc1tub2RlLmNvbnRlbnRdKTtcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGlzT2JqZWN0KGMpICYmIGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICByZXR1cm4gaGFzU2NvcGVSZWYobm9kZS5jb250ZW50LCBpZHMpO1xyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgZGVwcmVjYXRpb25EYXRhID0ge1xyXG4gICAgW1wiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFBsYXRmb3JtLW5hdGl2ZSBlbGVtZW50cyB3aXRoIFwiaXNcIiBwcm9wIHdpbGwgbm8gbG9uZ2VyIGJlIGAgK1xyXG4gICAgICAgICAgICBgdHJlYXRlZCBhcyBjb21wb25lbnRzIGluIFZ1ZSAzIHVubGVzcyB0aGUgXCJpc1wiIHZhbHVlIGlzIGV4cGxpY2l0bHkgYCArXHJcbiAgICAgICAgICAgIGBwcmVmaXhlZCB3aXRoIFwidnVlOlwiLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9jdXN0b20tZWxlbWVudHMtaW50ZXJvcC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9TWU5DXCIgLyogQ09NUElMRVJfVl9CSU5EX1NZTkMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZToga2V5ID0+IGAuc3luYyBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2LW1vZGVsIHdpdGggYCArXHJcbiAgICAgICAgICAgIGBhcmd1bWVudCBpbnN0ZWFkLiBcXGB2LWJpbmQ6JHtrZXl9LnN5bmNcXGAgc2hvdWxkIGJlIGNoYW5nZWQgdG8gYCArXHJcbiAgICAgICAgICAgIGBcXGB2LW1vZGVsOiR7a2V5fVxcYC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdi1tb2RlbC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9QUk9QXCIgLyogQ09NUElMRVJfVl9CSU5EX1BST1AgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYC5wcm9wIG1vZGlmaWVyIGZvciB2LWJpbmQgaGFzIGJlZW4gcmVtb3ZlZCBhbmQgbm8gbG9uZ2VyIG5lY2Vzc2FyeS4gYCArXHJcbiAgICAgICAgICAgIGBWdWUgMyB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IGEgYmluZGluZyBhcyBET00gcHJvcGVydHkgd2hlbiBhcHByb3ByaWF0ZS5gXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiIC8qIENPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHYtYmluZD1cIm9ialwiIHVzYWdlIGlzIG5vdyBvcmRlciBzZW5zaXRpdmUgYW5kIGJlaGF2ZXMgbGlrZSBKYXZhU2NyaXB0IGAgK1xyXG4gICAgICAgICAgICBgb2JqZWN0IHNwcmVhZDogaXQgd2lsbCBub3cgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIG5vbi1tZXJnZWFibGUgYXR0cmlidXRlIGAgK1xyXG4gICAgICAgICAgICBgdGhhdCBhcHBlYXJzIGJlZm9yZSB2LWJpbmQgaW4gdGhlIGNhc2Ugb2YgY29uZmxpY3QuIGAgK1xyXG4gICAgICAgICAgICBgVG8gcmV0YWluIDIueCBiZWhhdmlvciwgbW92ZSB2LWJpbmQgdG8gbWFrZSBpdCB0aGUgZmlyc3QgYXR0cmlidXRlLiBgICtcclxuICAgICAgICAgICAgYFlvdSBjYW4gYWxzbyBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaWYgdGhlIHVzYWdlIGlzIGludGVuZGVkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi92LWJpbmQuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENPTVBJTEVSX1ZfT05fTkFUSVZFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdi1vbi1uYXRpdmUtbW9kaWZpZXItcmVtb3ZlZC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdi1pZiAvIHYtZm9yIHByZWNlZGVuY2Ugd2hlbiB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnQgaGFzIGNoYW5nZWQgYCArXHJcbiAgICAgICAgICAgIGBpbiBWdWUgMzogdi1pZiBub3cgdGFrZXMgaGlnaGVyIHByZWNlZGVuY2UgYW5kIHdpbGwgbm8gbG9uZ2VyIGhhdmUgYCArXHJcbiAgICAgICAgICAgIGBhY2Nlc3MgdG8gdi1mb3Igc2NvcGUgdmFyaWFibGVzLiBJdCBpcyBiZXN0IHRvIGF2b2lkIHRoZSBhbWJpZ3VpdHkgYCArXHJcbiAgICAgICAgICAgIGB3aXRoIDx0ZW1wbGF0ZT4gdGFncyBvciB1c2UgYSBjb21wdXRlZCBwcm9wZXJ0eSB0aGF0IGZpbHRlcnMgdi1mb3IgYCArXHJcbiAgICAgICAgICAgIGBkYXRhIHNvdXJjZS5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdi1pZi12LWZvci5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfRk9SX1JFRlwiIC8qIENPTVBJTEVSX1ZfRk9SX1JFRiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgUmVmIHVzYWdlIG9uIHYtZm9yIG5vIGxvbmdlciBjcmVhdGVzIGFycmF5IHJlZiB2YWx1ZXMgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgQ29uc2lkZXIgdXNpbmcgZnVuY3Rpb24gcmVmcyBvciByZWZhY3RvciB0byBhdm9pZCByZWYgdXNhZ2UgYWx0b2dldGhlci5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vYXJyYXktcmVmcy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiIC8qIENPTVBJTEVSX05BVElWRV9URU1QTEFURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgPHRlbXBsYXRlPiB3aXRoIG5vIHNwZWNpYWwgZGlyZWN0aXZlcyB3aWxsIHJlbmRlciBhcyBhIG5hdGl2ZSB0ZW1wbGF0ZSBgICtcclxuICAgICAgICAgICAgYGVsZW1lbnQgaW5zdGVhZCBvZiBpdHMgaW5uZXIgY29udGVudCBpbiBWdWUgMy5gXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFXCIgLyogQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBcImlubGluZS10ZW1wbGF0ZVwiIGhhcyBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2lubGluZS10ZW1wbGF0ZS1hdHRyaWJ1dGUuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDT01QSUxFUl9GSUxURVJTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBmaWx0ZXJzIGhhdmUgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFRoZSBcInxcIiBzeW1ib2wgd2lsbCBiZSB0cmVhdGVkIGFzIG5hdGl2ZSBKYXZhU2NyaXB0IGJpdHdpc2UgT1Igb3BlcmF0b3IuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIG1ldGhvZCBjYWxscyBvciBjb21wdXRlZCBwcm9wZXJ0aWVzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2ZpbHRlcnMuaHRtbGBcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBjb25maWcgPSBjb250ZXh0Lm9wdGlvbnNcclxuICAgICAgICA/IGNvbnRleHQub3B0aW9ucy5jb21wYXRDb25maWdcclxuICAgICAgICA6IGNvbnRleHQuY29tcGF0Q29uZmlnO1xyXG4gICAgY29uc3QgdmFsdWUgPSBjb25maWcgJiYgY29uZmlnW2tleV07XHJcbiAgICBpZiAoa2V5ID09PSAnTU9ERScpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgfHwgMzsgLy8gY29tcGlsZXIgZGVmYXVsdHMgdG8gdjMgYmVoYXZpb3JcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtb2RlID0gZ2V0Q29tcGF0VmFsdWUoJ01PREUnLCBjb250ZXh0KTtcclxuICAgIGNvbnN0IHZhbHVlID0gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KTtcclxuICAgIC8vIGluIHYzIG1vZGUsIG9ubHkgZW5hYmxlIGlmIGV4cGxpY2l0bHkgc2V0IHRvIHRydWVcclxuICAgIC8vIG90aGVyd2lzZSBlbmFibGUgZm9yIGFueSBub24tZmFsc2UgdmFsdWVcclxuICAgIHJldHVybiBtb2RlID09PSAzID8gdmFsdWUgPT09IHRydWUgOiB2YWx1ZSAhPT0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKSB7XHJcbiAgICBjb25zdCBlbmFibGVkID0gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGVuYWJsZWQpIHtcclxuICAgICAgICB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuYWJsZWQ7XHJcbn1cclxuZnVuY3Rpb24gd2FybkRlcHJlY2F0aW9uKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKSB7XHJcbiAgICBjb25zdCB2YWwgPSBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpO1xyXG4gICAgaWYgKHZhbCA9PT0gJ3N1cHByZXNzLXdhcm5pbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtZXNzYWdlLCBsaW5rIH0gPSBkZXByZWNhdGlvbkRhdGFba2V5XTtcclxuICAgIGNvbnN0IG1zZyA9IGAoZGVwcmVjYXRpb24gJHtrZXl9KSAke3R5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nID8gbWVzc2FnZSguLi5hcmdzKSA6IG1lc3NhZ2V9JHtsaW5rID8gYFxcbiAgRGV0YWlsczogJHtsaW5rfWAgOiBgYH1gO1xyXG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKG1zZyk7XHJcbiAgICBlcnIuY29kZSA9IGtleTtcclxuICAgIGlmIChsb2MpXHJcbiAgICAgICAgZXJyLmxvYyA9IGxvYztcclxuICAgIGNvbnRleHQub25XYXJuKGVycik7XHJcbn1cblxuLy8gVGhlIGRlZmF1bHQgZGVjb2RlciBvbmx5IHByb3ZpZGVzIGVzY2FwZXMgZm9yIGNoYXJhY3RlcnMgcmVzZXJ2ZWQgYXMgcGFydCBvZlxyXG4vLyB0aGUgdGVtcGxhdGUgc3ludGF4LCBhbmQgaXMgb25seSB1c2VkIGlmIHRoZSBjdXN0b20gcmVuZGVyZXIgZGlkIG5vdCBwcm92aWRlXHJcbi8vIGEgcGxhdGZvcm0tc3BlY2lmaWMgZGVjb2Rlci5cclxuY29uc3QgZGVjb2RlUkUgPSAvJihndHxsdHxhbXB8YXBvc3xxdW90KTsvZztcclxuY29uc3QgZGVjb2RlTWFwID0ge1xyXG4gICAgZ3Q6ICc+JyxcclxuICAgIGx0OiAnPCcsXHJcbiAgICBhbXA6ICcmJyxcclxuICAgIGFwb3M6IFwiJ1wiLFxyXG4gICAgcXVvdDogJ1wiJ1xyXG59O1xyXG5jb25zdCBkZWZhdWx0UGFyc2VyT3B0aW9ucyA9IHtcclxuICAgIGRlbGltaXRlcnM6IFtge3tgLCBgfX1gXSxcclxuICAgIGdldE5hbWVzcGFjZTogKCkgPT4gMCAvKiBIVE1MICovLFxyXG4gICAgZ2V0VGV4dE1vZGU6ICgpID0+IDAgLyogREFUQSAqLyxcclxuICAgIGlzVm9pZFRhZzogTk8sXHJcbiAgICBpc1ByZVRhZzogTk8sXHJcbiAgICBpc0N1c3RvbUVsZW1lbnQ6IE5PLFxyXG4gICAgZGVjb2RlRW50aXRpZXM6IChyYXdUZXh0KSA9PiByYXdUZXh0LnJlcGxhY2UoZGVjb2RlUkUsIChfLCBwMSkgPT4gZGVjb2RlTWFwW3AxXSksXHJcbiAgICBvbkVycm9yOiBkZWZhdWx0T25FcnJvcixcclxuICAgIG9uV2FybjogZGVmYXVsdE9uV2FybixcclxuICAgIGNvbW1lbnRzOiBmYWxzZVxyXG59O1xyXG5mdW5jdGlvbiBiYXNlUGFyc2UoY29udGVudCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJvb3QocGFyc2VDaGlsZHJlbihjb250ZXh0LCAwIC8qIERBVEEgKi8sIFtdKSwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCByYXdPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0UGFyc2VyT3B0aW9ucyk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdPcHRpb25zKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHJhd09wdGlvbnNba2V5XSB8fCBkZWZhdWx0UGFyc2VyT3B0aW9uc1trZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIGNvbHVtbjogMSxcclxuICAgICAgICBsaW5lOiAxLFxyXG4gICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogY29udGVudCxcclxuICAgICAgICBzb3VyY2U6IGNvbnRlbnQsXHJcbiAgICAgICAgaW5QcmU6IGZhbHNlLFxyXG4gICAgICAgIGluVlByZTogZmFsc2UsXHJcbiAgICAgICAgb25XYXJuOiBvcHRpb25zLm9uV2FyblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykge1xyXG4gICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xyXG4gICAgY29uc3QgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiAwIC8qIEhUTUwgKi87XHJcbiAgICBjb25zdCBub2RlcyA9IFtdO1xyXG4gICAgd2hpbGUgKCFpc0VuZChjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpKSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChtb2RlID09PSAwIC8qIERBVEEgKi8gfHwgbW9kZSA9PT0gMSAvKiBSQ0RBVEEgKi8pIHtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiBzdGFydHNXaXRoKHMsIGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gJ3t7J1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlSW50ZXJwb2xhdGlvbihjb250ZXh0LCBtb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAwIC8qIERBVEEgKi8gJiYgc1swXSA9PT0gJzwnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjdGFnLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA1IC8qIEVPRl9CRUZPUkVfVEFHX05BTUUgKi8sIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJyEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI21hcmt1cC1kZWNsYXJhdGlvbi1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJzwhLS0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydHNXaXRoKHMsICc8IURPQ1RZUEUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgRE9DVFlQRSBieSBhIGxpbWl0YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFbQ0RBVEFbJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5zICE9PSAwIC8qIEhUTUwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMSAvKiBDREFUQV9JTl9IVE1MX0NPTlRFTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTEgLyogSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2VuZC10YWctb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc1syXSA9PT0gJz4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNCAvKiBNSVNTSU5HX0VORF9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9bYS16XS9pLnRlc3Qoc1syXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIzIC8qIFhfSU5WQUxJRF9FTkRfVEFHICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VUYWcoY29udGV4dCwgMSAvKiBFbmQgKi8sIHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9bYS16XS9pLnRlc3Qoc1sxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VFbGVtZW50KGNvbnRleHQsIGFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMi54IDx0ZW1wbGF0ZT4gd2l0aCBubyBkaXJlY3RpdmUgY29tcGF0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiIC8qIENPTVBJTEVSX05BVElWRV9URU1QTEFURSAqLywgY29udGV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhbm9kZS5wcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGVjaWFsVGVtcGxhdGVEaXJlY3RpdmUocC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi8sIGNvbnRleHQsIG5vZGUubG9jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIxIC8qIFVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTIgLyogSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi8sIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlID0gcGFyc2VUZXh0KGNvbnRleHQsIG1vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHVzaE5vZGUobm9kZXMsIG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFdoaXRlc3BhY2UgaGFuZGxpbmcgc3RyYXRlZ3kgbGlrZSB2MlxyXG4gICAgbGV0IHJlbW92ZWRXaGl0ZXNwYWNlID0gZmFsc2U7XHJcbiAgICBpZiAobW9kZSAhPT0gMiAvKiBSQVdURVhUICovICYmIG1vZGUgIT09IDEgLyogUkNEQVRBICovKSB7XHJcbiAgICAgICAgY29uc3QgcHJlc2VydmUgPSBjb250ZXh0Lm9wdGlvbnMud2hpdGVzcGFjZSA9PT0gJ3ByZXNlcnZlJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmluUHJlICYmIG5vZGUudHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIS9bXlxcdFxcclxcblxcZiBdLy50ZXN0KG5vZGUuY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gbm9kZXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2Rlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGlmOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlIHdoaXRlc3BhY2UgaXMgdGhlIGZpcnN0IG9yIGxhc3Qgbm9kZSwgb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSAoY29uZGVuc2UgbW9kZSkgdGhlIHdoaXRlc3BhY2UgaXMgYWRqYWNlbnQgdG8gYSBjb21tZW50LCBvcjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIChjb25kZW5zZSBtb2RlKSB0aGUgd2hpdGVzcGFjZSBpcyBiZXR3ZWVuIHR3byBlbGVtZW50cyBBTkQgY29udGFpbnMgbmV3bGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhbmV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXByZXNlcnZlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvW1xcclxcbl0vLnRlc3Qobm9kZS5jb250ZW50KSkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHdoaXRlc3BhY2UgaXMgY29uZGVuc2VkIGludG8gYSBzaW5nbGUgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwcmVzZXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGluIHRleHQgYXJlIGNvbmRlbnNlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdG8gYSBzaW5nbGUgc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2UoL1tcXHRcXHJcXG5cXGYgXSsvZywgJyAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIHJlbW92ZSBjb21tZW50IG5vZGVzIGluIHByb2QgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICFjb250ZXh0Lm9wdGlvbnMuY29tbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRXaGl0ZXNwYWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dC5pblByZSAmJiBwYXJlbnQgJiYgY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHBhcmVudC50YWcpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIG5ld2xpbmUgcGVyIGh0bWwgc3BlY1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9ncm91cGluZy1jb250ZW50Lmh0bWwjdGhlLXByZS1lbGVtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gbm9kZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBmaXJzdC50eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdC5jb250ZW50LnJlcGxhY2UoL15cXHI/XFxuLywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZWRXaGl0ZXNwYWNlID8gbm9kZXMuZmlsdGVyKEJvb2xlYW4pIDogbm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gcHVzaE5vZGUobm9kZXMsIG5vZGUpIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgIGNvbnN0IHByZXYgPSBsYXN0KG5vZGVzKTtcclxuICAgICAgICAvLyBNZXJnZSBpZiBib3RoIHRoaXMgYW5kIHRoZSBwcmV2aW91cyBub2RlIGFyZSB0ZXh0IGFuZCB0aG9zZSBhcmVcclxuICAgICAgICAvLyBjb25zZWN1dGl2ZS4gVGhpcyBoYXBwZW5zIGZvciBjYXNlcyBsaWtlIFwiYSA8IGJcIi5cclxuICAgICAgICBpZiAocHJldiAmJlxyXG4gICAgICAgICAgICBwcmV2LnR5cGUgPT09IDIgLyogVEVYVCAqLyAmJlxyXG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQub2Zmc2V0ID09PSBub2RlLmxvYy5zdGFydC5vZmZzZXQpIHtcclxuICAgICAgICAgICAgcHJldi5jb250ZW50ICs9IG5vZGUuY29udGVudDtcclxuICAgICAgICAgICAgcHJldi5sb2MuZW5kID0gbm9kZS5sb2MuZW5kO1xyXG4gICAgICAgICAgICBwcmV2LmxvYy5zb3VyY2UgKz0gbm9kZS5sb2Muc291cmNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbm9kZXMucHVzaChub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycykge1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIDkpO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIDMgLyogQ0RBVEEgKi8sIGFuY2VzdG9ycyk7XHJcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDYgLyogRU9GX0lOX0NEQVRBICovKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlcztcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNvbW1lbnQoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIC8vIFJlZ3VsYXIgY29tbWVudC5cclxuICAgIGNvbnN0IG1hdGNoID0gLy0tKFxcISk/Pi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA3IC8qIEVPRl9JTl9DT01NRU5UICovKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA8PSAzKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAwIC8qIEFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEwIC8qIElOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICAvLyBBZHZhbmNpbmcgd2l0aCByZXBvcnRpbmcgbmVzdGVkIGNvbW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCBtYXRjaC5pbmRleCk7XHJcbiAgICAgICAgbGV0IHByZXZJbmRleCA9IDEsIG5lc3RlZEluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAoKG5lc3RlZEluZGV4ID0gcy5pbmRleE9mKCc8IS0tJywgcHJldkluZGV4KSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBuZXN0ZWRJbmRleCAtIHByZXZJbmRleCArIDEpO1xyXG4gICAgICAgICAgICBpZiAobmVzdGVkSW5kZXggKyA0IDwgcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNiAvKiBORVNURURfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldkluZGV4ID0gbmVzdGVkSW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSBwcmV2SW5kZXggKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMyAvKiBDT01NRU5UICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY29udGVudFN0YXJ0ID0gY29udGV4dC5zb3VyY2VbMV0gPT09ICc/JyA/IDEgOiAyO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZignPicpO1xyXG4gICAgaWYgKGNsb3NlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRlbnRTdGFydCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0LCBjbG9zZUluZGV4KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2VJbmRleCArIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAzIC8qIENPTU1FTlQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VFbGVtZW50KGNvbnRleHQsIGFuY2VzdG9ycykge1xyXG4gICAgLy8gU3RhcnQgdGFnLlxyXG4gICAgY29uc3Qgd2FzSW5QcmUgPSBjb250ZXh0LmluUHJlO1xyXG4gICAgY29uc3Qgd2FzSW5WUHJlID0gY29udGV4dC5pblZQcmU7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gcGFyc2VUYWcoY29udGV4dCwgMCAvKiBTdGFydCAqLywgcGFyZW50KTtcclxuICAgIGNvbnN0IGlzUHJlQm91bmRhcnkgPSBjb250ZXh0LmluUHJlICYmICF3YXNJblByZTtcclxuICAgIGNvbnN0IGlzVlByZUJvdW5kYXJ5ID0gY29udGV4dC5pblZQcmUgJiYgIXdhc0luVlByZTtcclxuICAgIGlmIChlbGVtZW50LmlzU2VsZkNsb3NpbmcgfHwgY29udGV4dC5vcHRpb25zLmlzVm9pZFRhZyhlbGVtZW50LnRhZykpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIC8vIENoaWxkcmVuLlxyXG4gICAgYW5jZXN0b3JzLnB1c2goZWxlbWVudCk7XHJcbiAgICBjb25zdCBtb2RlID0gY29udGV4dC5vcHRpb25zLmdldFRleHRNb2RlKGVsZW1lbnQsIHBhcmVudCk7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKTtcclxuICAgIGFuY2VzdG9ycy5wb3AoKTtcclxuICAgIC8vIDIueCBpbmxpbmUtdGVtcGxhdGUgY29tcGF0XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5saW5lVGVtcGxhdGVQcm9wID0gZWxlbWVudC5wcm9wcy5maW5kKHAgPT4gcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdpbmxpbmUtdGVtcGxhdGUnKTtcclxuICAgICAgICBpZiAoaW5saW5lVGVtcGxhdGVQcm9wICYmXHJcbiAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiIC8qIENPTVBJTEVSX0lOTElORV9URU1QTEFURSAqLywgY29udGV4dCwgaW5saW5lVGVtcGxhdGVQcm9wLmxvYykpIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLmVuZCk7XHJcbiAgICAgICAgICAgIGlubGluZVRlbXBsYXRlUHJvcC52YWx1ZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogVEVYVCAqLyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxvYy5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAvLyBFbmQgdGFnLlxyXG4gICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKGNvbnRleHQuc291cmNlLCBlbGVtZW50LnRhZykpIHtcclxuICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIEVuZCAqLywgcGFyZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNCAvKiBYX01JU1NJTkdfRU5EX1RBRyAqLywgMCwgZWxlbWVudC5sb2Muc3RhcnQpO1xyXG4gICAgICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDAgJiYgZWxlbWVudC50YWcudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIHN0YXJ0c1dpdGgoZmlyc3QubG9jLnNvdXJjZSwgJzwhLS0nKSkge1xyXG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDggLyogRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsZW1lbnQubG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLnN0YXJ0KTtcclxuICAgIGlmIChpc1ByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVlByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59XHJcbmNvbnN0IGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBpZixlbHNlLGVsc2UtaWYsZm9yLHNsb3RgKTtcclxuZnVuY3Rpb24gcGFyc2VUYWcoY29udGV4dCwgdHlwZSwgcGFyZW50KSB7XHJcbiAgICAvLyBUYWcgb3Blbi5cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgbWF0Y2ggPSAvXjxcXC8/KFthLXpdW15cXHRcXHJcXG5cXGYgLz5dKikvaS5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGNvbnN0IHRhZyA9IG1hdGNoWzFdO1xyXG4gICAgY29uc3QgbnMgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgIC8vIHNhdmUgY3VycmVudCBzdGF0ZSBpbiBjYXNlIHdlIG5lZWQgdG8gcmUtcGFyc2UgYXR0cmlidXRlcyB3aXRoIHYtcHJlXHJcbiAgICBjb25zdCBjdXJzb3IgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjdXJyZW50U291cmNlID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICAvLyBBdHRyaWJ1dGVzLlxyXG4gICAgbGV0IHByb3BzID0gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpO1xyXG4gICAgLy8gY2hlY2sgPHByZT4gdGFnXHJcbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHRhZykpIHtcclxuICAgICAgICBjb250ZXh0LmluUHJlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIHYtcHJlXHJcbiAgICBpZiAodHlwZSA9PT0gMCAvKiBTdGFydCAqLyAmJlxyXG4gICAgICAgICFjb250ZXh0LmluVlByZSAmJlxyXG4gICAgICAgIHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3ByZScpKSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSB0cnVlO1xyXG4gICAgICAgIC8vIHJlc2V0IGNvbnRleHRcclxuICAgICAgICBleHRlbmQoY29udGV4dCwgY3Vyc29yKTtcclxuICAgICAgICBjb250ZXh0LnNvdXJjZSA9IGN1cnJlbnRTb3VyY2U7XHJcbiAgICAgICAgLy8gcmUtcGFyc2UgYXR0cnMgYW5kIGZpbHRlciBvdXQgdi1wcmUgaXRzZWxmXHJcbiAgICAgICAgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkuZmlsdGVyKHAgPT4gcC5uYW1lICE9PSAndi1wcmUnKTtcclxuICAgIH1cclxuICAgIC8vIFRhZyBjbG9zZS5cclxuICAgIGxldCBpc1NlbGZDbG9zaW5nID0gZmFsc2U7XHJcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDkgLyogRU9GX0lOX1RBRyAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc1NlbGZDbG9zaW5nID0gc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+Jyk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovICYmIGlzU2VsZkNsb3NpbmcpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgaXNTZWxmQ2xvc2luZyA/IDIgOiAxKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIDIueCBkZXByZWNhdGlvbiBjaGVja3NcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQpKSB7XHJcbiAgICAgICAgbGV0IGhhc0lmID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGhhc0ZvciA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0lmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2ZvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNGb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNJZiAmJiBoYXNGb3IpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRSAqLywgY29udGV4dCwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgdGFnVHlwZSA9IDAgLyogRUxFTUVOVCAqLztcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmICFvcHRpb25zLmlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XHJcbiAgICAgICAgY29uc3QgaGFzVklzID0gcHJvcHMuc29tZShwID0+IHtcclxuICAgICAgICAgICAgaWYgKHAubmFtZSAhPT0gJ2lzJylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgLy8gdi1pcz1cInh4eFwiIChUT0RPOiBkZXByZWNhdGUpXHJcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpcz1cInZ1ZTp4eHhcIlxyXG4gICAgICAgICAgICBpZiAocC52YWx1ZSAmJiBwLnZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbiBjb21wYXQgbW9kZSwgYW55IGlzIHVzYWdlIGlzIGNvbnNpZGVyZWQgYSBjb21wb25lbnRcclxuICAgICAgICAgICAgaWYgKGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDT01QSUxFUl9JU19PTl9FTEVNRU5UICovLCBjb250ZXh0LCBwLmxvYykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNOYXRpdmVUYWcgJiYgIWhhc1ZJcykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaXNOYXRpdmVUYWcodGFnKSlcclxuICAgICAgICAgICAgICAgIHRhZ1R5cGUgPSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzVklzIHx8XHJcbiAgICAgICAgICAgIGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8XHJcbiAgICAgICAgICAgIChvcHRpb25zLmlzQnVpbHRJbkNvbXBvbmVudCAmJiBvcHRpb25zLmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpKSB8fFxyXG4gICAgICAgICAgICAvXltBLVpdLy50ZXN0KHRhZykgfHxcclxuICAgICAgICAgICAgdGFnID09PSAnY29tcG9uZW50Jykge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YWcgPT09ICdzbG90Jykge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMiAvKiBTTE9UICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICd0ZW1wbGF0ZScgJiZcclxuICAgICAgICAgICAgcHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgaXNTcGVjaWFsVGVtcGxhdGVEaXJlY3RpdmUocC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDMgLyogVEVNUExBVEUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxIC8qIEVMRU1FTlQgKi8sXHJcbiAgICAgICAgbnMsXHJcbiAgICAgICAgdGFnLFxyXG4gICAgICAgIHRhZ1R5cGUsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgaXNTZWxmQ2xvc2luZyxcclxuICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQgLy8gdG8gYmUgY3JlYXRlZCBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xyXG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XHJcbiAgICB3aGlsZSAoY29udGV4dC5zb3VyY2UubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnPicpICYmXHJcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvJykpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIyIC8qIFVORVhQRUNURURfU09MSURVU19JTl9UQUcgKi8pO1xyXG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gMSAvKiBFbmQgKi8pIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDMgLyogRU5EX1RBR19XSVRIX0FUVFJJQlVURVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdHRyID0gcGFyc2VBdHRyaWJ1dGUoY29udGV4dCwgYXR0cmlidXRlTmFtZXMpO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAwIC8qIFN0YXJ0ICovKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnB1c2goYXR0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgvXlteXFx0XFxyXFxuXFxmIC8+XS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIG5hbWVTZXQpIHtcclxuICAgIC8vIE5hbWUuXHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiAvPl1bXlxcdFxcclxcblxcZiAvPj1dKi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBjb25zdCBuYW1lID0gbWF0Y2hbMF07XHJcbiAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovKTtcclxuICAgIH1cclxuICAgIG5hbWVTZXQuYWRkKG5hbWUpO1xyXG4gICAgaWYgKG5hbWVbMF0gPT09ICc9Jykge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqLyk7XHJcbiAgICB9XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IC9bXCInPF0vZztcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBwYXR0ZXJuLmV4ZWMobmFtZSkpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqLywgbS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5hbWUubGVuZ3RoKTtcclxuICAgIC8vIFZhbHVlXHJcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoL15bXFx0XFxyXFxuXFxmIF0qPS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIHZhbHVlID0gcGFyc2VBdHRyaWJ1dGVWYWx1ZShjb250ZXh0KTtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KTtcclxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgL14odi18OnxAfCMpLy50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvKD86XnYtKFthLXowLTktXSspKT8oPzooPzo6fF5AfF4jKShcXFtbXlxcXV0rXFxdfFteXFwuXSspKT8oLispPyQvaS5leGVjKG5hbWUpO1xyXG4gICAgICAgIGxldCBkaXJOYW1lID0gbWF0Y2hbMV0gfHxcclxuICAgICAgICAgICAgKHN0YXJ0c1dpdGgobmFtZSwgJzonKSA/ICdiaW5kJyA6IHN0YXJ0c1dpdGgobmFtZSwgJ0AnKSA/ICdvbicgOiAnc2xvdCcpO1xyXG4gICAgICAgIGxldCBhcmc7XHJcbiAgICAgICAgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2xvdCA9IGRpck5hbWUgPT09ICdzbG90JztcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuYW1lLmxhc3RJbmRleE9mKG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCksIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCArIG1hdGNoWzJdLmxlbmd0aCArICgoaXNTbG90ICYmIG1hdGNoWzNdKSB8fCAnJykubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gbWF0Y2hbMl07XHJcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJ1snKSkge1xyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5lbmRzV2l0aCgnXScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI2IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyKDEsIGNvbnRlbnQubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjMTI0MSBzcGVjaWFsIGNhc2UgZm9yIHYtc2xvdDogdnVldGlmeSByZWxpZXMgZXh0ZW5zaXZlbHkgb24gc2xvdFxyXG4gICAgICAgICAgICAgICAgLy8gbmFtZXMgY29udGFpbmluZyBkb3RzLiB2LXNsb3QgZG9lc24ndCBoYXZlIGFueSBtb2RpZmllcnMgYW5kIFZ1ZSAyLnhcclxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRzIHN1Y2ggdXNhZ2Ugc28gd2UgYXJlIGtlZXBpbmcgaXQgY29uc2lzdGVudCB3aXRoIDIueC5cclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gbWF0Y2hbM10gfHwgJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJnID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyxcclxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogaXNTdGF0aWNcclxuICAgICAgICAgICAgICAgICAgICA/IDMgLyogQ0FOX1NUUklOR0lGWSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzUXVvdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTG9jID0gdmFsdWUubG9jO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zdGFydC5vZmZzZXQrKztcclxuICAgICAgICAgICAgdmFsdWVMb2Muc3RhcnQuY29sdW1uKys7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLmVuZCA9IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSh2YWx1ZUxvYy5zdGFydCwgdmFsdWUuY29udGVudCk7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnNvdXJjZSA9IHZhbHVlTG9jLnNvdXJjZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IG1hdGNoWzNdID8gbWF0Y2hbM10uc3Vic3RyKDEpLnNwbGl0KCcuJykgOiBbXTtcclxuICAgICAgICAvLyAyLnggY29tcGF0IHYtYmluZDpmb28uc3luYyAtPiB2LW1vZGVsOmZvb1xyXG4gICAgICAgIGlmIChkaXJOYW1lID09PSAnYmluZCcgJiYgYXJnKSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3N5bmMnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDT01QSUxFUl9WX0JJTkRfU1lOQyAqLywgY29udGV4dCwgbG9jLCBhcmcubG9jLnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgIGRpck5hbWUgPSAnbW9kZWwnO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnNwbGljZShtb2RpZmllcnMuaW5kZXhPZignc3luYycpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1vZGlmaWVycy5pbmNsdWRlcygncHJvcCcpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfUFJPUFwiIC8qIENPTVBJTEVSX1ZfQklORF9QUk9QICovLCBjb250ZXh0LCBsb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICBuYW1lOiBkaXJOYW1lLFxyXG4gICAgICAgICAgICBleHA6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgYXMgbm9uLWNvbnN0YW50IGJ5IGRlZmF1bHQuIFRoaXMgY2FuIGJlIHBvdGVudGlhbGx5IHNldCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdmFsdWVzIGJ5IGB0cmFuc2Zvcm1FeHByZXNzaW9uYCB0byBtYWtlIGl0IGVsaWdpYmxlIGZvciBob2lzdGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVycyxcclxuICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNiAvKiBBVFRSSUJVVEUgKi8sXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICB2YWx1ZTogdmFsdWUgJiYge1xyXG4gICAgICAgICAgICB0eXBlOiAyIC8qIFRFWFQgKi8sXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmNvbnRlbnQsXHJcbiAgICAgICAgICAgIGxvYzogdmFsdWUubG9jXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVWYWx1ZShjb250ZXh0KSB7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgY29uc3QgcXVvdGUgPSBjb250ZXh0LnNvdXJjZVswXTtcclxuICAgIGNvbnN0IGlzUXVvdGVkID0gcXVvdGUgPT09IGBcImAgfHwgcXVvdGUgPT09IGAnYDtcclxuICAgIGlmIChpc1F1b3RlZCkge1xyXG4gICAgICAgIC8vIFF1b3RlZCB2YWx1ZS5cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKHF1b3RlKTtcclxuICAgICAgICBpZiAoZW5kSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCwgNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgZW5kSW5kZXgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFVucXVvdGVkXHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvXlteXFx0XFxyXFxuXFxmID5dKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bmV4cGVjdGVkQ2hhcnMgPSAvW1wiJzw9YF0vZztcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSB1bmV4cGVjdGVkQ2hhcnMuZXhlYyhtYXRjaFswXSkpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOCAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9VTlFVT1RFRF9BVFRSSUJVVEVfVkFMVUUgKi8sIG0uaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGNvbnRlbnQsIGlzUXVvdGVkLCBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSkge1xyXG4gICAgY29uc3QgW29wZW4sIGNsb3NlXSA9IGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzO1xyXG4gICAgY29uc3QgY2xvc2VJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoY2xvc2UsIG9wZW4ubGVuZ3RoKTtcclxuICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNSAvKiBYX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkQgKi8pO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBvcGVuLmxlbmd0aCk7XHJcbiAgICBjb25zdCBpbm5lclN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgaW5uZXJFbmQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCByYXdDb250ZW50TGVuZ3RoID0gY2xvc2VJbmRleCAtIG9wZW4ubGVuZ3RoO1xyXG4gICAgY29uc3QgcmF3Q29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIHJhd0NvbnRlbnRMZW5ndGgpO1xyXG4gICAgY29uc3QgcHJlVHJpbUNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIHJhd0NvbnRlbnRMZW5ndGgsIG1vZGUpO1xyXG4gICAgY29uc3QgY29udGVudCA9IHByZVRyaW1Db250ZW50LnRyaW0oKTtcclxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gcHJlVHJpbUNvbnRlbnQuaW5kZXhPZihjb250ZW50KTtcclxuICAgIGlmIChzdGFydE9mZnNldCA+IDApIHtcclxuICAgICAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJTdGFydCwgcmF3Q29udGVudCwgc3RhcnRPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gcmF3Q29udGVudExlbmd0aCAtIChwcmVUcmltQ29udGVudC5sZW5ndGggLSBjb250ZW50Lmxlbmd0aCAtIHN0YXJ0T2Zmc2V0KTtcclxuICAgIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihpbm5lckVuZCwgcmF3Q29udGVudCwgZW5kT2Zmc2V0KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBjbG9zZS5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA1IC8qIElOVEVSUE9MQVRJT04gKi8sXHJcbiAgICAgICAgY29udGVudDoge1xyXG4gICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vIFNldCBgaXNDb25zdGFudGAgdG8gZmFsc2UgYnkgZGVmYXVsdCBhbmQgd2lsbCBkZWNpZGUgaW4gdHJhbnNmb3JtRXhwcmVzc2lvblxyXG4gICAgICAgICAgICBjb25zdFR5cGU6IDAgLyogTk9UX0NPTlNUQU5UICovLFxyXG4gICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBpbm5lclN0YXJ0LCBpbm5lckVuZClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVRleHQoY29udGV4dCwgbW9kZSkge1xyXG4gICAgY29uc3QgZW5kVG9rZW5zID0gWyc8JywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF1dO1xyXG4gICAgaWYgKG1vZGUgPT09IDMgLyogQ0RBVEEgKi8pIHtcclxuICAgICAgICBlbmRUb2tlbnMucHVzaCgnXV0+Jyk7XHJcbiAgICB9XHJcbiAgICBsZXQgZW5kSW5kZXggPSBjb250ZXh0LnNvdXJjZS5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZFRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihlbmRUb2tlbnNbaV0sIDEpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgZW5kSW5kZXggPiBpbmRleCkge1xyXG4gICAgICAgICAgICBlbmRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgZW5kSW5kZXgsIG1vZGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyIC8qIFRFWFQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0ZXh0IGRhdGEgd2l0aCBhIGdpdmVuIGxlbmd0aCBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxyXG4gKiBUaGlzIHRyYW5zbGF0ZXMgSFRNTCBlbnRpdGllcyBpbiB0aGUgdGV4dCBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBsZW5ndGgsIG1vZGUpIHtcclxuICAgIGNvbnN0IHJhd1RleHQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCBsZW5ndGgpO1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGxlbmd0aCk7XHJcbiAgICBpZiAobW9kZSA9PT0gMiAvKiBSQVdURVhUICovIHx8XHJcbiAgICAgICAgbW9kZSA9PT0gMyAvKiBDREFUQSAqLyB8fFxyXG4gICAgICAgIHJhd1RleHQuaW5kZXhPZignJicpID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiByYXdUZXh0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gREFUQSBvciBSQ0RBVEEgY29udGFpbmluZyBcIiZcIlwiLiBFbnRpdHkgZGVjb2RpbmcgcmVxdWlyZWQuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQub3B0aW9ucy5kZWNvZGVFbnRpdGllcyhyYXdUZXh0LCBtb2RlID09PSA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3Vyc29yKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29sdW1uLCBsaW5lLCBvZmZzZXQgfSA9IGNvbnRleHQ7XHJcbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCwgZW5kKSB7XHJcbiAgICBlbmQgPSBlbmQgfHwgZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBlbmQsXHJcbiAgICAgICAgc291cmNlOiBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbGFzdCh4cykge1xyXG4gICAgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc291cmNlLCBzZWFyY2hTdHJpbmcpIHtcclxuICAgIHJldHVybiBzb3VyY2Uuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIGFkdmFuY2VCeShjb250ZXh0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcclxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBjb250ZXh0O1xyXG4gICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGNvbnRleHQsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxuICAgIGNvbnRleHQuc291cmNlID0gc291cmNlLnNsaWNlKG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZVNwYWNlcyhjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IC9eW1xcdFxcclxcblxcZiBdKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSB7XHJcbiAgICByZXR1cm4gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHN0YXJ0LCBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG5mdW5jdGlvbiBlbWl0RXJyb3IoY29udGV4dCwgY29kZSwgb2Zmc2V0LCBsb2MgPSBnZXRDdXJzb3IoY29udGV4dCkpIHtcclxuICAgIGlmIChvZmZzZXQpIHtcclxuICAgICAgICBsb2Mub2Zmc2V0ICs9IG9mZnNldDtcclxuICAgICAgICBsb2MuY29sdW1uICs9IG9mZnNldDtcclxuICAgIH1cclxuICAgIGNvbnRleHQub3B0aW9ucy5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwge1xyXG4gICAgICAgIHN0YXJ0OiBsb2MsXHJcbiAgICAgICAgZW5kOiBsb2MsXHJcbiAgICAgICAgc291cmNlOiAnJ1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRW5kKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykge1xyXG4gICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8LycpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSBiYWQgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgYW5jZXN0b3JzW2ldLnRhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMSAvKiBSQ0RBVEEgKi86XHJcbiAgICAgICAgY2FzZSAyIC8qIFJBV1RFWFQgKi86IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHMsIHBhcmVudC50YWcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzIC8qIENEQVRBICovOlxyXG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnXV0+JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICFzO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHNvdXJjZSwgdGFnKSB7XHJcbiAgICByZXR1cm4gKHN0YXJ0c1dpdGgoc291cmNlLCAnPC8nKSAmJlxyXG4gICAgICAgIHNvdXJjZS5zdWJzdHIoMiwgdGFnLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgICAvW1xcdFxcclxcblxcZiAvPl0vLnRlc3Qoc291cmNlWzIgKyB0YWcubGVuZ3RoXSB8fCAnPicpKTtcclxufVxuXG5mdW5jdGlvbiBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KSB7XHJcbiAgICB3YWxrKHJvb3QsIGNvbnRleHQsIFxyXG4gICAgLy8gUm9vdCBub2RlIGlzIHVuZm9ydHVuYXRlbHkgbm9uLWhvaXN0YWJsZSBkdWUgdG8gcG90ZW50aWFsIHBhcmVudFxyXG4gICAgLy8gZmFsbHRocm91Z2ggYXR0cmlidXRlcy5cclxuICAgIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgcm9vdC5jaGlsZHJlblswXSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpIHtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XHJcbiAgICByZXR1cm4gKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICFpc1Nsb3RPdXRsZXQoY2hpbGQpKTtcclxufVxyXG5mdW5jdGlvbiB3YWxrKG5vZGUsIGNvbnRleHQsIGRvTm90SG9pc3ROb2RlID0gZmFsc2UpIHtcclxuICAgIGxldCBoYXNIb2lzdGVkTm9kZSA9IGZhbHNlO1xyXG4gICAgLy8gU29tZSB0cmFuc2Zvcm1zLCBlLmcuIHRyYW5zZm9ybUFzc2V0VXJscyBmcm9tIEB2dWUvY29tcGlsZXItc2ZjLCByZXBsYWNlc1xyXG4gICAgLy8gc3RhdGljIGJpbmRpbmdzIHdpdGggZXhwcmVzc2lvbnMuIFRoZXNlIGV4cHJlc3Npb25zIGFyZSBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICAvLyBjb25zdGFudCBzbyB0aGV5IGFyZSBzdGlsbCBlbGlnaWJsZSBmb3IgaG9pc3RpbmcsIGJ1dCB0aGV5IGFyZSBvbmx5XHJcbiAgICAvLyBhdmFpbGFibGUgYXQgcnVudGltZSBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSBldmFsdWF0ZWQgYWhlYWQgb2YgdGltZS5cclxuICAgIC8vIFRoaXMgaXMgb25seSBhIGNvbmNlcm4gZm9yIHByZS1zdHJpbmdpZmljYXRpb24gKHZpYSB0cmFuc2Zvcm1Ib2lzdCBieVxyXG4gICAgLy8gQHZ1ZS9jb21waWxlci1kb20pLCBidXQgZG9pbmcgaXQgaGVyZSBhbGxvd3MgdXMgdG8gcGVyZm9ybSBvbmx5IG9uZSBmdWxsXHJcbiAgICAvLyB3YWxrIG9mIHRoZSBBU1QgYW5kIGFsbG93IGBzdHJpbmdpZnlTdGF0aWNgIHRvIHN0b3Agd2Fsa2luZyBhcyBzb29uIGFzIGl0c1xyXG4gICAgLy8gc3RyaW5nZmljaWF0aW9uIHRocmVzaG9sZCBpcyBtZXQuXHJcbiAgICBsZXQgY2FuU3RyaW5naWZ5ID0gdHJ1ZTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IG5vZGU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAvLyBvbmx5IHBsYWluIGVsZW1lbnRzICYgdGV4dCBjYWxscyBhcmUgZWxpZ2libGUgZm9yIGhvaXN0aW5nLlxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgY2hpbGQudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0YW50VHlwZSA9IGRvTm90SG9pc3ROb2RlXHJcbiAgICAgICAgICAgICAgICA/IDAgLyogTk9UX0NPTlNUQU5UICovXHJcbiAgICAgICAgICAgICAgICA6IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPiAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA8IDMgLyogQ0FOX1NUUklOR0lGWSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblN0cmluZ2lmeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+PSAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlLnBhdGNoRmxhZyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0xIC8qIEhPSVNURUQgKi8gKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiBIT0lTVEVEICovYCA6IGBgKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0hvaXN0ZWROb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUgbWF5IGNvbnRhaW4gZHluYW1pYyBjaGlsZHJlbiwgYnV0IGl0cyBwcm9wcyBtYXkgYmUgZWxpZ2libGUgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBob2lzdGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBnZXRQYXRjaEZsYWcoY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWZsYWcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gNTEyIC8qIE5FRURfUEFUQ0ggKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gMSAvKiBURVhUICovKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPj1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLyogQ0FOX0hPSVNUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5wcm9wcyA9IGNvbnRleHQuaG9pc3QocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDEyIC8qIFRFWFRfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZC5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlIDwgMyAvKiBDQU5fU1RSSU5HSUZZICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuU3RyaW5naWZ5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPj0gMiAvKiBDQU5fSE9JU1QgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0hvaXN0ZWROb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3YWxrIGZ1cnRoZXJcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gY2hpbGQudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3YWxrKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDExIC8qIEZPUiAqLykge1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1mb3Igc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcclxuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkLmJyYW5jaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1pZiBzaW5nbGUgY2hpbGQgYmVjYXVzZSBpdCBoYXMgdG8gYmUgYSBibG9ja1xyXG4gICAgICAgICAgICAgICAgd2FsayhjaGlsZC5icmFuY2hlc1tpXSwgY29udGV4dCwgY2hpbGQuYnJhbmNoZXNbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjYW5TdHJpbmdpZnkgJiYgaGFzSG9pc3RlZE5vZGUgJiYgY29udGV4dC50cmFuc2Zvcm1Ib2lzdCkge1xyXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSG9pc3QoY2hpbGRyZW4sIGNvbnRleHQsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbnN0YW50Q2FjaGUgfSA9IGNvbnRleHQ7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICBpZiAobm9kZS50YWdUeXBlICE9PSAwIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjb25zdGFudENhY2hlLmdldChub2RlKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgIT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgaWYgKCFmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmV0dXJuVHlwZSA9IDMgLyogQ0FOX1NUUklOR0lGWSAqLztcclxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgaXRzZWxmIGhhcyBubyBwYXRjaCBmbGFnLiBIb3dldmVyIHdlIHN0aWxsIG5lZWQgdG8gY2hlY2s6XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBFdmVuIGZvciBhIG5vZGUgd2l0aCBubyBwYXRjaCBmbGFnLCBpdCBpcyBwb3NzaWJsZSBmb3IgaXQgdG8gY29udGFpblxyXG4gICAgICAgICAgICAgICAgLy8gbm9uLWhvaXN0YWJsZSBleHByZXNzaW9ucyB0aGF0IHJlZmVycyB0byBzY29wZSB2YXJpYWJsZXMsIGUuZy4gY29tcGlsZXJcclxuICAgICAgICAgICAgICAgIC8vIGluamVjdGVkIGtleXMgb3IgY2FjaGVkIGV2ZW50IGhhbmRsZXJzLiBUaGVyZWZvcmUgd2UgbmVlZCB0byBhbHdheXNcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBjb2RlZ2VuTm9kZSdzIHByb3BzIHRvIGJlIHN1cmUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRQcm9wc1R5cGUgPSBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRQcm9wc1R5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRQcm9wc1R5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGdlbmVyYXRlZFByb3BzVHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDIuIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShub2RlLmNoaWxkcmVuW2ldLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIE5PVF9DT05TVEFOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGNoaWxkVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAzLiBpZiB0aGUgdHlwZSBpcyBub3QgYWxyZWFkeSBDQU5fU0tJUF9QQVRDSCB3aGljaCBpcyB0aGUgbG93ZXN0IG5vbi0wXHJcbiAgICAgICAgICAgICAgICAvLyB0eXBlLCBjaGVjayBpZiBhbnkgb2YgdGhlIHByb3BzIGNhbiBjYXVzZSB0aGUgdHlwZSB0byBiZSBsb3dlcmVkXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gc2tpcCBjYW5fcGF0Y2ggYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgYnkgdGhlIGFic2VuY2Ugb2YgYVxyXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2hGbGFnLlxyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblR5cGUgPiAxIC8qIENBTl9TS0lQX1BBVENIICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdiaW5kJyAmJiBwLmV4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwVHlwZSA9IGdldENvbnN0YW50VHlwZShwLmV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIE5PVF9DT05TVEFOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGV4cFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHN2Zy9mb3JlaWduT2JqZWN0IGNvdWxkIGJlIGJsb2NrIGhlcmUsIGhvd2V2ZXIgaWYgdGhleSBhcmVcclxuICAgICAgICAgICAgICAgIC8vIHN0YXRpYyB0aGVuIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBibG9ja3Mgc2luY2UgdGhlcmUgd2lsbCBiZSBub1xyXG4gICAgICAgICAgICAgICAgLy8gbmVzdGVkIHVwZGF0ZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlSGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlSGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuaXNCbG9jayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCByZXR1cm5UeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnN0VHlwZTtcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSB8fCBpc1N5bWJvbChjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgY29uc3QgcHJvcHMgPSBnZXROb2RlUHJvcHMobm9kZSk7XHJcbiAgICBpZiAocHJvcHMgJiYgcHJvcHMudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IHByb3BzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGtleVR5cGUgPSBnZXRDb25zdGFudFR5cGUoa2V5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGtleVR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBrZXlUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxufVxyXG5mdW5jdGlvbiBnZXROb2RlUHJvcHMobm9kZSkge1xyXG4gICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xyXG4gICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICByZXR1cm4gY29kZWdlbk5vZGUucHJvcHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGF0Y2hGbGFnKG5vZGUpIHtcclxuICAgIGNvbnN0IGZsYWcgPSBub2RlLnBhdGNoRmxhZztcclxuICAgIHJldHVybiBmbGFnID8gcGFyc2VJbnQoZmxhZywgMTApIDogdW5kZWZpbmVkO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgeyBmaWxlbmFtZSA9ICcnLCBwcmVmaXhJZGVudGlmaWVycyA9IGZhbHNlLCBob2lzdFN0YXRpYyA9IGZhbHNlLCBjYWNoZUhhbmRsZXJzID0gZmFsc2UsIG5vZGVUcmFuc2Zvcm1zID0gW10sIGRpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7fSwgdHJhbnNmb3JtSG9pc3QgPSBudWxsLCBpc0J1aWx0SW5Db21wb25lbnQgPSBOT09QLCBpc0N1c3RvbUVsZW1lbnQgPSBOT09QLCBleHByZXNzaW9uUGx1Z2lucyA9IFtdLCBzY29wZUlkID0gbnVsbCwgc2xvdHRlZCA9IHRydWUsIHNzciA9IGZhbHNlLCBzc3JDc3NWYXJzID0gYGAsIGJpbmRpbmdNZXRhZGF0YSA9IEVNUFRZX09CSiwgaW5saW5lID0gZmFsc2UsIGlzVFMgPSBmYWxzZSwgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLCBvbldhcm4gPSBkZWZhdWx0T25XYXJuLCBjb21wYXRDb25maWcgfSkge1xyXG4gICAgY29uc3QgbmFtZU1hdGNoID0gZmlsZW5hbWUucmVwbGFjZSgvXFw/LiokLywgJycpLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgIC8vIG9wdGlvbnNcclxuICAgICAgICBzZWxmTmFtZTogbmFtZU1hdGNoICYmIGNhcGl0YWxpemUoY2FtZWxpemUkMShuYW1lTWF0Y2hbMV0pKSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBob2lzdFN0YXRpYyxcclxuICAgICAgICBjYWNoZUhhbmRsZXJzLFxyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgdHJhbnNmb3JtSG9pc3QsXHJcbiAgICAgICAgaXNCdWlsdEluQ29tcG9uZW50LFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICBleHByZXNzaW9uUGx1Z2lucyxcclxuICAgICAgICBzY29wZUlkLFxyXG4gICAgICAgIHNsb3R0ZWQsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIHNzckNzc1ZhcnMsXHJcbiAgICAgICAgYmluZGluZ01ldGFkYXRhLFxyXG4gICAgICAgIGlubGluZSxcclxuICAgICAgICBpc1RTLFxyXG4gICAgICAgIG9uRXJyb3IsXHJcbiAgICAgICAgb25XYXJuLFxyXG4gICAgICAgIGNvbXBhdENvbmZpZyxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIHJvb3QsXHJcbiAgICAgICAgaGVscGVyczogbmV3IE1hcCgpLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IG5ldyBTZXQoKSxcclxuICAgICAgICBkaXJlY3RpdmVzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgaG9pc3RzOiBbXSxcclxuICAgICAgICBpbXBvcnRzOiBbXSxcclxuICAgICAgICBjb25zdGFudENhY2hlOiBuZXcgTWFwKCksXHJcbiAgICAgICAgdGVtcHM6IDAsXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIGlkZW50aWZpZXJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIHNjb3Blczoge1xyXG4gICAgICAgICAgICB2Rm9yOiAwLFxyXG4gICAgICAgICAgICB2U2xvdDogMCxcclxuICAgICAgICAgICAgdlByZTogMCxcclxuICAgICAgICAgICAgdk9uY2U6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICBjdXJyZW50Tm9kZTogcm9vdCxcclxuICAgICAgICBjaGlsZEluZGV4OiAwLFxyXG4gICAgICAgIC8vIG1ldGhvZHNcclxuICAgICAgICBoZWxwZXIobmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSkgfHwgMDtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjb3VudCArIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUhlbHBlcihuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY29udGV4dC5oZWxwZXJzLmdldChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSBjb3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuc2V0KG5hbWUsIGN1cnJlbnRDb3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhlbHBlclN0cmluZyhuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtjb250ZXh0LmhlbHBlcihuYW1lKV19YDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2VOb2RlKG5vZGUpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBiZWluZyByZXBsYWNlZCBpcyBhbHJlYWR5IHJlbW92ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW5bY29udGV4dC5jaGlsZEluZGV4XSA9IGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgcm9vdCBub2RlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZhbEluZGV4ID0gbm9kZVxyXG4gICAgICAgICAgICAgICAgPyBsaXN0LmluZGV4T2Yobm9kZSlcclxuICAgICAgICAgICAgICAgIDogY29udGV4dC5jdXJyZW50Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5jaGlsZEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcmVtb3ZhbEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub2RlIGJlaW5nIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgY3VycmVudCBwYXJlbnRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBub2RlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaWJsaW5nIG5vZGUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hpbGRJbmRleCA+IHJlbW92YWxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hpbGRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuLnNwbGljZShyZW1vdmFsSW5kZXgsIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Ob2RlUmVtb3ZlZDogKCkgPT4geyB9LFxyXG4gICAgICAgIGFkZElkZW50aWZpZXJzKGV4cCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlSWRlbnRpZmllcnMoZXhwKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob2lzdChleHApIHtcclxuICAgICAgICAgICAgY29udGV4dC5ob2lzdHMucHVzaChleHApO1xyXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2hvaXN0ZWRfJHtjb250ZXh0LmhvaXN0cy5sZW5ndGh9YCwgZmFsc2UsIGV4cC5sb2MsIDIgLyogQ0FOX0hPSVNUICovKTtcclxuICAgICAgICAgICAgaWRlbnRpZmllci5ob2lzdGVkID0gZXhwO1xyXG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhY2hlKGV4cCwgaXNWTm9kZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDYWNoZUV4cHJlc3Npb24oKytjb250ZXh0LmNhY2hlZCwgZXhwLCBpc1ZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAge1xyXG4gICAgICAgIGNvbnRleHQuZmlsdGVycyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybShyb290LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCBvcHRpb25zKTtcclxuICAgIHRyYXZlcnNlTm9kZShyb290LCBjb250ZXh0KTtcclxuICAgIGlmIChvcHRpb25zLmhvaXN0U3RhdGljKSB7XHJcbiAgICAgICAgaG9pc3RTdGF0aWMocm9vdCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW9wdGlvbnMuc3NyKSB7XHJcbiAgICAgICAgY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBmaW5hbGl6ZSBtZXRhIGluZm9ybWF0aW9uXHJcbiAgICByb290LmhlbHBlcnMgPSBbLi4uY29udGV4dC5oZWxwZXJzLmtleXMoKV07XHJcbiAgICByb290LmNvbXBvbmVudHMgPSBbLi4uY29udGV4dC5jb21wb25lbnRzXTtcclxuICAgIHJvb3QuZGlyZWN0aXZlcyA9IFsuLi5jb250ZXh0LmRpcmVjdGl2ZXNdO1xyXG4gICAgcm9vdC5pbXBvcnRzID0gY29udGV4dC5pbXBvcnRzO1xyXG4gICAgcm9vdC5ob2lzdHMgPSBjb250ZXh0LmhvaXN0cztcclxuICAgIHJvb3QudGVtcHMgPSBjb250ZXh0LnRlbXBzO1xyXG4gICAgcm9vdC5jYWNoZWQgPSBjb250ZXh0LmNhY2hlZDtcclxuICAgIHtcclxuICAgICAgICByb290LmZpbHRlcnMgPSBbLi4uY29udGV4dC5maWx0ZXJzXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcm9vdDtcclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgIC8vIGlmIHRoZSBzaW5nbGUgY2hpbGQgaXMgYW4gZWxlbWVudCwgdHVybiBpdCBpbnRvIGEgYmxvY2suXHJcbiAgICAgICAgaWYgKGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpICYmIGNoaWxkLmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSBlbGVtZW50IHJvb3QgaXMgbmV2ZXIgaG9pc3RlZCBzbyBjb2RlZ2VuTm9kZSB3aWxsIG5ldmVyIGJlXHJcbiAgICAgICAgICAgIC8vIFNpbXBsZUV4cHJlc3Npb25Ob2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvZGVnZW5Ob2RlLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoQ1JFQVRFX1ZOT0RFKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5pc0Jsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNvZGVnZW5Ob2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgPHNsb3QvPiwgSWZOb2RlLCBGb3JOb2RlOiBhbHJlYWR5IGJsb2Nrcy5cclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgdGV4dCBub2RlOiBhbHdheXMgcGF0Y2hlZC5cclxuICAgICAgICAgICAgLy8gcm9vdCBjb2RlZ2VuIGZhbGxzIHRocm91Z2ggdmlhIGdlbk5vZGUoKVxyXG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIC8vIHJvb3QgaGFzIG11bHRpcGxlIG5vZGVzIC0gcmV0dXJuIGEgZnJhZ21lbnQgYmxvY2suXHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLztcclxuICAgICAgICBsZXQgcGF0Y2hGbGFnVGV4dCA9IFBhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL107XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyYWdtZW50IGFjdHVhbGx5IGNvbnRhaW5zIGEgc2luZ2xlIHZhbGlkIGNoaWxkIHdpdGhcclxuICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke1BhdGNoRmxhZ05hbWVzWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByb290LmNoaWxkcmVuLCBwYXRjaEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3BhdGNoRmxhZ1RleHR9ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSA7XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VDaGlsZHJlbihwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IG5vZGVSZW1vdmVkID0gKCkgPT4ge1xyXG4gICAgICAgIGktLTtcclxuICAgIH07XHJcbiAgICBmb3IgKDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIGNvbnRleHQuY2hpbGRJbmRleCA9IGk7XHJcbiAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkID0gbm9kZVJlbW92ZWQ7XHJcbiAgICAgICAgdHJhdmVyc2VOb2RlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAvLyBhcHBseSB0cmFuc2Zvcm0gcGx1Z2luc1xyXG4gICAgY29uc3QgeyBub2RlVHJhbnNmb3JtcyB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBvbkV4aXQgPSBub2RlVHJhbnNmb3Jtc1tpXShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAob25FeGl0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9uRXhpdCkpIHtcclxuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaCguLi5vbkV4aXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIHJlbW92ZWRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkXHJcbiAgICAgICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluamVjdCBpbXBvcnQgZm9yIHRoZSBDb21tZW50IHN5bWJvbCwgd2hpY2ggaXMgbmVlZGVkIGZvciBjcmVhdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gY29tbWVudCBub2RlcyB3aXRoIGBjcmVhdGVWTm9kZWBcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB0cmF2ZXJzZSwgYnV0IHdlIG5lZWQgdG8gaW5qZWN0IHRvU3RyaW5nIGhlbHBlclxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihUT19ESVNQTEFZX1NUUklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gZm9yIGNvbnRhaW5lciB0eXBlcywgZnVydGhlciB0cmF2ZXJzZSBkb3dud2FyZHNcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuYnJhbmNoZXNbaV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgIGNhc2UgMCAvKiBST09UICovOlxyXG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8vIGV4aXQgdHJhbnNmb3Jtc1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICBsZXQgaSA9IGV4aXRGbnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGV4aXRGbnNbaV0oKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKG5hbWUsIGZuKSB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gaXNTdHJpbmcobmFtZSlcclxuICAgICAgICA/IChuKSA9PiBuID09PSBuYW1lXHJcbiAgICAgICAgOiAobikgPT4gbmFtZS50ZXN0KG4pO1xyXG4gICAgcmV0dXJuIChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRyYW5zZm9ybXMgYXJlIG5vdCBjb25jZXJuZWQgd2l0aCBzbG90c1xyXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgaW4gdlNsb3QudHNcclxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyAmJiBwcm9wcy5zb21lKGlzVlNsb3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZXhpdEZucyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBtYXRjaGVzKHByb3AubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgYXJlIHJlbW92ZWQgdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3ZSByZW1vdmUgdGhlbSAqYmVmb3JlKiBhcHBseWluZyBzbyB0aGF0IGl0IGNhbiBmdXJ0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhdmVyc2UgaXRzZWxmIGluIGNhc2UgaXQgbW92ZXMgdGhlIG5vZGUgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBmbihub2RlLCBwcm9wLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXhpdEZucztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IFBVUkVfQU5OT1RBVElPTiA9IGAvKiNfX1BVUkVfXyovYDtcclxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7IG1vZGUgPSAnZnVuY3Rpb24nLCBwcmVmaXhJZGVudGlmaWVycyA9IG1vZGUgPT09ICdtb2R1bGUnLCBzb3VyY2VNYXAgPSBmYWxzZSwgZmlsZW5hbWUgPSBgdGVtcGxhdGUudnVlLmh0bWxgLCBzY29wZUlkID0gbnVsbCwgb3B0aW1pemVJbXBvcnRzID0gZmFsc2UsIHJ1bnRpbWVHbG9iYWxOYW1lID0gYFZ1ZWAsIHJ1bnRpbWVNb2R1bGVOYW1lID0gYHZ1ZWAsIHNzciA9IGZhbHNlIH0pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBzb3VyY2VNYXAsXHJcbiAgICAgICAgZmlsZW5hbWUsXHJcbiAgICAgICAgc2NvcGVJZCxcclxuICAgICAgICBvcHRpbWl6ZUltcG9ydHMsXHJcbiAgICAgICAgcnVudGltZUdsb2JhbE5hbWUsXHJcbiAgICAgICAgcnVudGltZU1vZHVsZU5hbWUsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIHNvdXJjZTogYXN0LmxvYy5zb3VyY2UsXHJcbiAgICAgICAgY29kZTogYGAsXHJcbiAgICAgICAgY29sdW1uOiAxLFxyXG4gICAgICAgIGxpbmU6IDEsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIGluZGVudExldmVsOiAwLFxyXG4gICAgICAgIHB1cmU6IGZhbHNlLFxyXG4gICAgICAgIG1hcDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlbHBlcihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBfJHtoZWxwZXJOYW1lTWFwW2tleV19YDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2goY29kZSwgbm9kZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gY29kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluZGVudCgpIHtcclxuICAgICAgICAgICAgbmV3bGluZSgrK2NvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVpbmRlbnQod2l0aG91dE5ld0xpbmUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dE5ld0xpbmUpIHtcclxuICAgICAgICAgICAgICAgIC0tY29udGV4dC5pbmRlbnRMZXZlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld2xpbmUoLS1jb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV3bGluZSgpIHtcclxuICAgICAgICAgICAgbmV3bGluZShjb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gbmV3bGluZShuKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKCdcXG4nICsgYCAgYC5yZXBlYXQobikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGUoYXN0LCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIG9wdGlvbnMpO1xyXG4gICAgaWYgKG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZClcclxuICAgICAgICBvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQoY29udGV4dCk7XHJcbiAgICBjb25zdCB7IG1vZGUsIHB1c2gsIHByZWZpeElkZW50aWZpZXJzLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lLCBzY29wZUlkLCBzc3IgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBoYXNIZWxwZXJzID0gYXN0LmhlbHBlcnMubGVuZ3RoID4gMDtcclxuICAgIGNvbnN0IHVzZVdpdGhCbG9jayA9ICFwcmVmaXhJZGVudGlmaWVycyAmJiBtb2RlICE9PSAnbW9kdWxlJztcclxuICAgIC8vIHByZWFtYmxlc1xyXG4gICAgLy8gaW4gc2V0dXAoKSBpbmxpbmUgbW9kZSwgdGhlIHByZWFtYmxlIGlzIGdlbmVyYXRlZCBpbiBhIHN1YiBjb250ZXh0XHJcbiAgICAvLyBhbmQgcmV0dXJuZWQgc2VwYXJhdGVseS5cclxuICAgIGNvbnN0IHByZWFtYmxlQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB7XHJcbiAgICAgICAgZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIHByZWFtYmxlQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBlbnRlciByZW5kZXIgZnVuY3Rpb25cclxuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHNzciA/IGBzc3JSZW5kZXJgIDogYHJlbmRlcmA7XHJcbiAgICBjb25zdCBhcmdzID0gc3NyID8gWydfY3R4JywgJ19wdXNoJywgJ19wYXJlbnQnLCAnX2F0dHJzJ10gOiBbJ19jdHgnLCAnX2NhY2hlJ107XHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhcmdzLmpvaW4oJywgJyk7XHJcbiAgICB7XHJcbiAgICAgICAgcHVzaChgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCR7c2lnbmF0dXJlfSkge2ApO1xyXG4gICAgfVxyXG4gICAgaW5kZW50KCk7XHJcbiAgICBpZiAodXNlV2l0aEJsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgd2l0aCAoX2N0eCkge2ApO1xyXG4gICAgICAgIGluZGVudCgpO1xyXG4gICAgICAgIC8vIGZ1bmN0aW9uIG1vZGUgY29uc3QgZGVjbGFyYXRpb25zIHNob3VsZCBiZSBpbnNpZGUgd2l0aCBibG9ja1xyXG4gICAgICAgIC8vIGFsc28gdGhleSBzaG91bGQgYmUgcmVuYW1lZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCB1c2VyIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAoaGFzSGVscGVycykge1xyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCB7ICR7YXN0LmhlbHBlcnNcclxuICAgICAgICAgICAgICAgIC5tYXAocyA9PiBgJHtoZWxwZXJOYW1lTWFwW3NdfTogXyR7aGVscGVyTmFtZU1hcFtzXX1gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IH0gPSBfVnVlYCk7XHJcbiAgICAgICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZ2VuZXJhdGUgYXNzZXQgcmVzb2x1dGlvbiBzdGF0ZW1lbnRzXHJcbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5jb21wb25lbnRzLCAnY29tcG9uZW50JywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmRpcmVjdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5kaXJlY3RpdmVzLCAnZGlyZWN0aXZlJywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuZmlsdGVycyAmJiBhc3QuZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5maWx0ZXJzLCAnZmlsdGVyJywgY29udGV4dCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICBwdXNoKGBsZXQgYCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudGVtcHM7IGkrKykge1xyXG4gICAgICAgICAgICBwdXNoKGAke2kgPiAwID8gYCwgYCA6IGBgfV90ZW1wJHtpfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGggfHwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcykge1xyXG4gICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIC8vIGdlbmVyYXRlIHRoZSBWTm9kZSB0cmVlIGV4cHJlc3Npb25cclxuICAgIGlmICghc3NyKSB7XHJcbiAgICAgICAgcHVzaChgcmV0dXJuIGApO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgIGdlbk5vZGUoYXN0LmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYG51bGxgKTtcclxuICAgIH1cclxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGRlaW5kZW50KCk7XHJcbiAgICBwdXNoKGB9YCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFzdCxcclxuICAgICAgICBjb2RlOiBjb250ZXh0LmNvZGUsXHJcbiAgICAgICAgcHJlYW1ibGU6IGBgLFxyXG4gICAgICAgIC8vIFNvdXJjZU1hcEdlbmVyYXRvciBkb2VzIGhhdmUgdG9KU09OKCkgbWV0aG9kIGJ1dCBpdCdzIG5vdCBpbiB0aGUgdHlwZXNcclxuICAgICAgICBtYXA6IGNvbnRleHQubWFwID8gY29udGV4dC5tYXAudG9KU09OKCkgOiB1bmRlZmluZWRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgc3NyLCBwcmVmaXhJZGVudGlmaWVycywgcHVzaCwgbmV3bGluZSwgcnVudGltZU1vZHVsZU5hbWUsIHJ1bnRpbWVHbG9iYWxOYW1lIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgVnVlQmluZGluZyA9IHJ1bnRpbWVHbG9iYWxOYW1lO1xyXG4gICAgY29uc3QgYWxpYXNIZWxwZXIgPSAocykgPT4gYCR7aGVscGVyTmFtZU1hcFtzXX06IF8ke2hlbHBlck5hbWVNYXBbc119YDtcclxuICAgIC8vIEdlbmVyYXRlIGNvbnN0IGRlY2xhcmF0aW9uIGZvciBoZWxwZXJzXHJcbiAgICAvLyBJbiBwcmVmaXggbW9kZSwgd2UgcGxhY2UgdGhlIGNvbnN0IGRlY2xhcmF0aW9uIGF0IHRvcCBzbyBpdCdzIGRvbmVcclxuICAgIC8vIG9ubHkgb25jZTsgQnV0IGlmIHdlIG5vdCBwcmVmaXhpbmcsIHdlIHBsYWNlIHRoZSBkZWNsYXJhdGlvbiBpbnNpZGUgdGhlXHJcbiAgICAvLyB3aXRoIGJsb2NrIHNvIGl0IGRvZXNuJ3QgaW5jdXIgdGhlIGBpbmAgY2hlY2sgY29zdCBmb3IgZXZlcnkgaGVscGVyIGFjY2Vzcy5cclxuICAgIGlmIChhc3QuaGVscGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBcIndpdGhcIiBtb2RlLlxyXG4gICAgICAgICAgICAvLyBzYXZlIFZ1ZSBpbiBhIHNlcGFyYXRlIHZhcmlhYmxlIHRvIGF2b2lkIGNvbGxpc2lvblxyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfVnVlID0gJHtWdWVCaW5kaW5nfVxcbmApO1xyXG4gICAgICAgICAgICAvLyBpbiBcIndpdGhcIiBtb2RlLCBoZWxwZXJzIGFyZSBkZWNsYXJlZCBpbnNpZGUgdGhlIHdpdGggYmxvY2sgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gaGFzIGNoZWNrIGNvc3QsIGJ1dCBob2lzdHMgYXJlIGxpZnRlZCBvdXQgb2YgdGhlIGZ1bmN0aW9uIC0gd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBwcm92aWRlIHRoZSBoZWxwZXIgaGVyZS5cclxuICAgICAgICAgICAgaWYgKGFzdC5ob2lzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0aWNIZWxwZXJzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9WTk9ERSxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfQ09NTUVOVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVEVYVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfU1RBVElDXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihoZWxwZXIgPT4gYXN0LmhlbHBlcnMuaW5jbHVkZXMoaGVscGVyKSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFsaWFzSGVscGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgcHVzaChgY29uc3QgeyAke3N0YXRpY0hlbHBlcnN9IH0gPSBfVnVlXFxuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZW5Ib2lzdHMoYXN0LmhvaXN0cywgY29udGV4dCk7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBwdXNoKGByZXR1cm4gYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXNzZXRzKGFzc2V0cywgdHlwZSwgeyBoZWxwZXIsIHB1c2gsIG5ld2xpbmUgfSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZXIgPSBoZWxwZXIodHlwZSA9PT0gJ2ZpbHRlcidcclxuICAgICAgICA/IFJFU09MVkVfRklMVEVSXHJcbiAgICAgICAgOiB0eXBlID09PSAnY29tcG9uZW50J1xyXG4gICAgICAgICAgICA/IFJFU09MVkVfQ09NUE9ORU5UXHJcbiAgICAgICAgICAgIDogUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgaWQgPSBhc3NldHNbaV07XHJcbiAgICAgICAgLy8gcG90ZW50aWFsIGNvbXBvbmVudCBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZSBpbmZlcnJlZCBmcm9tIFNGQyBmaWxlbmFtZVxyXG4gICAgICAgIGNvbnN0IG1heWJlU2VsZlJlZmVyZW5jZSA9IGlkLmVuZHNXaXRoKCdfX3NlbGYnKTtcclxuICAgICAgICBpZiAobWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgIGlkID0gaWQuc2xpY2UoMCwgLTYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdXNoKGBjb25zdCAke3RvVmFsaWRBc3NldElkKGlkLCB0eXBlKX0gPSAke3Jlc29sdmVyfSgke0pTT04uc3RyaW5naWZ5KGlkKX0ke21heWJlU2VsZlJlZmVyZW5jZSA/IGAsIHRydWVgIDogYGB9KWApO1xyXG4gICAgICAgIGlmIChpIDwgYXNzZXRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Ib2lzdHMoaG9pc3RzLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWhvaXN0cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LnB1cmUgPSB0cnVlO1xyXG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lLCBoZWxwZXIsIHNjb3BlSWQsIG1vZGUgfSA9IGNvbnRleHQ7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBob2lzdHMuZm9yRWFjaCgoZXhwLCBpKSA9PiB7XHJcbiAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfaG9pc3RlZF8ke2kgKyAxfSA9IGApO1xyXG4gICAgICAgICAgICBnZW5Ob2RlKGV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnRleHQucHVyZSA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dCQxKG4pIHtcclxuICAgIHJldHVybiAoaXNTdHJpbmcobikgfHxcclxuICAgICAgICBuLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDIgLyogVEVYVCAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGVMaXN0QXNBcnJheShub2RlcywgY29udGV4dCkge1xyXG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IG5vZGVzLmxlbmd0aCA+IDMgfHxcclxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiYgbm9kZXMuc29tZShuID0+IGlzQXJyYXkobikgfHwgIWlzVGV4dCQxKG4pKSk7XHJcbiAgICBjb250ZXh0LnB1c2goYFtgKTtcclxuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5pbmRlbnQoKTtcclxuICAgIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzKTtcclxuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5kZWluZGVudCgpO1xyXG4gICAgY29udGV4dC5wdXNoKGBdYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMgPSBmYWxzZSwgY29tbWEgPSB0cnVlKSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgICAgICBwdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdGlsaW5lcykge1xyXG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgIGNvbnRleHQucHVzaChub2RlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTeW1ib2wobm9kZSkpIHtcclxuICAgICAgICBjb250ZXh0LnB1c2goY29udGV4dC5oZWxwZXIobm9kZSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGFzc2VydChub2RlLmNvZGVnZW5Ob2RlICE9IG51bGwsIGBDb2RlZ2VuIG5vZGUgaXMgbWlzc2luZyBmb3IgZWxlbWVudC9pZi9mb3Igbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuYCk7XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZS5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgICAgICBnZW5UZXh0KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgICAgICBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEyIC8qIFRFWFRfQ0FMTCAqLzpcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTMgLyogVk5PREVfQ0FMTCAqLzpcclxuICAgICAgICAgICAgZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE4IC8qIEpTX0ZVTkNUSU9OX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5Db25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBTU1Igb25seSB0eXBlc1xyXG4gICAgICAgIGNhc2UgMjEgLyogSlNfQkxPQ0tfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjMgLyogSlNfSUZfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI0IC8qIEpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI2IC8qIEpTX1JFVFVSTl9TVEFURU1FTlQgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIC8vIG5vb3BcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5oYW5kbGVkIGNvZGVnZW4gbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBleGhhdXN0IGFsbCBwb3NzaWJsZSB0eXBlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGhhdXN0aXZlQ2hlY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQucHVzaChKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29udGVudCwgaXNTdGF0aWMgfSA9IG5vZGU7XHJcbiAgICBjb250ZXh0LnB1c2goaXNTdGF0aWMgPyBKU09OLnN0cmluZ2lmeShjb250ZW50KSA6IGNvbnRlbnQsIG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAocHVyZSlcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICBwdXNoKGAke2hlbHBlcihUT19ESVNQTEFZX1NUUklORyl9KGApO1xyXG4gICAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkV4cHJlc3Npb25Bc1Byb3BlcnR5S2V5KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIHB1c2goYFtgKTtcclxuICAgICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgXWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS5pc1N0YXRpYykge1xyXG4gICAgICAgIC8vIG9ubHkgcXVvdGUga2V5cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudClcclxuICAgICAgICAgICAgPyBub2RlLmNvbnRlbnRcclxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpO1xyXG4gICAgICAgIHB1c2godGV4dCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdXNoKGBbJHtub2RlLmNvbnRlbnR9XWAsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIHB1c2goYCR7aGVscGVyKENSRUFURV9DT01NRU5UKX0oJHtKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpfSlgLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jaywgZGlzYWJsZVRyYWNraW5nIH0gPSBub2RlO1xyXG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBwdXNoKGhlbHBlcihXSVRIX0RJUkVDVElWRVMpICsgYChgKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgKCR7aGVscGVyKE9QRU5fQkxPQ0spfSgke2Rpc2FibGVUcmFja2luZyA/IGB0cnVlYCA6IGBgfSksIGApO1xyXG4gICAgfVxyXG4gICAgaWYgKHB1cmUpIHtcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICB9XHJcbiAgICBwdXNoKGhlbHBlcihpc0Jsb2NrID8gQ1JFQVRFX0JMT0NLIDogQ1JFQVRFX1ZOT0RFKSArIGAoYCwgbm9kZSk7XHJcbiAgICBnZW5Ob2RlTGlzdChnZW5OdWxsYWJsZUFyZ3MoW3RhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wc10pLCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxuICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBwdXNoKGAsIGApO1xyXG4gICAgICAgIGdlbk5vZGUoZGlyZWN0aXZlcywgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk51bGxhYmxlQXJncyhhcmdzKSB7XHJcbiAgICBsZXQgaSA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChhcmdzW2ldICE9IG51bGwpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcChhcmcgPT4gYXJnIHx8IGBudWxsYCk7XHJcbn1cclxuLy8gSmF2YVNjcmlwdFxyXG5mdW5jdGlvbiBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGNhbGxlZSA9IGlzU3RyaW5nKG5vZGUuY2FsbGVlKSA/IG5vZGUuY2FsbGVlIDogaGVscGVyKG5vZGUuY2FsbGVlKTtcclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgcHVzaChjYWxsZWUgKyBgKGAsIG5vZGUpO1xyXG4gICAgZ2VuTm9kZUxpc3Qobm9kZS5hcmd1bWVudHMsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlO1xyXG4gICAgaWYgKCFwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHB1c2goYHt9YCwgbm9kZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IHByb3BlcnRpZXMubGVuZ3RoID4gMSB8fFxyXG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJlxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNvbWUocCA9PiBwLnZhbHVlLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pKTtcclxuICAgIHB1c2gobXVsdGlsaW5lcyA/IGB7YCA6IGB7IGApO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBpbmRlbnQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAvLyBrZXlcclxuICAgICAgICBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShrZXksIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYDogYCk7XHJcbiAgICAgICAgLy8gdmFsdWVcclxuICAgICAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIG9ubHkgcmVhY2ggdGhpcyBpZiBpdCdzIG11bHRpbGluZXNcclxuICAgICAgICAgICAgcHVzaChgLGApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbXVsdGlsaW5lcyAmJiBkZWluZGVudCgpO1xyXG4gICAgcHVzaChtdWx0aWxpbmVzID8gYH1gIDogYCB9YCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLmVsZW1lbnRzLCBjb250ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBnZW5GdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBzY29wZUlkLCBtb2RlIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwYXJhbXMsIHJldHVybnMsIGJvZHksIG5ld2xpbmUsIGlzU2xvdCB9ID0gbm9kZTtcclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICAvLyB3cmFwIHNsb3QgZnVuY3Rpb25zIHdpdGggb3duZXIgY29udGV4dFxyXG4gICAgICAgIHB1c2goYF8ke2hlbHBlck5hbWVNYXBbV0lUSF9DVFhdfShgKTtcclxuICAgIH1cclxuICAgIHB1c2goYChgLCBub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHBhcmFtcykpIHtcclxuICAgICAgICBnZW5Ob2RlTGlzdChwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgZ2VuTm9kZShwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKSA9PiBgKTtcclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBwdXNoKGB7YCk7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmV0dXJucykge1xyXG4gICAgICAgIGlmIChuZXdsaW5lKSB7XHJcbiAgICAgICAgICAgIHB1c2goYHJldHVybiBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmV0dXJucykpIHtcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KHJldHVybnMsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShyZXR1cm5zLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChib2R5KSB7XHJcbiAgICAgICAgZ2VuTm9kZShib2R5LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICBpZiAobm9kZS5pc05vblNjb3BlZFNsb3QpIHtcclxuICAgICAgICAgICAgcHVzaChgLCB1bmRlZmluZWQsIHRydWVgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZTogbmVlZE5ld2xpbmUgfSA9IG5vZGU7XHJcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAodGVzdC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgY29uc3QgbmVlZHNQYXJlbnMgPSAhaXNTaW1wbGVJZGVudGlmaWVyKHRlc3QuY29udGVudCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbkV4cHJlc3Npb24odGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbk5vZGUodGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgbmVlZE5ld2xpbmUgJiYgaW5kZW50KCk7XHJcbiAgICBjb250ZXh0LmluZGVudExldmVsKys7XHJcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgICBwdXNoKGA/IGApO1xyXG4gICAgZ2VuTm9kZShjb25zZXF1ZW50LCBjb250ZXh0KTtcclxuICAgIGNvbnRleHQuaW5kZW50TGV2ZWwtLTtcclxuICAgIG5lZWROZXdsaW5lICYmIG5ld2xpbmUoKTtcclxuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcclxuICAgIHB1c2goYDogYCk7XHJcbiAgICBjb25zdCBpc05lc3RlZCA9IGFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovO1xyXG4gICAgaWYgKCFpc05lc3RlZCkge1xyXG4gICAgICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcclxuICAgIH1cclxuICAgIGdlbk5vZGUoYWx0ZXJuYXRlLCBjb250ZXh0KTtcclxuICAgIGlmICghaXNOZXN0ZWQpIHtcclxuICAgICAgICBjb250ZXh0LmluZGVudExldmVsLS07XHJcbiAgICB9XHJcbiAgICBuZWVkTmV3bGluZSAmJiBkZWluZGVudCh0cnVlIC8qIHdpdGhvdXQgbmV3bGluZSAqLyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dIHx8IChgKTtcclxuICAgIGlmIChub2RlLmlzVk5vZGUpIHtcclxuICAgICAgICBpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgtMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dID0gYCk7XHJcbiAgICBnZW5Ob2RlKG5vZGUudmFsdWUsIGNvbnRleHQpO1xyXG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xyXG4gICAgICAgIHB1c2goYCxgKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XWApO1xyXG4gICAgICAgIGRlaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGApYCk7XHJcbn1cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcclxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxyXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcclxuICAgICgnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcclxuICAgICAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xyXG4gICAgICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzLHR5cGVvZix2b2lkJylcclxuICAgICAgICAuc3BsaXQoJywnKVxyXG4gICAgICAgIC5qb2luKCdcXFxcYnxcXFxcYicpICtcclxuICAgICdcXFxcYicpO1xyXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXHJcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcclxuLyoqXHJcbiAqIFZhbGlkYXRlIGEgbm9uLXByZWZpeGVkIGV4cHJlc3Npb24uXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB1c2luZyB0aGUgaW4tYnJvd3NlciBydW50aW1lIGNvbXBpbGVyIHNpbmNlIGl0XHJcbiAqIGRvZXNuJ3QgcHJlZml4IGV4cHJlc3Npb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcyA9IGZhbHNlLCBhc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gICAgLy8gZW1wdHkgZXhwcmVzc2lvbnMgYXJlIHZhbGlkYXRlZCBwZXItZGlyZWN0aXZlIHNpbmNlIHNvbWUgZGlyZWN0aXZlc1xyXG4gICAgLy8gZG8gYWxsb3cgZW1wdHkgZXhwcmVzc2lvbnMuXHJcbiAgICBpZiAoIWV4cC50cmltKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBGdW5jdGlvbihhc1Jhd1N0YXRlbWVudHNcclxuICAgICAgICAgICAgPyBgICR7ZXhwfSBgXHJcbiAgICAgICAgICAgIDogYHJldHVybiAke2FzUGFyYW1zID8gYCgke2V4cH0pID0+IHt9YCA6IGAoJHtleHB9KWB9YCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxldCBtZXNzYWdlID0gZS5tZXNzYWdlO1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cFxyXG4gICAgICAgICAgICAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJylcclxuICAgICAgICAgICAgLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIke2tleXdvcmRNYXRjaFswXX1cImA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQzIC8qIFhfSU5WQUxJRF9FWFBSRVNTSU9OICovLCBub2RlLmxvYywgdW5kZWZpbmVkLCBtZXNzYWdlKSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtRXhwcmVzc2lvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICBub2RlLmNvbnRlbnQgPSBwcm9jZXNzRXhwcmVzc2lvbihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAvLyBoYW5kbGUgZGlyZWN0aXZlcyBvbiBlbGVtZW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGZvciB2LW9uICYgdi1mb3Igc2luY2UgdGhleSBhcmUgc3BlY2lhbCBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmIChkaXIudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgZGlyLm5hbWUgIT09ICdmb3InKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHAgPSBkaXIuZXhwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGV4cCBpZiB0aGlzIGlzIHYtb246YXJnIC0gd2UgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Igd3JhcHBpbmcgaW5saW5lIHN0YXRlbWVudHMuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGRpci5uYW1lID09PSAnb24nICYmIGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwID0gcHJvY2Vzc0V4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbG90IGFyZ3MgbXVzdCBiZSBwcm9jZXNzZWQgYXMgZnVuY3Rpb24gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLm5hbWUgPT09ICdzbG90Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmICFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuYXJnID0gcHJvY2Vzc0V4cHJlc3Npb24oYXJnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLy8gSW1wb3J0YW50OiBzaW5jZSB0aGlzIGZ1bmN0aW9uIHVzZXMgTm9kZS5qcyBvbmx5IGRlcGVuZGVuY2llcywgaXQgc2hvdWxkXHJcbi8vIGFsd2F5cyBiZSB1c2VkIHdpdGggYSBsZWFkaW5nICF0cnVlIGNoZWNrIHNvIHRoYXQgaXQgY2FuIGJlXHJcbi8vIHRyZWUtc2hha2VuIGZyb20gdGhlIGJyb3dzZXIgYnVpbGQuXHJcbmZ1bmN0aW9uIHByb2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIFxyXG4vLyBzb21lIGV4cHJlc3Npb25zIGxpa2Ugdi1zbG90IHByb3BzICYgdi1mb3IgYWxpYXNlcyBzaG91bGQgYmUgcGFyc2VkIGFzXHJcbi8vIGZ1bmN0aW9uIHBhcmFtc1xyXG5hc1BhcmFtcyA9IGZhbHNlLCBcclxuLy8gdi1vbiBoYW5kbGVyIHZhbHVlcyBtYXkgY29udGFpbiBtdWx0aXBsZSBzdGF0ZW1lbnRzXHJcbmFzUmF3U3RhdGVtZW50cyA9IGZhbHNlKSB7XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAvLyBzaW1wbGUgaW4tYnJvd3NlciB2YWxpZGF0aW9uIChzYW1lIGxvZ2ljIGluIDIueClcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcywgYXNSYXdTdGF0ZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtSWYgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKC9eKGlmfGVsc2V8ZWxzZS1pZikkLywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIChpZk5vZGUsIGJyYW5jaCwgaXNSb290KSA9PiB7XHJcbiAgICAgICAgLy8gIzE1ODc6IFdlIG5lZWQgdG8gZHluYW1pY2FsbHkgaW5jcmVtZW50IHRoZSBrZXkgYmFzZWQgb24gdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyBub2RlJ3Mgc2libGluZyBub2Rlcywgc2luY2UgY2hhaW5lZCB2LWlmL2Vsc2UgYnJhbmNoZXMgYXJlXHJcbiAgICAgICAgLy8gcmVuZGVyZWQgYXQgdGhlIHNhbWUgZGVwdGhcclxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihpZk5vZGUpO1xyXG4gICAgICAgIGxldCBrZXkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpLS0gPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAga2V5ICs9IHNpYmxpbmcuYnJhbmNoZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV4aXQgY2FsbGJhY2suIENvbXBsZXRlIHRoZSBjb2RlZ2VuTm9kZSB3aGVuIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW5cclxuICAgICAgICAvLyB0cmFuc2Zvcm1lZC5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSb290KSB7XHJcbiAgICAgICAgICAgICAgICBpZk5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBicmFuY2gncyBjb2RlZ2VuIG5vZGUgdG8gdGhlIHYtaWYgcm9vdC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENvbmRpdGlvbiA9IGdldFBhcmVudENvbmRpdGlvbihpZk5vZGUuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZGl0aW9uLmFsdGVybmF0ZSA9IGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5ICsgaWZOb2RlLmJyYW5jaGVzLmxlbmd0aCAtIDEsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59KTtcclxuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXHJcbmZ1bmN0aW9uIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdlbHNlJyAmJlxyXG4gICAgICAgICghZGlyLmV4cCB8fCAhZGlyLmV4cC5jb250ZW50LnRyaW0oKSkpIHtcclxuICAgICAgICBjb25zdCBsb2MgPSBkaXIuZXhwID8gZGlyLmV4cC5sb2MgOiBub2RlLmxvYztcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyNyAvKiBYX1ZfSUZfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIGRpci5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUgJiYgZGlyLmV4cCkge1xyXG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLm5hbWUgPT09ICdpZicpIHtcclxuICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xyXG4gICAgICAgIGNvbnN0IGlmTm9kZSA9IHtcclxuICAgICAgICAgICAgdHlwZTogOSAvKiBJRiAqLyxcclxuICAgICAgICAgICAgbG9jOiBub2RlLmxvYyxcclxuICAgICAgICAgICAgYnJhbmNoZXM6IFticmFuY2hdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb250ZXh0LnJlcGxhY2VOb2RlKGlmTm9kZSk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbG9jYXRlIHRoZSBhZGphY2VudCB2LWlmXHJcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjb21tZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihub2RlKTtcclxuICAgICAgICB3aGlsZSAoaS0tID49IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50cy51bnNoaWZ0KHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiZcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcudHlwZSA9PT0gMiAvKiBURVhUICovICYmXHJcbiAgICAgICAgICAgICAgICAhc2libGluZy5jb250ZW50LnRyaW0oKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgbm9kZSB0byB0aGUgaWYgbm9kZSdzIGJyYW5jaGVzXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzM2MTkgaWdub3JlIGNvbW1lbnRzIGlmIHRoZSB2LWlmIGlzIGRpcmVjdCBjaGlsZCBvZiA8dHJhbnNpdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAhKGNvbnRleHQucGFyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGFyZW50LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0J1aWx0SW5UeXBlKGNvbnRleHQucGFyZW50LnRhZywgJ3RyYW5zaXRpb24nKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmFuY2guY2hpbGRyZW4gPSBbLi4uY29tbWVudHMsIC4uLmJyYW5jaC5jaGlsZHJlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB1c2VyIGlzIGZvcmNpbmcgc2FtZSBrZXkgb24gZGlmZmVyZW50IGJyYW5jaGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYnJhbmNoLnVzZXJLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLmZvckVhY2goKHsgdXNlcktleSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lS2V5KHVzZXJLZXksIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOCAvKiBYX1ZfSUZfU0FNRV9LRVkgKi8sIGJyYW5jaC51c2VyS2V5LmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLnB1c2goYnJhbmNoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKHNpYmxpbmcsIGJyYW5jaCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGJyYW5jaCB3YXMgcmVtb3ZlZCwgaXQgd2lsbCBub3QgYmUgdHJhdmVyc2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHRyYXZlcnNlIGhlcmUuXHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUoYnJhbmNoLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIC8vIGNhbGwgb24gZXhpdFxyXG4gICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQoKTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCBjdXJyZW50Tm9kZSBhZnRlciB0cmF2ZXJzYWwgdG8gaW5kaWNhdGUgdGhpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBoYXMgYmVlbiByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOSAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqLywgbm9kZS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEwIC8qIElGX0JSQU5DSCAqLyxcclxuICAgICAgICBsb2M6IG5vZGUubG9jLFxyXG4gICAgICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09ICdlbHNlJyA/IHVuZGVmaW5lZCA6IGRpci5leHAsXHJcbiAgICAgICAgY2hpbGRyZW46IG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyAmJiAhZmluZERpcihub2RlLCAnZm9yJylcclxuICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgIDogW25vZGVdLFxyXG4gICAgICAgIHVzZXJLZXk6IGZpbmRQcm9wKG5vZGUsIGBrZXlgKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBpZiAoYnJhbmNoLmNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oYnJhbmNoLmNvbmRpdGlvbiwgY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSwgXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHBhc3MgaW4gYXNCbG9jazogdHJ1ZSBzbyB0aGF0IHRoZSBjb21tZW50IG5vZGUgY2FsbFxyXG4gICAgICAgIC8vIGNsb3NlcyB0aGUgY3VycmVudCBibG9jay5cclxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1widi1pZlwiJyA6ICdcIlwiJyxcclxuICAgICAgICAgICAgJ3RydWUnXHJcbiAgICAgICAgXSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3Qga2V5UHJvcGVydHkgPSBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXlJbmRleH1gLCBmYWxzZSwgbG9jU3R1YiwgMiAvKiBDQU5fSE9JU1QgKi8pKTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGJyYW5jaDtcclxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgZmlyc3RDaGlsZC50eXBlICE9PSAxIC8qIEVMRU1FTlQgKi87XHJcbiAgICBpZiAobmVlZEZyYWdtZW50V3JhcHBlcikge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZmlyc3RDaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8pIHtcclxuICAgICAgICAgICAgLy8gb3B0aW1pemUgYXdheSBuZXN0ZWQgZnJhZ21lbnRzIHdoZW4gY2hpbGQgaXMgYSBGb3JOb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IHZub2RlQ2FsbCA9IGZpcnN0Q2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZUNhbGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hGbGFnID0gNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hGbGFnVGV4dCA9IFBhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL107XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcmFnbWVudCBhY3R1YWxseSBjb250YWlucyBhIHNpbmdsZSB2YWxpZCBjaGlsZCB3aXRoXHJcbiAgICAgICAgICAgIC8vIHRoZSByZXN0IGJlaW5nIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovO1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke1BhdGNoRmxhZ05hbWVzWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pLCBjaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgYnJhbmNoLmxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZmlyc3RDaGlsZFxyXG4gICAgICAgICAgICAuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgLy8gQ2hhbmdlIGNyZWF0ZVZOb2RlIHRvIGNyZWF0ZUJsb2NrLlxyXG4gICAgICAgIGlmICh2bm9kZUNhbGwudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLyAmJiAhdm5vZGVDYWxsLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgcmVtb3ZlSGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgICAgIHZub2RlQ2FsbC5pc0Jsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICBoZWxwZXIoQ1JFQVRFX0JMT0NLKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IGJyYW5jaCBrZXlcclxuICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB2bm9kZUNhbGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lS2V5KGEsIGIpIHtcclxuICAgIGlmICghYSB8fCBhLnR5cGUgIT09IGIudHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChhLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgaWYgKGEudmFsdWUuY29udGVudCAhPT0gYi52YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkaXJlY3RpdmVcclxuICAgICAgICBjb25zdCBleHAgPSBhLmV4cDtcclxuICAgICAgICBjb25zdCBicmFuY2hFeHAgPSBiLmV4cDtcclxuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IGJyYW5jaEV4cC50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgIChleHAuaXNTdGF0aWMgIT09IGJyYW5jaEV4cC5pc1N0YXRpYyB8fFxyXG4gICAgICAgICAgICAgICAgZXhwLmNvbnRlbnQgIT09IGJyYW5jaEV4cC5jb250ZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuYWx0ZXJuYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCB0cmFuc2Zvcm1Gb3IgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKCdmb3InLCAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgcmV0dXJuIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBmb3JOb2RlID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgdGhlIGxvb3AgcmVuZGVyIGZ1bmN0aW9uIGV4cHJlc3Npb24gbm93LCBhbmQgYWRkIHRoZVxyXG4gICAgICAgIC8vIGl0ZXJhdG9yIG9uIGV4aXQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcclxuICAgICAgICBjb25zdCByZW5kZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihoZWxwZXIoUkVOREVSX0xJU1QpLCBbXHJcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3Qga2V5UHJvcCA9IGZpbmRQcm9wKG5vZGUsIGBrZXlgKTtcclxuICAgICAgICBjb25zdCBrZXlQcm9wZXJ0eSA9IGtleVByb3BcclxuICAgICAgICAgICAgPyBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwga2V5UHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqL1xyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleVByb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDoga2V5UHJvcC5leHApXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBjb25zdCBpc1N0YWJsZUZyYWdtZW50ID0gZm9yTm9kZS5zb3VyY2UudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICBmb3JOb2RlLnNvdXJjZS5jb25zdFR5cGUgPiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICBjb25zdCBmcmFnbWVudEZsYWcgPSBpc1N0YWJsZUZyYWdtZW50XHJcbiAgICAgICAgICAgID8gNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXHJcbiAgICAgICAgICAgIDoga2V5UHJvcFxyXG4gICAgICAgICAgICAgICAgPyAxMjggLyogS0VZRURfRlJBR01FTlQgKi9cclxuICAgICAgICAgICAgICAgIDogMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi87XHJcbiAgICAgICAgZm9yTm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCB1bmRlZmluZWQsIHJlbmRlckV4cCwgZnJhZ21lbnRGbGFnICtcclxuICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1tmcmFnbWVudEZsYWddfSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlIC8qIGlzQmxvY2sgKi8sICFpc1N0YWJsZUZyYWdtZW50IC8qIGRpc2FibGVUcmFja2luZyAqLywgbm9kZS5sb2MpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpbmlzaCB0aGUgY29kZWdlbiBub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIHRyYXZlcnNlZFxyXG4gICAgICAgICAgICBsZXQgY2hpbGRCbG9jaztcclxuICAgICAgICAgICAgY29uc3QgaXNUZW1wbGF0ZSA9IGlzVGVtcGxhdGVOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBmb3JOb2RlO1xyXG4gICAgICAgICAgICAvLyBjaGVjayA8dGVtcGxhdGUgdi1mb3I+IGtleSBwbGFjZW1lbnRcclxuICAgICAgICAgICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpICYmIGlzVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZmluZFByb3AoYywgJ2tleScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMiAvKiBYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi8sIGtleS5sb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZHJlblswXS50eXBlICE9PSAxIC8qIEVMRU1FTlQgKi87XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RPdXRsZXQgPSBpc1Nsb3RPdXRsZXQobm9kZSlcclxuICAgICAgICAgICAgICAgID8gbm9kZVxyXG4gICAgICAgICAgICAgICAgOiBpc1RlbXBsYXRlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1Nsb3RPdXRsZXQobm9kZS5jaGlsZHJlblswXSlcclxuICAgICAgICAgICAgICAgICAgICA/IG5vZGUuY2hpbGRyZW5bMF0gLy8gYXBpLWV4dHJhY3RvciBzb21laG93IGZhaWxzIHRvIGluZmVyIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChzbG90T3V0bGV0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8c2xvdCB2LWZvcj1cIi4uLlwiPiBvciA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIj48c2xvdC8+PC90ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBzbG90T3V0bGV0LmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIiA6a2V5PVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbmplY3QgdGhlIGtleSB0byB0aGUgcmVuZGVyU2xvdCgpIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3BzIGZvciByZW5kZXJTbG90IGlzIHBhc3NlZCBhcyB0aGUgM3JkIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiPiB3aXRoIHRleHQgb3IgbXVsdGktZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBnZW5lcmF0ZSBhIGZyYWdtZW50IGJsb2NrIGZvciBlYWNoIGxvb3BcclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwga2V5UHJvcGVydHkgPyBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pIDogdW5kZWZpbmVkLCBub2RlLmNoaWxkcmVuLCA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gK1xyXG4gICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXX0gKi9gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgZWxlbWVudCB2LWZvci4gRGlyZWN0bHkgdXNlIHRoZSBjaGlsZCdzIGNvZGVnZW5Ob2RlXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgbWFyayBpdCBhcyBhIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IGNoaWxkcmVuWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2sgIT09ICFpc1N0YWJsZUZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSBibG9jayB0byB2bm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGZyb20gdm5vZGUgdG8gYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jay5pc0Jsb2NrID0gIWlzU3RhYmxlRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVuZGVyRXhwLmFyZ3VtZW50cy5wdXNoKGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKGZvck5vZGUucGFyc2VSZXN1bHQpLCBjaGlsZEJsb2NrLCB0cnVlIC8qIGZvcmNlIG5ld2xpbmUgKi8pKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn0pO1xyXG4vLyB0YXJnZXQtYWdub3N0aWMgdHJhbnNmb3JtIHVzZWQgZm9yIGJvdGggQ2xpZW50IGFuZCBTU1JcclxuZnVuY3Rpb24gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICBpZiAoIWRpci5leHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBYX1ZfRk9SX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbihcclxuICAgIC8vIGNhbiBvbmx5IGJlIHNpbXBsZSBleHByZXNzaW9uIGJlY2F1c2UgdkZvciB0cmFuc2Zvcm0gaXMgYXBwbGllZFxyXG4gICAgLy8gYmVmb3JlIGV4cHJlc3Npb24gdHJhbnNmb3JtLlxyXG4gICAgZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzEgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzLCBzY29wZXMgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHNvdXJjZSwgdmFsdWUsIGtleSwgaW5kZXggfSA9IHBhcnNlUmVzdWx0O1xyXG4gICAgY29uc3QgZm9yTm9kZSA9IHtcclxuICAgICAgICB0eXBlOiAxMSAvKiBGT1IgKi8sXHJcbiAgICAgICAgbG9jOiBkaXIubG9jLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICB2YWx1ZUFsaWFzOiB2YWx1ZSxcclxuICAgICAgICBrZXlBbGlhczoga2V5LFxyXG4gICAgICAgIG9iamVjdEluZGV4QWxpYXM6IGluZGV4LFxyXG4gICAgICAgIHBhcnNlUmVzdWx0LFxyXG4gICAgICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlTm9kZShub2RlKSA/IG5vZGUuY2hpbGRyZW4gOiBbbm9kZV1cclxuICAgIH07XHJcbiAgICBjb250ZXh0LnJlcGxhY2VOb2RlKGZvck5vZGUpO1xyXG4gICAgLy8gYm9va2tlZXBpbmdcclxuICAgIHNjb3Blcy52Rm9yKys7XHJcbiAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihmb3JOb2RlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgc2NvcGVzLnZGb3ItLTtcclxuICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICBvbkV4aXQoKTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcclxuLy8gVGhpcyByZWdleCBkb2Vzbid0IGNvdmVyIHRoZSBjYXNlIGlmIGtleSBvciBpbmRleCBhbGlhc2VzIGhhdmUgZGVzdHJ1Y3R1cmluZyxcclxuLy8gYnV0IHRob3NlIGRvIG5vdCBtYWtlIHNlbnNlIGluIHRoZSBmaXJzdCBwbGFjZSwgc28gdGhpcyB3b3JrcyBpbiBwcmFjdGljZS5cclxuY29uc3QgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcclxuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcclxuZnVuY3Rpb24gcGFyc2VGb3JFeHByZXNzaW9uKGlucHV0LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBsb2MgPSBpbnB1dC5sb2M7XHJcbiAgICBjb25zdCBleHAgPSBpbnB1dC5jb250ZW50O1xyXG4gICAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcclxuICAgIGlmICghaW5NYXRjaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjb25zdCBbLCBMSFMsIFJIU10gPSBpbk1hdGNoO1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHNvdXJjZTogY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgUkhTLnRyaW0oKSwgZXhwLmluZGV4T2YoUkhTLCBMSFMubGVuZ3RoKSksXHJcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcclxuICAgICAgICBpbmRleDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuc291cmNlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGxldCB2YWx1ZUNvbnRlbnQgPSBMSFMudHJpbSgpXHJcbiAgICAgICAgLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpXHJcbiAgICAgICAgLnRyaW0oKTtcclxuICAgIGNvbnN0IHRyaW1tZWRPZmZzZXQgPSBMSFMuaW5kZXhPZih2YWx1ZUNvbnRlbnQpO1xyXG4gICAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IHZhbHVlQ29udGVudC5tYXRjaChmb3JJdGVyYXRvclJFKTtcclxuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XHJcbiAgICAgICAgdmFsdWVDb250ZW50ID0gdmFsdWVDb250ZW50LnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcclxuICAgICAgICBjb25zdCBrZXlDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XHJcbiAgICAgICAgbGV0IGtleU9mZnNldDtcclxuICAgICAgICBpZiAoa2V5Q29udGVudCkge1xyXG4gICAgICAgICAgICBrZXlPZmZzZXQgPSBleHAuaW5kZXhPZihrZXlDb250ZW50LCB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBrZXlDb250ZW50LCBrZXlPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LmtleSwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXhDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGluZGV4Q29udGVudCwgZXhwLmluZGV4T2YoaW5kZXhDb250ZW50LCByZXN1bHQua2V5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlPZmZzZXQgKyBrZXlDb250ZW50Lmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIDogdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LmluZGV4LCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh2YWx1ZUNvbnRlbnQpIHtcclxuICAgICAgICByZXN1bHQudmFsdWUgPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCB2YWx1ZUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC52YWx1ZSwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBbGlhc0V4cHJlc3Npb24ocmFuZ2UsIGNvbnRlbnQsIG9mZnNldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgZmFsc2UsIGdldElubmVyUmFuZ2UocmFuZ2UsIG9mZnNldCwgY29udGVudC5sZW5ndGgpKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JMb29wUGFyYW1zKHsgdmFsdWUsIGtleSwgaW5kZXggfSkge1xyXG4gICAgY29uc3QgcGFyYW1zID0gW107XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBwYXJhbXMucHVzaCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfYCwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLnB1c2goa2V5KTtcclxuICAgIH1cclxuICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9fYCwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLnB1c2goaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxufVxuXG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB1bmRlZmluZWRgLCBmYWxzZSk7XHJcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0OlxyXG4vLyAxLiBUcmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IHByZWZpeGVkXHJcbi8vICAgIGJ5IHRyYW5zZm9ybUV4cHJlc3Npb24uIFRoaXMgaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoXHJcbi8vICAgIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfS5cclxuLy8gMi4gVHJhY2sgdi1zbG90IGRlcHRocyBzbyB0aGF0IHdlIGtub3cgYSBzbG90IGlzIGluc2lkZSBhbm90aGVyIHNsb3QuXHJcbi8vICAgIE5vdGUgdGhlIGV4aXQgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgYmVmb3JlIGJ1aWxkU2xvdHMoKSBvbiB0aGUgc2FtZSBub2RlLFxyXG4vLyAgICBzbyBvbmx5IG5lc3RlZCBzbG90cyBzZWUgcG9zaXRpdmUgbnVtYmVycy5cclxuY29uc3QgdHJhY2tTbG90U2NvcGVzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIChub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLykpIHtcclxuICAgICAgICAvLyBXZSBhcmUgb25seSBjaGVja2luZyBub24tZW1wdHkgdi1zbG90IGhlcmVcclxuICAgICAgICAvLyBzaW5jZSB3ZSBvbmx5IGNhcmUgYWJvdXQgc2xvdHMgdGhhdCBpbnRyb2R1Y2Ugc2NvcGUgdmFyaWFibGVzLlxyXG4gICAgICAgIGNvbnN0IHZTbG90ID0gZmluZERpcihub2RlLCAnc2xvdCcpO1xyXG4gICAgICAgIGlmICh2U2xvdCkge1xyXG4gICAgICAgICAgICB2U2xvdC5leHA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90Kys7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdC0tO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLy8gQSBOb2RlVHJhbnNmb3JtIHRoYXQgdHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgd2l0aCB2LWZvci5cclxuLy8gVGhpcyB0cmFuc2Zvcm0gaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfVxyXG5jb25zdCB0cmFja1ZGb3JTbG90U2NvcGVzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGxldCB2Rm9yO1xyXG4gICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpICYmXHJcbiAgICAgICAgbm9kZS5wcm9wcy5zb21lKGlzVlNsb3QpICYmXHJcbiAgICAgICAgKHZGb3IgPSBmaW5kRGlyKG5vZGUsICdmb3InKSkpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSAodkZvci5wYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCkpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwga2V5LCBpbmRleCB9ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdmFsdWUgJiYgYWRkSWRlbnRpZmllcnModmFsdWUpO1xyXG4gICAgICAgICAgICBrZXkgJiYgYWRkSWRlbnRpZmllcnMoa2V5KTtcclxuICAgICAgICAgICAgaW5kZXggJiYgYWRkSWRlbnRpZmllcnMoaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgJiYgcmVtb3ZlSWRlbnRpZmllcnModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAga2V5ICYmIHJlbW92ZUlkZW50aWZpZXJzKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCAmJiByZW1vdmVJZGVudGlmaWVycyhpbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBidWlsZENsaWVudFNsb3RGbiA9IChwcm9wcywgY2hpbGRyZW4sIGxvYykgPT4gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHByb3BzLCBjaGlsZHJlbiwgZmFsc2UgLyogbmV3bGluZSAqLywgdHJ1ZSAvKiBpc1Nsb3QgKi8sIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdLmxvYyA6IGxvYyk7XHJcbi8vIEluc3RlYWQgb2YgYmVpbmcgYSBEaXJlY3RpdmVUcmFuc2Zvcm0sIHYtc2xvdCBwcm9jZXNzaW5nIGlzIGNhbGxlZCBkdXJpbmdcclxuLy8gdHJhbnNmb3JtRWxlbWVudCB0byBidWlsZCB0aGUgc2xvdHMgb2JqZWN0IGZvciBhIGNvbXBvbmVudC5cclxuZnVuY3Rpb24gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0LCBidWlsZFNsb3RGbiA9IGJ1aWxkQ2xpZW50U2xvdEZuKSB7XHJcbiAgICBjb250ZXh0LmhlbHBlcihXSVRIX0NUWCk7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBsb2MgfSA9IG5vZGU7XHJcbiAgICBjb25zdCBzbG90c1Byb3BlcnRpZXMgPSBbXTtcclxuICAgIGNvbnN0IGR5bmFtaWNTbG90cyA9IFtdO1xyXG4gICAgLy8gSWYgdGhlIHNsb3QgaXMgaW5zaWRlIGEgdi1mb3Igb3IgYW5vdGhlciB2LXNsb3QsIGZvcmNlIGl0IHRvIGJlIGR5bmFtaWNcclxuICAgIC8vIHNpbmNlIGl0IGxpa2VseSB1c2VzIGEgc2NvcGUgdmFyaWFibGUuXHJcbiAgICBsZXQgaGFzRHluYW1pY1Nsb3RzID0gY29udGV4dC5zY29wZXMudlNsb3QgPiAwIHx8IGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwO1xyXG4gICAgLy8gMS4gQ2hlY2sgZm9yIHNsb3Qgd2l0aCBzbG90UHJvcHMgb24gY29tcG9uZW50IGl0c2VsZi5cclxuICAgIC8vICAgIDxDb21wIHYtc2xvdD1cInsgcHJvcCB9XCIvPlxyXG4gICAgY29uc3Qgb25Db21wb25lbnRTbG90ID0gZmluZERpcihub2RlLCAnc2xvdCcsIHRydWUpO1xyXG4gICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgIGNvbnN0IHsgYXJnLCBleHAgfSA9IG9uQ29tcG9uZW50U2xvdDtcclxuICAgICAgICBpZiAoYXJnICYmICFpc1N0YXRpY0V4cChhcmcpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGFyZyB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdkZWZhdWx0JywgdHJ1ZSksIGJ1aWxkU2xvdEZuKGV4cCwgY2hpbGRyZW4sIGxvYykpKTtcclxuICAgIH1cclxuICAgIC8vIDIuIEl0ZXJhdGUgdGhyb3VnaCBjaGlsZHJlbiBhbmQgY2hlY2sgZm9yIHRlbXBsYXRlIHNsb3RzXHJcbiAgICAvLyAgICA8dGVtcGxhdGUgdi1zbG90OmZvbz1cInsgcHJvcCB9XCI+XHJcbiAgICBsZXQgaGFzVGVtcGxhdGVTbG90cyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc05hbWVkRGVmYXVsdFNsb3QgPSBmYWxzZTtcclxuICAgIGNvbnN0IGltcGxpY2l0RGVmYXVsdENoaWxkcmVuID0gW107XHJcbiAgICBjb25zdCBzZWVuU2xvdE5hbWVzID0gbmV3IFNldCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNsb3RFbGVtZW50ID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgbGV0IHNsb3REaXI7XHJcbiAgICAgICAgaWYgKCFpc1RlbXBsYXRlTm9kZShzbG90RWxlbWVudCkgfHxcclxuICAgICAgICAgICAgIShzbG90RGlyID0gZmluZERpcihzbG90RWxlbWVudCwgJ3Nsb3QnLCB0cnVlKSkpIHtcclxuICAgICAgICAgICAgLy8gbm90IGEgPHRlbXBsYXRlIHYtc2xvdD4sIHNraXAuXHJcbiAgICAgICAgICAgIGlmIChzbG90RWxlbWVudC50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnB1c2goc2xvdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgaGFzIG9uLWNvbXBvbmVudCBzbG90IC0gdGhpcyBpcyBpbmNvcnJlY3QgdXNhZ2UuXHJcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM2IC8qIFhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0UgKi8sIHNsb3REaXIubG9jKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNUZW1wbGF0ZVNsb3RzID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzbG90Q2hpbGRyZW4sIGxvYzogc2xvdExvYyB9ID0gc2xvdEVsZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgeyBhcmc6IHNsb3ROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgZGVmYXVsdGAsIHRydWUpLCBleHA6IHNsb3RQcm9wcywgbG9jOiBkaXJMb2MgfSA9IHNsb3REaXI7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgbmFtZSBpcyBkeW5hbWljLlxyXG4gICAgICAgIGxldCBzdGF0aWNTbG90TmFtZTtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoc2xvdE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHN0YXRpY1Nsb3ROYW1lID0gc2xvdE5hbWUgPyBzbG90TmFtZS5jb250ZW50IDogYGRlZmF1bHRgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2xvdEZ1bmN0aW9uID0gYnVpbGRTbG90Rm4oc2xvdFByb3BzLCBzbG90Q2hpbGRyZW4sIHNsb3RMb2MpO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc2xvdCBpcyBjb25kaXRpb25hbCAodi1pZi92LWZvcilcclxuICAgICAgICBsZXQgdklmO1xyXG4gICAgICAgIGxldCB2RWxzZTtcclxuICAgICAgICBsZXQgdkZvcjtcclxuICAgICAgICBpZiAoKHZJZiA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdpZicpKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odklmLmV4cCwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgZGVmYXVsdEZhbGxiYWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh2RWxzZSA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIC9eZWxzZSgtaWYpPyQvLCB0cnVlIC8qIGFsbG93RW1wdHkgKi8pKSkge1xyXG4gICAgICAgICAgICAvLyBmaW5kIGFkamFjZW50IHYtaWZcclxuICAgICAgICAgICAgbGV0IGogPSBpO1xyXG4gICAgICAgICAgICBsZXQgcHJldjtcclxuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXYgJiYgaXNUZW1wbGF0ZU5vZGUocHJldikgJiYgZmluZERpcihwcmV2LCAnaWYnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCB0aGlzIHNsb3QgdG8gcHJldmlvdXMgY29uZGl0aW9uYWxcclxuICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb25hbCA9IGR5bmFtaWNTbG90c1tkeW5hbWljU2xvdHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29uZGl0aW9uYWwuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmFsdGVybmF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsLmFsdGVybmF0ZSA9IHZFbHNlLmV4cFxyXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHZFbHNlLmV4cCwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgZGVmYXVsdEZhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIDogYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI5IC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCB2RWxzZS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodkZvciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdmb3InKSkpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB2Rm9yLnBhcnNlUmVzdWx0IHx8XHJcbiAgICAgICAgICAgICAgICBwYXJzZUZvckV4cHJlc3Npb24odkZvci5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgZHluYW1pYyBzbG90cyBhcyBhbiBhcnJheSBhbmQgYWRkIGl0IHRvIHRoZSBjcmVhdGVTbG90KClcclxuICAgICAgICAgICAgICAgIC8vIGFyZ3MuIFRoZSBydW50aW1lIGtub3dzIGhvdyB0byBoYW5kbGUgaXQgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LnNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhwYXJzZVJlc3VsdCksIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLylcclxuICAgICAgICAgICAgICAgIF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMxIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIHZGb3IubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGR1cGxpY2F0ZSBzdGF0aWMgbmFtZXNcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VlblNsb3ROYW1lcy5oYXMoc3RhdGljU2xvdE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzcgLyogWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi8sIGRpckxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VlblNsb3ROYW1lcy5hZGQoc3RhdGljU2xvdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNOYW1lZERlZmF1bHRTbG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICBjb25zdCBidWlsZERlZmF1bHRTbG90UHJvcGVydHkgPSAocHJvcHMsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZuID0gYnVpbGRTbG90Rm4ocHJvcHMsIGNoaWxkcmVuLCBsb2MpO1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5jb21wYXRDb25maWcpIHtcclxuICAgICAgICAgICAgICAgIGZuLmlzTm9uU2NvcGVkU2xvdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBkZWZhdWx0YCwgZm4pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFoYXNUZW1wbGF0ZVNsb3RzKSB7XHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAob24gY29tcG9uZW50KVxyXG4gICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBjaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gIzM3NjZcclxuICAgICAgICAgICAgLy8gd2l0aCB3aGl0ZXNwYWNlOiAncHJlc2VydmUnLCB3aGl0ZXNwYWNlcyBiZXR3ZWVuIHNsb3RzIHdpbGwgZW5kIHVwIGluXHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLiBJZ25vcmUgaWYgYWxsIGltcGxpY2l0IGNoaWxkcmVuIGFyZSB3aGl0ZXNwYWNlcy5cclxuICAgICAgICAgICAgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uc29tZShub2RlID0+IGlzTm9uV2hpdGVzcGFjZUNvbnRlbnQobm9kZSkpKSB7XHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAobWl4ZWQgd2l0aCBuYW1lZCBzbG90cylcclxuICAgICAgICAgICAgaWYgKGhhc05hbWVkRGVmYXVsdFNsb3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM4IC8qIFhfVl9TTE9UX0VYVFJBTkVPVVNfREVGQVVMVF9TTE9UX0NISUxEUkVOICovLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlblswXS5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSh1bmRlZmluZWQsIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzbG90RmxhZyA9IGhhc0R5bmFtaWNTbG90c1xyXG4gICAgICAgID8gMiAvKiBEWU5BTUlDICovXHJcbiAgICAgICAgOiBoYXNGb3J3YXJkZWRTbG90cyhub2RlLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IDMgLyogRk9SV0FSREVEICovXHJcbiAgICAgICAgICAgIDogMSAvKiBTVEFCTEUgKi87XHJcbiAgICBsZXQgc2xvdHMgPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHNsb3RzUHJvcGVydGllcy5jb25jYXQoY3JlYXRlT2JqZWN0UHJvcGVydHkoYF9gLCBcclxuICAgIC8vIDIgPSBjb21waWxlZCBidXQgZHluYW1pYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24sIGJ1dCBtdXN0IHJ1biBkaWZmXHJcbiAgICAvLyAxID0gY29tcGlsZWQgYW5kIHN0YXRpYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24gQU5EIGRpZmYgYXMgb3B0aW1pemVkXHJcbiAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHNsb3RGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtzbG90RmxhZ3NUZXh0W3Nsb3RGbGFnXX0gKi9gIDogYGApLCBmYWxzZSkpKSwgbG9jKTtcclxuICAgIGlmIChkeW5hbWljU2xvdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgc2xvdHMgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfU0xPVFMpLCBbXHJcbiAgICAgICAgICAgIHNsb3RzLFxyXG4gICAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oZHluYW1pY1Nsb3RzKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzbG90cyxcclxuICAgICAgICBoYXNEeW5hbWljU2xvdHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYnVpbGREeW5hbWljU2xvdChuYW1lLCBmbikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW1xyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBuYW1lYCwgbmFtZSksXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYGZuYCwgZm4pXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZHJlbikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ1R5cGUgPT09IDIgLyogU0xPVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChjaGlsZC50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5icmFuY2hlcykpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUpIHtcclxuICAgIGlmIChub2RlLnR5cGUgIT09IDIgLyogVEVYVCAqLyAmJiBub2RlLnR5cGUgIT09IDEyIC8qIFRFWFRfQ0FMTCAqLylcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqL1xyXG4gICAgICAgID8gISFub2RlLmNvbnRlbnQudHJpbSgpXHJcbiAgICAgICAgOiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUuY29udGVudCk7XHJcbn1cblxuLy8gc29tZSBkaXJlY3RpdmUgdHJhbnNmb3JtcyAoZS5nLiB2LW1vZGVsKSBtYXkgcmV0dXJuIGEgc3ltYm9sIGZvciBydW50aW1lXHJcbi8vIGltcG9ydCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBhIHJlc29sdmVEaXJlY3RpdmUgY2FsbC5cclxuY29uc3QgZGlyZWN0aXZlSW1wb3J0TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuLy8gZ2VuZXJhdGUgYSBKYXZhU2NyaXB0IEFTVCBmb3IgdGhpcyBlbGVtZW50J3MgY29kZWdlblxyXG5jb25zdCB0cmFuc2Zvcm1FbGVtZW50ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIC8vIHBlcmZvcm0gdGhlIHdvcmsgb24gZXhpdCwgYWZ0ZXIgYWxsIGNoaWxkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxyXG4gICAgLy8gcHJvY2Vzc2VkIGFuZCBtZXJnZWQuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9zdFRyYW5zZm9ybUVsZW1lbnQoKSB7XHJcbiAgICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICAgICAgaWYgKCEobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHRhZywgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgICAgY29uc3QgaXNDb21wb25lbnQgPSBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgIC8vIFRoZSBnb2FsIG9mIHRoZSB0cmFuc2Zvcm0gaXMgdG8gY3JlYXRlIGEgY29kZWdlbk5vZGUgaW1wbGVtZW50aW5nIHRoZVxyXG4gICAgICAgIC8vIFZOb2RlQ2FsbCBpbnRlcmZhY2UuXHJcbiAgICAgICAgbGV0IHZub2RlVGFnID0gaXNDb21wb25lbnRcclxuICAgICAgICAgICAgPyByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0KVxyXG4gICAgICAgICAgICA6IGBcIiR7dGFnfVwiYDtcclxuICAgICAgICBjb25zdCBpc0R5bmFtaWNDb21wb25lbnQgPSBpc09iamVjdCh2bm9kZVRhZykgJiYgdm5vZGVUYWcuY2FsbGVlID09PSBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UO1xyXG4gICAgICAgIGxldCB2bm9kZVByb3BzO1xyXG4gICAgICAgIGxldCB2bm9kZUNoaWxkcmVuO1xyXG4gICAgICAgIGxldCB2bm9kZVBhdGNoRmxhZztcclxuICAgICAgICBsZXQgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICBsZXQgdm5vZGVEeW5hbWljUHJvcHM7XHJcbiAgICAgICAgbGV0IGR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICAgICAgbGV0IHZub2RlRGlyZWN0aXZlcztcclxuICAgICAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBcclxuICAgICAgICAvLyBkeW5hbWljIGNvbXBvbmVudCBtYXkgcmVzb2x2ZSB0byBwbGFpbiBlbGVtZW50c1xyXG4gICAgICAgIGlzRHluYW1pY0NvbXBvbmVudCB8fFxyXG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gVEVMRVBPUlQgfHxcclxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFNVU1BFTlNFIHx8XHJcbiAgICAgICAgICAgICghaXNDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIC8vIDxzdmc+IGFuZCA8Zm9yZWlnbk9iamVjdD4gbXVzdCBiZSBmb3JjZWQgaW50byBibG9ja3Mgc28gdGhhdCBibG9ja1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyBpbnNpZGUgZ2V0IHByb3BlciBpc1NWRyBmbGFnIGF0IHJ1bnRpbWUuICgjNjM5LCAjNjQzKVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSB3ZWItc3BlY2lmaWMsIGJ1dCBzcGxpdHRpbmcgdGhlIGxvZ2ljIG91dCBvZiBjb3JlXHJcbiAgICAgICAgICAgICAgICAvLyBsZWFkcyB0byB0b28gbXVjaCB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4gICAgICAgICAgICAgICAgKHRhZyA9PT0gJ3N2ZycgfHxcclxuICAgICAgICAgICAgICAgICAgICB0YWcgPT09ICdmb3JlaWduT2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICM5Mzg6IGVsZW1lbnRzIHdpdGggZHluYW1pYyBrZXlzIHNob3VsZCBiZSBmb3JjZWQgaW50byBibG9ja3NcclxuICAgICAgICAgICAgICAgICAgICBmaW5kUHJvcChub2RlLCAna2V5JywgdHJ1ZSkpKTtcclxuICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzQnVpbGRSZXN1bHQgPSBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2bm9kZVByb3BzID0gcHJvcHNCdWlsZFJlc3VsdC5wcm9wcztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gcHJvcHNCdWlsZFJlc3VsdC5wYXRjaEZsYWc7XHJcbiAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmRpcmVjdGl2ZXM7XHJcbiAgICAgICAgICAgIHZub2RlRGlyZWN0aXZlcyA9XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyZWN0aXZlcy5tYXAoZGlyID0+IGJ1aWxkRGlyZWN0aXZlQXJncyhkaXIsIGNvbnRleHQpKSlcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hpbGRyZW5cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZVRhZyA9PT0gS0VFUF9BTElWRSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggYSBidWlsdC1pbiBjb21wb25lbnQsIHdlIGNvbXBpbGUgS2VlcEFsaXZlIHdpdGggcmF3IGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHNsb3QgZnVuY3Rpb25zIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW5zaWRlIFRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIC8vIG9yIG90aGVyIFRyYW5zaXRpb24td3JhcHBpbmcgSE9Dcy5cclxuICAgICAgICAgICAgICAgIC8vIFRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMgd2l0aCBibG9jayBvcHRpbWl6YXRpb25zLCB3ZSBuZWVkIHRvOlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gRm9yY2Uga2VlcC1hbGl2ZSBpbnRvIGEgYmxvY2suIFRoaXMgYXZvaWRzIGl0cyBjaGlsZHJlbiBiZWluZ1xyXG4gICAgICAgICAgICAgICAgLy8gICAgY29sbGVjdGVkIGJ5IGEgcGFyZW50IGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gMi4gRm9yY2Uga2VlcC1hbGl2ZSB0byBhbHdheXMgYmUgdXBkYXRlZCwgc2luY2UgaXQgdXNlcyByYXcgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NCAvKiBYX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5jaGlsZHJlblswXS5sb2Muc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQnVpbGRBc1Nsb3RzID0gaXNDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0IGlzIG5vdCBhIHJlYWwgY29tcG9uZW50IGFuZCBoYXMgZGVkaWNhdGVkIHJ1bnRpbWUgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBURUxFUE9SVCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gZXhwbGFpbmVkIGFib3ZlLlxyXG4gICAgICAgICAgICAgICAgdm5vZGVUYWcgIT09IEtFRVBfQUxJVkU7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRCdWlsZEFzU2xvdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2xvdHMsIGhhc0R5bmFtaWNTbG90cyB9ID0gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBzbG90cztcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2xvdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHZub2RlVGFnICE9PSBURUxFUE9SVCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHluYW1pYyB0ZXh0IGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNEeW5hbWljVGV4dENoaWxkID0gdHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxIC8qIFRFWFQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwYXNzIGRpcmVjdGx5IGlmIHRoZSBvbmx5IGNoaWxkIGlzIGEgdGV4dCBub2RlXHJcbiAgICAgICAgICAgICAgICAvLyAocGxhaW4gLyBpbnRlcnBvbGF0aW9uIC8gZXhwcmVzc2lvbilcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkIHx8IHR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGF0Y2hGbGFnICYgZHluYW1pY1Byb3BOYW1lc1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGZsYWdzIChuZWdhdGl2ZSBhbmQgbXV0dWFsbHkgZXhjbHVzaXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlUGF0Y2hGbGFnID0gcGF0Y2hGbGFnICsgYCAvKiAke1BhdGNoRmxhZ05hbWVzW3BhdGNoRmxhZ119ICovYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHdpc2UgZmxhZ3NcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhQYXRjaEZsYWdOYW1lcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChOdW1iZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuID4gMCAmJiBwYXRjaEZsYWcgJiBuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKG4gPT4gUGF0Y2hGbGFnTmFtZXNbbl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKGAsIGApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlUGF0Y2hGbGFnID0gcGF0Y2hGbGFnICsgYCAvKiAke2ZsYWdOYW1lc30gKi9gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBTdHJpbmcocGF0Y2hGbGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZHluYW1pY1Byb3BOYW1lcyAmJiBkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVEeW5hbWljUHJvcHMgPSBzdHJpbmdpZnlEeW5hbWljUHJvcE5hbWVzKGR5bmFtaWNQcm9wTmFtZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdm5vZGVUYWcsIHZub2RlUHJvcHMsIHZub2RlQ2hpbGRyZW4sIHZub2RlUGF0Y2hGbGFnLCB2bm9kZUR5bmFtaWNQcm9wcywgdm5vZGVEaXJlY3RpdmVzLCAhIXNob3VsZFVzZUJsb2NrLCBmYWxzZSAvKiBkaXNhYmxlVHJhY2tpbmcgKi8sIG5vZGUubG9jKTtcclxuICAgIH07XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBsZXQgeyB0YWcgfSA9IG5vZGU7XHJcbiAgICAvLyAxLiBkeW5hbWljIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaXNFeHBsaWNpdER5bmFtaWMgPSBpc0NvbXBvbmVudFRhZyh0YWcpO1xyXG4gICAgY29uc3QgaXNQcm9wID0gZmluZFByb3Aobm9kZSwgJ2lzJykgfHwgKCFpc0V4cGxpY2l0RHluYW1pYyAmJiBmaW5kRGlyKG5vZGUsICdpcycpKTtcclxuICAgIGlmIChpc1Byb3ApIHtcclxuICAgICAgICBpZiAoIWlzRXhwbGljaXREeW5hbWljICYmIGlzUHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICAvLyA8YnV0dG9uIGlzPVwidnVlOnh4eFwiPlxyXG4gICAgICAgICAgICAvLyBpZiBub3QgPGNvbXBvbmVudD4sIG9ubHkgaXMgdmFsdWUgdGhhdCBzdGFydHMgd2l0aCBcInZ1ZTpcIiB3aWxsIGJlXHJcbiAgICAgICAgICAgIC8vIHRyZWF0ZWQgYXMgY29tcG9uZW50IGJ5IHRoZSBwYXJzZSBwaGFzZSBhbmQgcmVhY2ggaGVyZSwgdW5sZXNzIGl0J3NcclxuICAgICAgICAgICAgLy8gY29tcGF0IG1vZGUgd2hlcmUgYWxsIGlzIHZhbHVlcyBhcmUgY29uc2lkZXJlZCBjb21wb25lbnRzXHJcbiAgICAgICAgICAgIHRhZyA9IGlzUHJvcC52YWx1ZS5jb250ZW50LnJlcGxhY2UoL152dWU6LywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwID0gaXNQcm9wLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovXHJcbiAgICAgICAgICAgICAgICA/IGlzUHJvcC52YWx1ZSAmJiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGlzUHJvcC52YWx1ZS5jb250ZW50LCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgOiBpc1Byb3AuZXhwO1xyXG4gICAgICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCksIFtcclxuICAgICAgICAgICAgICAgICAgICBleHBcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMi4gYnVpbHQtaW4gY29tcG9uZW50cyAoVGVsZXBvcnQsIFRyYW5zaXRpb24sIEtlZXBBbGl2ZSwgU3VzcGVuc2UuLi4pXHJcbiAgICBjb25zdCBidWlsdEluID0gaXNDb3JlQ29tcG9uZW50KHRhZykgfHwgY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQodGFnKTtcclxuICAgIGlmIChidWlsdEluKSB7XHJcbiAgICAgICAgLy8gYnVpbHQtaW5zIGFyZSBzaW1wbHkgZmFsbHRocm91Z2hzIC8gaGF2ZSBzcGVjaWFsIGhhbmRsaW5nIGR1cmluZyBzc3JcclxuICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGltcG9ydCB0aGVpciBydW50aW1lIGVxdWl2YWxlbnRzXHJcbiAgICAgICAgaWYgKCFzc3IpXHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGJ1aWx0SW4pO1xyXG4gICAgICAgIHJldHVybiBidWlsdEluO1xyXG4gICAgfVxyXG4gICAgLy8gNS4gdXNlciBjb21wb25lbnQgKHJlc29sdmUpXHJcbiAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0NPTVBPTkVOVCk7XHJcbiAgICBjb250ZXh0LmNvbXBvbmVudHMuYWRkKHRhZyk7XHJcbiAgICByZXR1cm4gdG9WYWxpZEFzc2V0SWQodGFnLCBgY29tcG9uZW50YCk7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBwcm9wcyA9IG5vZGUucHJvcHMsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IHRhZywgbG9jOiBlbGVtZW50TG9jIH0gPSBub2RlO1xyXG4gICAgY29uc3QgaXNDb21wb25lbnQgPSBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgbGV0IHByb3BlcnRpZXMgPSBbXTtcclxuICAgIGNvbnN0IG1lcmdlQXJncyA9IFtdO1xyXG4gICAgY29uc3QgcnVudGltZURpcmVjdGl2ZXMgPSBbXTtcclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgbGV0IHBhdGNoRmxhZyA9IDA7XHJcbiAgICBsZXQgaGFzUmVmID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzQ2xhc3NCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzU3R5bGVCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzRHluYW1pY0tleXMgPSBmYWxzZTtcclxuICAgIGxldCBoYXNWbm9kZUhvb2sgPSBmYWxzZTtcclxuICAgIGNvbnN0IGR5bmFtaWNQcm9wTmFtZXMgPSBbXTtcclxuICAgIGNvbnN0IGFuYWx5emVQYXRjaEZsYWcgPSAoeyBrZXksIHZhbHVlIH0pID0+IHtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRXZlbnRIYW5kbGVyID0gaXNPbihuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgaXNFdmVudEhhbmRsZXIgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdGhlIGZsYWcgZm9yIGNsaWNrIGhhbmRsZXJzIGJlY2F1c2UgaHlkcmF0aW9uIGdpdmVzIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAvLyBkZWRpY2F0ZWQgZmFzdCBwYXRoLlxyXG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25jbGljaycgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdi1tb2RlbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ29uVXBkYXRlOm1vZGVsVmFsdWUnICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcclxuICAgICAgICAgICAgICAgICFpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiYgaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGhhc1Zub2RlSG9vayA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICgodmFsdWUudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUodmFsdWUsIGNvbnRleHQpID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIHByb3AgaXMgYSBjYWNoZWQgaGFuZGxlciBvciBoYXMgY29uc3RhbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhhc0NsYXNzQmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJyAmJiAhaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhhc1N0eWxlQmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ2tleScgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY0tleXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gc3RhdGljIGF0dHJpYnV0ZVxyXG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcclxuICAgICAgICBpZiAocHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxvYywgbmFtZSwgdmFsdWUgfSA9IHByb3A7XHJcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xyXG4gICAgICAgICAgICAgICAgaGFzUmVmID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIGlzIG9uIDxjb21wb25lbnQ+LCBvciBpcz1cInZ1ZTp4eHhcIlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJlxyXG4gICAgICAgICAgICAgICAgKGlzQ29tcG9uZW50VGFnKHRhZykgfHwgKHZhbHVlICYmIHZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKG5hbWUsIHRydWUsIGdldElubmVyUmFuZ2UobG9jLCAwLCBuYW1lLmxlbmd0aCkpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHZhbHVlID8gdmFsdWUuY29udGVudCA6ICcnLCBpc1N0YXRpYywgdmFsdWUgPyB2YWx1ZS5sb2MgOiBsb2MpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzXHJcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJnLCBleHAsIGxvYyB9ID0gcHJvcDtcclxuICAgICAgICAgICAgY29uc3QgaXNWQmluZCA9IG5hbWUgPT09ICdiaW5kJztcclxuICAgICAgICAgICAgY29uc3QgaXNWT24gPSBuYW1lID09PSAnb24nO1xyXG4gICAgICAgICAgICAvLyBza2lwIHYtc2xvdCAtIGl0IGlzIGhhbmRsZWQgYnkgaXRzIGRlZGljYXRlZCB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzOSAvKiBYX1ZfU0xPVF9NSVNQTEFDRUQgKi8sIGxvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCB2LW9uY2UgLSBpdCBpcyBoYW5kbGVkIGJ5IGl0cyBkZWRpY2F0ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ29uY2UnKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtaXMgYW5kIDppcyBvbiA8Y29tcG9uZW50PlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyB8fFxyXG4gICAgICAgICAgICAgICAgKGlzVkJpbmQgJiYgaXNDb21wb25lbnRUYWcodGFnKSAmJiBpc0JpbmRLZXkoYXJnLCAnaXMnKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1vbiBpbiBTU1IgY29tcGlsYXRpb25cclxuICAgICAgICAgICAgaWYgKGlzVk9uICYmIHNzcikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB2LWJpbmQgYW5kIHYtb24gd2l0aCBubyBhcmd1bWVudFxyXG4gICAgICAgICAgICBpZiAoIWFyZyAmJiAoaXNWQmluZCB8fCBpc1ZPbikpIHtcclxuICAgICAgICAgICAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChleHApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVkJpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi54IHYtYmluZCBvYmplY3Qgb3JkZXIgY29tcGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzT3ZlcnJpZGFibGVLZXlzID0gbWVyZ2VBcmdzLnNvbWUoYXJnID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5wcm9wZXJ0aWVzLnNvbWUoKHsga2V5IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWtleS5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChrZXkuY29udGVudCAhPT0gJ2NsYXNzJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkuY29udGVudCAhPT0gJ3N0eWxlJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNPbihrZXkuY29udGVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJyaWRhYmxlS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIgLyogQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqLywgY29udGV4dCwgbG9jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiIC8qIENPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVIgKi8sIGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnVuc2hpZnQoZXhwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChleHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1vbj1cIm9ialwiIC0+IHRvSGFuZGxlcnMob2JqKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IGNvbnRleHQuaGVscGVyKFRPX0hBTkRMRVJTKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2V4cF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoaXNWQmluZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDMzIC8qIFhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAzNCAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmVUcmFuc2Zvcm0gPSBjb250ZXh0LmRpcmVjdGl2ZVRyYW5zZm9ybXNbbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmVUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGhhcyBidWlsdC1pbiBkaXJlY3RpdmUgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgbmVlZFJ1bnRpbWUgfSA9IGRpcmVjdGl2ZVRyYW5zZm9ybShwcm9wLCBub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICFzc3IgJiYgcHJvcHMuZm9yRWFjaChhbmFseXplUGF0Y2hGbGFnKTtcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCguLi5wcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVlZFJ1bnRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBydW50aW1lRGlyZWN0aXZlcy5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bWJvbChuZWVkUnVudGltZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlSW1wb3J0TWFwLnNldChwcm9wLCBuZWVkUnVudGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gYnVpbHQtaW4gdHJhbnNmb3JtLCB0aGlzIGlzIGEgdXNlciBjdXN0b20gZGlyZWN0aXZlLlxyXG4gICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJlxyXG4gICAgICAgICAgICBwcm9wLm5hbWUgPT09ICdyZWYnICYmXHJcbiAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwICYmXHJcbiAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfRk9SX1JFRlwiIC8qIENPTVBJTEVSX1ZfRk9SX1JFRiAqLywgY29udGV4dCwgcHJvcC5sb2MpKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdyZWZJbkZvcicsIHRydWUpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCd0cnVlJywgZmFsc2UpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHByb3BzRXhwcmVzc2lvbiA9IHVuZGVmaW5lZDtcclxuICAgIC8vIGhhcyB2LWJpbmQ9XCJvYmplY3RcIiBvciB2LW9uPVwib2JqZWN0XCIsIHdyYXAgd2l0aCBtZXJnZVByb3BzXHJcbiAgICBpZiAobWVyZ2VBcmdzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmdlQXJncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgbWVyZ2VBcmdzLCBlbGVtZW50TG9jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBub3RoaW5nIGVsc2UgLSBubyBuZWVkIGZvciBhIG1lcmdlUHJvcHMgY2FsbFxyXG4gICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBtZXJnZUFyZ3NbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpO1xyXG4gICAgfVxyXG4gICAgLy8gcGF0Y2hGbGFnIGFuYWx5c2lzXHJcbiAgICBpZiAoaGFzRHluYW1pY0tleXMpIHtcclxuICAgICAgICBwYXRjaEZsYWcgfD0gMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChoYXNDbGFzc0JpbmRpbmcpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIgLyogQ0xBU1MgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNTdHlsZUJpbmRpbmcpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDQgLyogU1RZTEUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gOCAvKiBQUk9QUyAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZykge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChwYXRjaEZsYWcgPT09IDAgfHwgcGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykgJiZcclxuICAgICAgICAoaGFzUmVmIHx8IGhhc1Zub2RlSG9vayB8fCBydW50aW1lRGlyZWN0aXZlcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSA1MTIgLyogTkVFRF9QQVRDSCAqLztcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IHByb3BzRXhwcmVzc2lvbixcclxuICAgICAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BOYW1lc1xyXG4gICAgfTtcclxufVxyXG4vLyBEZWR1cGUgcHJvcHMgaW4gYW4gb2JqZWN0IGxpdGVyYWwuXHJcbi8vIExpdGVyYWwgZHVwbGljYXRlZCBhdHRyaWJ1dGVzIHdvdWxkIGhhdmUgYmVlbiB3YXJuZWQgZHVyaW5nIHRoZSBwYXJzZSBwaGFzZSxcclxuLy8gaG93ZXZlciwgaXQncyBwb3NzaWJsZSB0byBlbmNvdW50ZXIgZHVwbGljYXRlZCBgb25YWFhgIGhhbmRsZXJzIHdpdGggZGlmZmVyZW50XHJcbi8vIG1vZGlmaWVycy4gV2UgYWxzbyBuZWVkIHRvIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBjbGFzcyAvIHN0eWxlIGF0dHJpYnV0ZXMuXHJcbi8vIC0gb25YWFggaGFuZGxlcnMgLyBzdHlsZTogbWVyZ2UgaW50byBhcnJheVxyXG4vLyAtIGNsYXNzOiBtZXJnZSBpbnRvIHNpbmdsZSBleHByZXNzaW9uIHdpdGggY29uY2F0ZW5hdGlvblxyXG5mdW5jdGlvbiBkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcclxuICAgIGNvbnN0IGtub3duUHJvcHMgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBkZWR1cGVkID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAvLyBkeW5hbWljIGtleXMgYXJlIGFsd2F5cyBhbGxvd2VkXHJcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyB8fCAhcHJvcC5rZXkuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBrbm93blByb3BzLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScgfHwgbmFtZSA9PT0gJ2NsYXNzJyB8fCBuYW1lLnN0YXJ0c1dpdGgoJ29uJykpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlQXNBcnJheShleGlzdGluZywgcHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBkdXBsaWNhdGUsIHNob3VsZCBoYXZlIGVtaXR0ZWQgZXJyb3IgZHVyaW5nIHBhcnNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBrbm93blByb3BzLnNldChuYW1lLCBwcm9wKTtcclxuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWR1cGVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcclxuICAgIGlmIChleGlzdGluZy52YWx1ZS50eXBlID09PSAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleGlzdGluZy52YWx1ZSA9IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSwgZXhpc3RpbmcubG9jKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBkaXJBcmdzID0gW107XHJcbiAgICBjb25zdCBydW50aW1lID0gZGlyZWN0aXZlSW1wb3J0TWFwLmdldChkaXIpO1xyXG4gICAgaWYgKHJ1bnRpbWUpIHtcclxuICAgICAgICAvLyBidWlsdC1pbiBkaXJlY3RpdmUgd2l0aCBydW50aW1lXHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGNvbnRleHQuaGVscGVyU3RyaW5nKHJ1bnRpbWUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaW5qZWN0IHN0YXRlbWVudCBmb3IgcmVzb2x2aW5nIGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0RJUkVDVElWRSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlcy5hZGQoZGlyLm5hbWUpO1xyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2MgfSA9IGRpcjtcclxuICAgIGlmIChkaXIuZXhwKVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuZXhwKTtcclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuYXJnKTtcclxuICAgIH1cclxuICAgIGlmIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzKS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoIWRpci5hcmcpIHtcclxuICAgICAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRydWVFeHByZXNzaW9uID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gICAgICAgIGRpckFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRpci5tb2RpZmllcnMubWFwKG1vZGlmaWVyID0+IGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyLCB0cnVlRXhwcmVzc2lvbikpLCBsb2MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyQXJncywgZGlyLmxvYyk7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhwcm9wcykge1xyXG4gICAgbGV0IHByb3BzTmFtZXNTdHJpbmcgPSBgW2A7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkocHJvcHNbaV0pO1xyXG4gICAgICAgIGlmIChpIDwgbCAtIDEpXHJcbiAgICAgICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gJywgJztcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wc05hbWVzU3RyaW5nICsgYF1gO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnKHRhZykge1xyXG4gICAgcmV0dXJuIHRhZ1swXS50b0xvd2VyQ2FzZSgpICsgdGFnLnNsaWNlKDEpID09PSAnY29tcG9uZW50JztcclxufVxuXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAoKHN0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xyXG59KTtcblxuY29uc3QgdHJhbnNmb3JtU2xvdE91dGxldCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAoaXNTbG90T3V0bGV0KG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHsgc2xvdE5hbWUsIHNsb3RQcm9wcyB9ID0gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3Qgc2xvdEFyZ3MgPSBbXHJcbiAgICAgICAgICAgIGNvbnRleHQucHJlZml4SWRlbnRpZmllcnMgPyBgX2N0eC4kc2xvdHNgIDogYCRzbG90c2AsXHJcbiAgICAgICAgICAgIHNsb3ROYW1lXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAoc2xvdFByb3BzKSB7XHJcbiAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goc2xvdFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChge31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbG90QXJncy5wdXNoKGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihbXSwgY2hpbGRyZW4sIGZhbHNlLCBmYWxzZSwgbG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0LnNjb3BlSWQgJiYgIWNvbnRleHQuc2xvdHRlZCkge1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChge31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChgdW5kZWZpbmVkYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChgdHJ1ZWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX1NMT1QpLCBzbG90QXJncywgbG9jKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCkge1xyXG4gICAgbGV0IHNsb3ROYW1lID0gYFwiZGVmYXVsdFwiYDtcclxuICAgIGxldCBzbG90UHJvcHMgPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBub25OYW1lUHJvcHMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnbmFtZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90TmFtZSA9IEpTT04uc3RyaW5naWZ5KHAudmFsdWUuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwLm5hbWUgPSBjYW1lbGl6ZShwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgaXNCaW5kS2V5KHAuYXJnLCAnbmFtZScpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5leHApXHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBwLmV4cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBwLmFyZyAmJiBpc1N0YXRpY0V4cChwLmFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwLmFyZy5jb250ZW50ID0gY2FtZWxpemUocC5hcmcuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub25OYW1lUHJvcHMucHVzaChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub25OYW1lUHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGRpcmVjdGl2ZXMgfSA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgbm9uTmFtZVByb3BzKTtcclxuICAgICAgICBzbG90UHJvcHMgPSBwcm9wcztcclxuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzUgLyogWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVQgKi8sIGRpcmVjdGl2ZXNbMF0ubG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzbG90TmFtZSxcclxuICAgICAgICBzbG90UHJvcHNcclxuICAgIH07XHJcbn1cblxuY29uc3QgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5cXHMqZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XHJcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCwgYXVnbWVudG9yKSA9PiB7XHJcbiAgICBjb25zdCB7IGxvYywgbW9kaWZpZXJzLCBhcmcgfSA9IGRpcjtcclxuICAgIGlmICghZGlyLmV4cCAmJiAhbW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM0IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIGxldCBldmVudE5hbWU7XHJcbiAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd05hbWUgPSBhcmcuY29udGVudDtcclxuICAgICAgICAgICAgLy8gZm9yIGFsbCBldmVudCBsaXN0ZW5lcnMsIGF1dG8gY29udmVydCBpdCB0byBjYW1lbENhc2UuIFNlZSBpc3N1ZSAjMjI0OVxyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHRvSGFuZGxlcktleShjYW1lbGl6ZSQxKHJhd05hbWUpKSwgdHJ1ZSwgYXJnLmxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAjMjM4OFxyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgLFxyXG4gICAgICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICAgICAgYClgXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGFscmVhZHkgYSBjb21wb3VuZCBleHByZXNzaW9uLlxyXG4gICAgICAgIGV2ZW50TmFtZSA9IGFyZztcclxuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGApO1xyXG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICB9XHJcbiAgICAvLyBoYW5kbGVyIHByb2Nlc3NpbmdcclxuICAgIGxldCBleHAgPSBkaXIuZXhwO1xyXG4gICAgaWYgKGV4cCAmJiAhZXhwLmNvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgZXhwID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgbGV0IHNob3VsZENhY2hlID0gY29udGV4dC5jYWNoZUhhbmRsZXJzICYmICFleHA7XHJcbiAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgY29uc3QgaXNNZW1iZXJFeHAgPSBpc01lbWJlckV4cHJlc3Npb24oZXhwLmNvbnRlbnQpO1xyXG4gICAgICAgIGNvbnN0IGlzSW5saW5lU3RhdGVtZW50ID0gIShpc01lbWJlckV4cCB8fCBmbkV4cFJFLnRlc3QoZXhwLmNvbnRlbnQpKTtcclxuICAgICAgICBjb25zdCBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPSBleHAuY29udGVudC5pbmNsdWRlcyhgO2ApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgZmFsc2UsIGhhc011bHRpcGxlU3RhdGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0lubGluZVN0YXRlbWVudCB8fCAoc2hvdWxkQ2FjaGUgJiYgaXNNZW1iZXJFeHApKSB7XHJcbiAgICAgICAgICAgIC8vIHdyYXAgaW5saW5lIHN0YXRlbWVudCBpbiBhIGZ1bmN0aW9uIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgZXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAke2lzSW5saW5lU3RhdGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgJGV2ZW50YFxyXG4gICAgICAgICAgICAgICAgICAgIDogYCR7YGB9KC4uLmFyZ3MpYH0gPT4gJHtoYXNNdWx0aXBsZVN0YXRlbWVudHMgPyBge2AgOiBgKGB9YCxcclxuICAgICAgICAgICAgICAgIGV4cCxcclxuICAgICAgICAgICAgICAgIGhhc011bHRpcGxlU3RhdGVtZW50cyA/IGB9YCA6IGApYFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgcmV0ID0ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCgpID0+IHt9YCwgZmFsc2UsIGxvYykpXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxuICAgIC8vIGFwcGx5IGV4dGVuZGVkIGNvbXBpbGVyIGF1Z21lbnRvclxyXG4gICAgaWYgKGF1Z21lbnRvcikge1xyXG4gICAgICAgIHJldCA9IGF1Z21lbnRvcihyZXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNob3VsZENhY2hlKSB7XHJcbiAgICAgICAgLy8gY2FjaGUgaGFuZGxlcnMgc28gdGhhdCBpdCdzIGFsd2F5cyB0aGUgc2FtZSBoYW5kbGVyIGJlaW5nIHBhc3NlZCBkb3duLlxyXG4gICAgICAgIC8vIHRoaXMgYXZvaWRzIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgd2hlbiB1c2VycyB1c2UgaW5saW5lIGhhbmRsZXJzIG9uXHJcbiAgICAgICAgLy8gY29tcG9uZW50cy5cclxuICAgICAgICByZXQucHJvcHNbMF0udmFsdWUgPSBjb250ZXh0LmNhY2hlKHJldC5wcm9wc1swXS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xuXG4vLyB2LWJpbmQgd2l0aG91dCBhcmcgaXMgaGFuZGxlZCBkaXJlY3RseSBpbiAuL3RyYW5zZm9ybUVsZW1lbnRzLnRzIGR1ZSB0byBpdCBhZmZlY3RpbmdcclxuLy8gY29kZWdlbiBmb3IgdGhlIGVudGlyZSBwcm9wcyBvYmplY3QuIFRoaXMgdHJhbnNmb3JtIGhlcmUgaXMgb25seSBmb3Igdi1iaW5kXHJcbi8vICp3aXRoKiBhcmdzLlxyXG5jb25zdCB0cmFuc2Zvcm1CaW5kID0gKGRpciwgX25vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBtb2RpZmllcnMsIGxvYyB9ID0gZGlyO1xyXG4gICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgIGlmIChhcmcudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAoYCk7XHJcbiAgICAgICAgYXJnLmNoaWxkcmVuLnB1c2goYCkgfHwgXCJcImApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgIGFyZy5jb250ZW50ID0gYCR7YXJnLmNvbnRlbnR9IHx8IFwiXCJgO1xyXG4gICAgfVxyXG4gICAgLy8gLnByb3AgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBkdWUgdG8gbmV3IHBhdGNoIGJlaGF2aW9yXHJcbiAgICAvLyAuc3luYyBpcyByZXBsYWNlZCBieSB2LW1vZGVsOmFyZ1xyXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xyXG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICBhcmcuY29udGVudCA9IGNhbWVsaXplJDEoYXJnLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KCR7YXJnLmNvbnRlbnR9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKENBTUVMSVpFKX0oYCk7XHJcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFleHAgfHxcclxuICAgICAgICAoZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgIWV4cC5jb250ZW50LnRyaW0oKSkpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMyAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSwgbG9jKSldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGV4cCldXHJcbiAgICB9O1xyXG59O1xuXG4vLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGFuZCBleHByZXNzaW9ucyBpbnRvIGEgc2luZ2xlIGV4cHJlc3Npb25cclxuLy8gZS5nLiA8ZGl2PmFiYyB7eyBkIH19IHt7IGUgfX08L2Rpdj4gc2hvdWxkIGhhdmUgYSBzaW5nbGUgZXhwcmVzc2lvbiBub2RlIGFzIGNoaWxkLlxyXG5jb25zdCB0cmFuc2Zvcm1UZXh0ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDAgLyogUk9PVCAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxMSAvKiBGT1IgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEwIC8qIElGX0JSQU5DSCAqLykge1xyXG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIHRyYW5zZm9ybSBvbiBub2RlIGV4aXQgc28gdGhhdCBhbGwgZXhwcmVzc2lvbnMgaGF2ZSBhbHJlYWR5XHJcbiAgICAgICAgLy8gYmVlbiBwcm9jZXNzZWQuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbGV0IGhhc1RleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RleHQoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGNoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gY2hpbGRyZW5baV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBjaGlsZC5sb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbY2hpbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZSBpbnRvIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIuY2hpbGRyZW4ucHVzaChgICsgYCwgbmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFoYXNUZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIHRleHQgY2hpbGQsIGxlYXZlIGl0XHJcbiAgICAgICAgICAgICAgICAvLyBhcy1pcyBzaW5jZSB0aGUgcnVudGltZSBoYXMgZGVkaWNhdGVkIGZhc3QgcGF0aCBmb3IgdGhpcyBieSBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBjb21wb25lbnQgcm9vdCBpdCdzIGFsd2F5cyBub3JtYWxpemVkIGFueXdheS5cclxuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAobm9kZS50eXBlID09PSAwIC8qIFJPT1QgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzM3NTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBkaXJlY3RpdmVzIGNhbiBwb3RlbnRpYWxseSBhZGQgRE9NIGVsZW1lbnRzIGFyYml0cmFyaWx5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhdm9pZCBzZXR0aW5nIHRleHRDb250ZW50IG9mIHRoZSBlbGVtZW50IGF0IHJ1bnRpbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGFjY2lkZW50YWxseSBvdmVyd3JpdGluZyB0aGUgRE9NIGVsZW1lbnRzIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSB0aGUgdXNlciB0aHJvdWdoIGN1c3RvbSBkaXJlY3RpdmVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIW5vZGUucHJvcHMuZmluZChwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY29udGV4dC5kaXJlY3RpdmVUcmFuc2Zvcm1zW3AubmFtZV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjb21wYXQgbW9kZSwgPHRlbXBsYXRlPiB0YWdzIHdpdGggbm8gc3BlY2lhbCBkaXJlY3RpdmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgZnJhZ21lbnQgc28gaXRzIGNoaWxkcmVuIG11c3QgYmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIHZub2Rlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEobm9kZS50YWcgPT09ICd0ZW1wbGF0ZScpKSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJlLWNvbnZlcnQgdGV4dCBub2RlcyBpbnRvIGNyZWF0ZVRleHRWTm9kZSh0ZXh0KSBjYWxscyB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyBydW50aW1lIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KGNoaWxkKSB8fCBjaGlsZC50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsQXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZVRleHRWTm9kZSBkZWZhdWx0cyB0byBzaW5nbGUgd2hpdGVzcGFjZSwgc28gaWYgaXQgaXMgYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcGFjZSB0aGUgY29kZSBjb3VsZCBiZSBhbiBlbXB0eSBjYWxsIHRvIHNhdmUgYnl0ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IDIgLyogVEVYVCAqLyB8fCBjaGlsZC5jb250ZW50ICE9PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3MucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgZHluYW1pYyB0ZXh0IHdpdGggZmxhZyBzbyBpdCBnZXRzIHBhdGNoZWQgaW5zaWRlIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goMSAvKiBURVhUICovICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbMSAvKiBURVhUICovXX0gKi9gIDogYGApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDEyIC8qIFRFWFRfQ0FMTCAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogY2hpbGQubG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZTogY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1RFWFQpLCBjYWxsQXJncylcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XHJcbmNvbnN0IHRyYW5zZm9ybU9uY2UgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIGZpbmREaXIobm9kZSwgJ29uY2UnLCB0cnVlKSkge1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyhub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW4uYWRkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRleHQuaGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3VyID0gY29udGV4dC5jdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKGN1ci5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY3VyLmNvZGVnZW5Ob2RlID0gY29udGV4dC5jYWNoZShjdXIuY29kZWdlbk5vZGUsIHRydWUgLyogaXNWTm9kZSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBhcmcgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDAgLyogWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhd0V4cCA9IGV4cC5sb2Muc291cmNlO1xyXG4gICAgY29uc3QgZXhwU3RyaW5nID0gZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gPyBleHAuY29udGVudCA6IHJhd0V4cDtcclxuICAgIC8vIGltIFNGQyA8c2NyaXB0IHNldHVwPiBpbmxpbmUgbW9kZSwgdGhlIGV4cCBtYXkgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIGludG9cclxuICAgIC8vIF91bnJlZihleHApXHJcbiAgICBjb250ZXh0LmJpbmRpbmdNZXRhZGF0YVtyYXdFeHBdO1xyXG4gICAgY29uc3QgbWF5YmVSZWYgPSAhdHJ1ZSAgICAvKiBTRVRVUF9DT05TVCAqLztcclxuICAgIGlmICghaXNNZW1iZXJFeHByZXNzaW9uKGV4cFN0cmluZykgJiYgIW1heWJlUmVmKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDEgLyogWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCBleHAubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wTmFtZSA9IGFyZyA/IGFyZyA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ21vZGVsVmFsdWUnLCB0cnVlKTtcclxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IGFyZ1xyXG4gICAgICAgID8gaXNTdGF0aWNFeHAoYXJnKVxyXG4gICAgICAgICAgICA/IGBvblVwZGF0ZToke2FyZy5jb250ZW50fWBcclxuICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oWydcIm9uVXBkYXRlOlwiICsgJywgYXJnXSlcclxuICAgICAgICA6IGBvblVwZGF0ZTptb2RlbFZhbHVlYDtcclxuICAgIGxldCBhc3NpZ25tZW50RXhwO1xyXG4gICAgY29uc3QgZXZlbnRBcmcgPSBjb250ZXh0LmlzVFMgPyBgKCRldmVudDogYW55KWAgOiBgJGV2ZW50YDtcclxuICAgIHtcclxuICAgICAgICBhc3NpZ25tZW50RXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgYCR7ZXZlbnRBcmd9ID0+IChgLFxyXG4gICAgICAgICAgICBleHAsXHJcbiAgICAgICAgICAgIGAgPSAkZXZlbnQpYFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcHMgPSBbXHJcbiAgICAgICAgLy8gbW9kZWxWYWx1ZTogZm9vXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkocHJvcE5hbWUsIGRpci5leHApLFxyXG4gICAgICAgIC8vIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiAkZXZlbnQgPT4gKGZvbyA9ICRldmVudClcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGFzc2lnbm1lbnRFeHApXHJcbiAgICBdO1xyXG4gICAgLy8gbW9kZWxNb2RpZmllcnM6IHsgZm9vOiB0cnVlLCBcImJhci1iYXpcIjogdHJ1ZSB9XHJcbiAgICBpZiAoZGlyLm1vZGlmaWVycy5sZW5ndGggJiYgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnNcclxuICAgICAgICAgICAgLm1hcChtID0+IChpc1NpbXBsZUlkZW50aWZpZXIobSkgPyBtIDogSlNPTi5zdHJpbmdpZnkobSkpICsgYDogdHJ1ZWApXHJcbiAgICAgICAgICAgIC5qb2luKGAsIGApO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGFyZ1xyXG4gICAgICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcclxuICAgICAgICAgICAgICAgID8gYCR7YXJnLmNvbnRlbnR9TW9kaWZpZXJzYFxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2FyZywgJyArIFwiTW9kaWZpZXJzXCInXSlcclxuICAgICAgICAgICAgOiBgbW9kZWxNb2RpZmllcnNgO1xyXG4gICAgICAgIHByb3BzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkobW9kaWZpZXJzS2V5LCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB7ICR7bW9kaWZpZXJzfSB9YCwgZmFsc2UsIGRpci5sb2MsIDIgLyogQ0FOX0hPSVNUICovKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzKTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMgPSBbXSkge1xyXG4gICAgcmV0dXJuIHsgcHJvcHMgfTtcclxufVxuXG5jb25zdCB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xyXG5jb25zdCB0cmFuc2Zvcm1GaWx0ZXIgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKCFpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDT01QSUxFUl9GSUxURVJTICovLCBjb250ZXh0KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLykge1xyXG4gICAgICAgIC8vIGZpbHRlciByZXdyaXRlIGlzIGFwcGxpZWQgYmVmb3JlIGV4cHJlc3Npb24gdHJhbnNmb3JtIHNvIG9ubHlcclxuICAgICAgICAvLyBzaW1wbGUgZXhwcmVzc2lvbnMgYXJlIHBvc3NpYmxlIGF0IHRoaXMgc3RhZ2VcclxuICAgICAgICByZXdyaXRlRmlsdGVyKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICBub2RlLnByb3BzLmZvckVhY2goKHByb3ApID0+IHtcclxuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgIHByb3AubmFtZSAhPT0gJ2ZvcicgJiZcclxuICAgICAgICAgICAgICAgIHByb3AuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKHByb3AuZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZUZpbHRlcihjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihjaGlsZC5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBleHAgPSBub2RlLmNvbnRlbnQ7XHJcbiAgICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcclxuICAgIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xyXG4gICAgbGV0IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcclxuICAgIGxldCBpblJlZ2V4ID0gZmFsc2U7XHJcbiAgICBsZXQgY3VybHkgPSAwO1xyXG4gICAgbGV0IHNxdWFyZSA9IDA7XHJcbiAgICBsZXQgcGFyZW4gPSAwO1xyXG4gICAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XHJcbiAgICBsZXQgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycyA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByZXYgPSBjO1xyXG4gICAgICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoaW5TaW5nbGUpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluU2luZ2xlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluRG91YmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluUmVnZXgpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluUmVnZXggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gMHg3YyAmJiAvLyBwaXBlXHJcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3YyAmJlxyXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N2MgJiZcclxuICAgICAgICAgICAgIWN1cmx5ICYmXHJcbiAgICAgICAgICAgICFzcXVhcmUgJiZcclxuICAgICAgICAgICAgIXBhcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDIyOlxyXG4gICAgICAgICAgICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXCJcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyNzpcclxuICAgICAgICAgICAgICAgICAgICBpblNpbmdsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vICdcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg2MDpcclxuICAgICAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYFxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDI4OlxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIChcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyOTpcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyApXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWI6XHJcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg1ZDpcclxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUtLTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXVxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDdiOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cmx5Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg3ZDpcclxuICAgICAgICAgICAgICAgICAgICBjdXJseS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYpIHtcclxuICAgICAgICAgICAgICAgIC8vIC9cclxuICAgICAgICAgICAgICAgIGxldCBqID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgcDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gJyAnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5SZWdleCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcclxuICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xyXG4gICAgICAgIGZpbHRlcnMucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xyXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX0ZJTFRFUlwiIC8qIENPTVBJTEVSX0ZJTFRFUlMgKi8sIGNvbnRleHQsIG5vZGUubG9jKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb250ZW50ID0gZXhwcmVzc2lvbjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cmFwRmlsdGVyKGV4cCwgZmlsdGVyLCBjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0ZJTFRFUik7XHJcbiAgICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcclxuICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGNvbnRleHQuZmlsdGVycy5hZGQoZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gYCR7dG9WYWxpZEFzc2V0SWQoZmlsdGVyLCAnZmlsdGVyJyl9KCR7ZXhwfSlgO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcclxuICAgICAgICBjb25zdCBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICBjb250ZXh0LmZpbHRlcnMuYWRkKG5hbWUpO1xyXG4gICAgICAgIHJldHVybiBgJHt0b1ZhbGlkQXNzZXRJZChuYW1lLCAnZmlsdGVyJyl9KCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YDtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KHByZWZpeElkZW50aWZpZXJzKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT25jZSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtSWYsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUZvcixcclxuICAgICAgICAgICAgLi4uKFt0cmFuc2Zvcm1GaWx0ZXJdICksXHJcbiAgICAgICAgICAgIC4uLigocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IFt0cmFuc2Zvcm1FeHByZXNzaW9uXVxyXG4gICAgICAgICAgICAgICAgICAgIDogW10pLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1TbG90T3V0bGV0LFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1FbGVtZW50LFxyXG4gICAgICAgICAgICB0cmFja1Nsb3RTY29wZXMsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVRleHRcclxuICAgICAgICBdLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb246IHRyYW5zZm9ybU9uLFxyXG4gICAgICAgICAgICBiaW5kOiB0cmFuc2Zvcm1CaW5kLFxyXG4gICAgICAgICAgICBtb2RlbDogdHJhbnNmb3JtTW9kZWxcclxuICAgICAgICB9XHJcbiAgICBdO1xyXG59XHJcbi8vIHdlIG5hbWUgaXQgYGJhc2VDb21waWxlYCBzbyB0aGF0IGhpZ2hlciBvcmRlciBjb21waWxlcnMgbGlrZVxyXG4vLyBAdnVlL2NvbXBpbGVyLWRvbSBjYW4gZXhwb3J0IGBjb21waWxlYCB3aGlsZSByZS1leHBvcnRpbmcgZXZlcnl0aGluZyBlbHNlLlxyXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xyXG4gICAgY29uc3QgaXNNb2R1bGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnbW9kdWxlJztcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeElkZW50aWZpZXJzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NSAvKiBYX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTW9kdWxlTW9kZSkge1xyXG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDYgLyogWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcHJlZml4SWRlbnRpZmllcnMgPSAhdHJ1ZSA7XHJcbiAgICBpZiAob3B0aW9ucy5jYWNoZUhhbmRsZXJzKSB7XHJcbiAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ3IC8qIFhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5zY29wZUlkICYmICFpc01vZHVsZU1vZGUpIHtcclxuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDggLyogWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhc3QgPSBpc1N0cmluZyh0ZW1wbGF0ZSkgPyBiYXNlUGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIDogdGVtcGxhdGU7XHJcbiAgICBjb25zdCBbbm9kZVRyYW5zZm9ybXMsIGRpcmVjdGl2ZVRyYW5zZm9ybXNdID0gZ2V0QmFzZVRyYW5zZm9ybVByZXNldCgpO1xyXG4gICAgdHJhbnNmb3JtKGFzdCwgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAgICAgLi4ubm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdKSAvLyB1c2VyIHRyYW5zZm9ybXNcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgZGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9IC8vIHVzZXIgdHJhbnNmb3Jtc1xyXG4gICAgICAgIClcclxuICAgIH0pKTtcclxuICAgIHJldHVybiBnZW5lcmF0ZShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzXHJcbiAgICB9KSk7XHJcbn1cblxuY29uc3Qgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSA9ICgpID0+ICh7IHByb3BzOiBbXSB9KTtcblxuZXhwb3J0IHsgQkFTRV9UUkFOU0lUSU9OLCBDQU1FTElaRSwgQ0FQSVRBTElaRSwgQ1JFQVRFX0JMT0NLLCBDUkVBVEVfQ09NTUVOVCwgQ1JFQVRFX1NMT1RTLCBDUkVBVEVfU1RBVElDLCBDUkVBVEVfVEVYVCwgQ1JFQVRFX1ZOT0RFLCBGUkFHTUVOVCwgSVNfUkVGLCBLRUVQX0FMSVZFLCBNRVJHRV9QUk9QUywgT1BFTl9CTE9DSywgUE9QX1NDT1BFX0lELCBQVVNIX1NDT1BFX0lELCBSRU5ERVJfTElTVCwgUkVOREVSX1NMT1QsIFJFU09MVkVfQ09NUE9ORU5ULCBSRVNPTFZFX0RJUkVDVElWRSwgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCwgUkVTT0xWRV9GSUxURVIsIFNFVF9CTE9DS19UUkFDS0lORywgU1VTUEVOU0UsIFRFTEVQT1JULCBUT19ESVNQTEFZX1NUUklORywgVE9fSEFORExFUlMsIFRPX0hBTkRMRVJfS0VZLCBVTlJFRiwgV0lUSF9DVFgsIFdJVEhfRElSRUNUSVZFUywgV0lUSF9TQ09QRV9JRCwgYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lLCBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24sIGFzc2VydCwgYmFzZUNvbXBpbGUsIGJhc2VQYXJzZSwgYnVpbGRQcm9wcywgYnVpbGRTbG90cywgY2hlY2tDb21wYXRFbmFibGVkLCBjcmVhdGVBcnJheUV4cHJlc3Npb24sIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uLCBjcmVhdGVCbG9ja1N0YXRlbWVudCwgY3JlYXRlQ2FjaGVFeHByZXNzaW9uLCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24sIGNyZWF0ZUZvckxvb3BQYXJhbXMsIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiwgY3JlYXRlSWZTdGF0ZW1lbnQsIGNyZWF0ZUludGVycG9sYXRpb24sIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24sIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQsIGNyZWF0ZVJvb3QsIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbiwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSwgY3JlYXRlVGVtcGxhdGVMaXRlcmFsLCBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0LCBjcmVhdGVWTm9kZUNhbGwsIGZpbmREaXIsIGZpbmRQcm9wLCBnZW5lcmF0ZSwgZ2V0QmFzZVRyYW5zZm9ybVByZXNldCwgZ2V0SW5uZXJSYW5nZSwgaGFzRHluYW1pY0tleVZCaW5kLCBoYXNTY29wZVJlZiwgaGVscGVyTmFtZU1hcCwgaW5qZWN0UHJvcCwgaXNCaW5kS2V5LCBpc0J1aWx0SW5UeXBlLCBpc0NvcmVDb21wb25lbnQsIGlzTWVtYmVyRXhwcmVzc2lvbiwgaXNTaW1wbGVJZGVudGlmaWVyLCBpc1Nsb3RPdXRsZXQsIGlzU3RhdGljRXhwLCBpc1RlbXBsYXRlTm9kZSwgaXNUZXh0LCBpc1ZTbG90LCBsb2NTdHViLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBwcm9jZXNzRXhwcmVzc2lvbiwgcHJvY2Vzc0ZvciwgcHJvY2Vzc0lmLCBwcm9jZXNzU2xvdE91dGxldCwgcmVnaXN0ZXJSdW50aW1lSGVscGVycywgcmVzb2x2ZUNvbXBvbmVudFR5cGUsIHRvVmFsaWRBc3NldElkLCB0cmFja1Nsb3RTY29wZXMsIHRyYWNrVkZvclNsb3RTY29wZXMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtQmluZCwgdHJhbnNmb3JtRWxlbWVudCwgdHJhbnNmb3JtRXhwcmVzc2lvbiwgdHJhbnNmb3JtTW9kZWwsIHRyYW5zZm9ybU9uLCB0cmF2ZXJzZU5vZGUsIHdhcm5EZXByZWNhdGlvbiB9O1xuIiwiaW1wb3J0IHsgcmVnaXN0ZXJSdW50aW1lSGVscGVycywgaXNCdWlsdEluVHlwZSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlT2JqZWN0UHJvcGVydHksIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBUT19ESVNQTEFZX1NUUklORywgdHJhbnNmb3JtTW9kZWwgYXMgdHJhbnNmb3JtTW9kZWwkMSwgZmluZFByb3AsIGhhc0R5bmFtaWNLZXlWQmluZCwgdHJhbnNmb3JtT24gYXMgdHJhbnNmb3JtT24kMSwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBpc1N0YXRpY0V4cCwgY2hlY2tDb21wYXRFbmFibGVkLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5pbXBvcnQgeyBpc1ZvaWRUYWcsIGlzSFRNTFRhZywgaXNTVkdUYWcsIG1ha2VNYXAsIHBhcnNlU3RyaW5nU3R5bGUsIGNhcGl0YWxpemUsIGV4dGVuZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3QgVl9NT0RFTF9SQURJTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsUmFkaW9gIDogYGApO1xyXG5jb25zdCBWX01PREVMX0NIRUNLQk9YID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxDaGVja2JveGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfVEVYVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsVGV4dGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfU0VMRUNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxTZWxlY3RgIDogYGApO1xyXG5jb25zdCBWX01PREVMX0RZTkFNSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbER5bmFtaWNgIDogYGApO1xyXG5jb25zdCBWX09OX1dJVEhfTU9ESUZJRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25Nb2RpZmllcnNHdWFyZGAgOiBgYCk7XHJcbmNvbnN0IFZfT05fV0lUSF9LRVlTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25LZXlzR3VhcmRgIDogYGApO1xyXG5jb25zdCBWX1NIT1cgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZTaG93YCA6IGBgKTtcclxuY29uc3QgVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT05fR1JPVVAgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25Hcm91cGAgOiBgYCk7XHJcbnJlZ2lzdGVyUnVudGltZUhlbHBlcnMoe1xyXG4gICAgW1ZfTU9ERUxfUkFESU9dOiBgdk1vZGVsUmFkaW9gLFxyXG4gICAgW1ZfTU9ERUxfQ0hFQ0tCT1hdOiBgdk1vZGVsQ2hlY2tib3hgLFxyXG4gICAgW1ZfTU9ERUxfVEVYVF06IGB2TW9kZWxUZXh0YCxcclxuICAgIFtWX01PREVMX1NFTEVDVF06IGB2TW9kZWxTZWxlY3RgLFxyXG4gICAgW1ZfTU9ERUxfRFlOQU1JQ106IGB2TW9kZWxEeW5hbWljYCxcclxuICAgIFtWX09OX1dJVEhfTU9ESUZJRVJTXTogYHdpdGhNb2RpZmllcnNgLFxyXG4gICAgW1ZfT05fV0lUSF9LRVlTXTogYHdpdGhLZXlzYCxcclxuICAgIFtWX1NIT1ddOiBgdlNob3dgLFxyXG4gICAgW1RSQU5TSVRJT05dOiBgVHJhbnNpdGlvbmAsXHJcbiAgICBbVFJBTlNJVElPTl9HUk9VUF06IGBUcmFuc2l0aW9uR3JvdXBgXHJcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGRlY29kZXI7XHJcbmZ1bmN0aW9uIGRlY29kZUh0bWxCcm93c2VyKHJhdywgYXNBdHRyID0gZmFsc2UpIHtcclxuICAgIGlmICghZGVjb2Rlcikge1xyXG4gICAgICAgIGRlY29kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIH1cclxuICAgIGlmIChhc0F0dHIpIHtcclxuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IGA8ZGl2IGZvbz1cIiR7cmF3LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKX1cIj5gO1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVyLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgnZm9vJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IHJhdztcclxuICAgICAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcclxuICAgIH1cclxufVxuXG5jb25zdCBpc1Jhd1RleHRDb250YWluZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3N0eWxlLGlmcmFtZSxzY3JpcHQsbm9zY3JpcHQnLCB0cnVlKTtcclxuY29uc3QgcGFyc2VyT3B0aW9ucyA9IHtcclxuICAgIGlzVm9pZFRhZyxcclxuICAgIGlzTmF0aXZlVGFnOiB0YWcgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgIGlzUHJlVGFnOiB0YWcgPT4gdGFnID09PSAncHJlJyxcclxuICAgIGRlY29kZUVudGl0aWVzOiBkZWNvZGVIdG1sQnJvd3NlciAsXHJcbiAgICBpc0J1aWx0SW5Db21wb25lbnQ6ICh0YWcpID0+IHtcclxuICAgICAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsIGBUcmFuc2l0aW9uYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT047XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbkdyb3VwYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT05fR1JPVVA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0cmVlLWNvbnN0cnVjdGlvbi1kaXNwYXRjaGVyXHJcbiAgICBnZXROYW1lc3BhY2UodGFnLCBwYXJlbnQpIHtcclxuICAgICAgICBsZXQgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiBucyA9PT0gMiAvKiBNQVRIX01MICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQudGFnID09PSAnYW5ub3RhdGlvbi14bWwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNWRyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucHJvcHMuc29tZShhID0+IGEudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICBhLm5hbWUgPT09ICdlbmNvZGluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBhLnZhbHVlICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICAoYS52YWx1ZS5jb250ZW50ID09PSAndGV4dC9odG1sJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnZhbHVlLmNvbnRlbnQgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgvXm0oPzpbaW9uc118dGV4dCkkLy50ZXN0KHBhcmVudC50YWcpICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtZ2x5cGgnICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtYWxpZ25tYXJrJykge1xyXG4gICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICYmIG5zID09PSAxIC8qIFNWRyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAnZGVzYycgfHxcclxuICAgICAgICAgICAgICAgIHBhcmVudC50YWcgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChucyA9PT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTVkcgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBNQVRIX01MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBucztcclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1odG1sLWZyYWdtZW50c1xyXG4gICAgZ2V0VGV4dE1vZGUoeyB0YWcsIG5zIH0pIHtcclxuICAgICAgICBpZiAobnMgPT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICBpZiAodGFnID09PSAndGV4dGFyZWEnIHx8IHRhZyA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogUkNEQVRBICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Jhd1RleHRDb250YWluZXIodGFnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogUkFXVEVYVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMCAvKiBEQVRBICovO1xyXG4gICAgfVxyXG59O1xuXG4vLyBQYXJzZSBpbmxpbmUgQ1NTIHN0cmluZ3MgZm9yIHN0YXRpYyBzdHlsZSBhdHRyaWJ1dGVzIGludG8gYW4gb2JqZWN0LlxyXG4vLyBUaGlzIGlzIGEgTm9kZVRyYW5zZm9ybSBzaW5jZSBpdCB3b3JrcyBvbiB0aGUgc3RhdGljIGBzdHlsZWAgYXR0cmlidXRlIGFuZFxyXG4vLyBjb252ZXJ0cyBpdCBpbnRvIGEgZHluYW1pYyBlcXVpdmFsZW50OlxyXG4vLyBzdHlsZT1cImNvbG9yOiByZWRcIiAtPiA6c3R5bGU9J3sgXCJjb2xvclwiOiBcInJlZFwiIH0nXHJcbi8vIEl0IGlzIHRoZW4gcHJvY2Vzc2VkIGJ5IGB0cmFuc2Zvcm1FbGVtZW50YCBhbmQgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZFxyXG4vLyBwcm9wcy5cclxuY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBub2RlID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdzdHlsZScgJiYgcC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwIHdpdGggYW4gZXhwcmVzc2lvbiBub2RlXHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BzW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBiaW5kYCxcclxuICAgICAgICAgICAgICAgICAgICBhcmc6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHN0eWxlYCwgdHJ1ZSwgcC5sb2MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cDogcGFyc2VJbmxpbmVDU1MocC52YWx1ZS5jb250ZW50LCBwLmxvYyksXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBsb2M6IHAubG9jXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCk7XHJcbiAgICByZXR1cm4gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihKU09OLnN0cmluZ2lmeShub3JtYWxpemVkKSwgZmFsc2UsIGxvYywgMyAvKiBDQU5fU1RSSU5HSUZZICovKTtcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MpIHtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlID8gRE9NRXJyb3JNZXNzYWdlcyA6IHVuZGVmaW5lZCk7XHJcbn1cclxuY29uc3QgRE9NRXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIFs0OSAvKiBYX1ZfSFRNTF9OT19FWFBSRVNTSU9OICovXTogYHYtaHRtbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MCAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovXTogYHYtaHRtbCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1MSAvKiBYX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovXTogYHYtdGV4dCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MiAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovXTogYHYtdGV4dCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1MyAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2FuIG9ubHkgYmUgdXNlZCBvbiA8aW5wdXQ+LCA8dGV4dGFyZWE+IGFuZCA8c2VsZWN0PiBlbGVtZW50cy5gLFxyXG4gICAgWzU0IC8qIFhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVCAqL106IGB2LW1vZGVsIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gcGxhaW4gZWxlbWVudHMuYCxcclxuICAgIFs1NSAvKiBYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gZmlsZSBpbnB1dHMgc2luY2UgdGhleSBhcmUgcmVhZC1vbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXHJcbiAgICBbNTYgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovXTogYFVubmVjZXNzYXJ5IHZhbHVlIGJpbmRpbmcgdXNlZCBhbG9uZ3NpZGUgdi1tb2RlbC4gSXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB2LW1vZGVsJ3MgYmVoYXZpb3IuYCxcclxuICAgIFs1NyAvKiBYX1ZfU0hPV19OT19FWFBSRVNTSU9OICovXTogYHYtc2hvdyBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1OCAvKiBYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqL106IGA8VHJhbnNpdGlvbj4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50IG9yIGNvbXBvbmVudC5gLFxyXG4gICAgWzU5IC8qIFhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi9dOiBgVGFncyB3aXRoIHNpZGUgZWZmZWN0ICg8c2NyaXB0PiBhbmQgPHN0eWxlPikgYXJlIGlnbm9yZWQgaW4gY2xpZW50IGNvbXBvbmVudCB0ZW1wbGF0ZXMuYFxyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WSHRtbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNDkgLyogWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MCAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGlubmVySFRNTGAsIHRydWUsIGxvYyksIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WVGV4dCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTEgLyogWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MiAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRleHRDb250ZW50YCwgdHJ1ZSksIGV4cFxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlclN0cmluZyhUT19ESVNQTEFZX1NUUklORyksIFtleHBdLCBsb2MpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUpKVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybU1vZGVsID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgYmFzZVJlc3VsdCA9IHRyYW5zZm9ybU1vZGVsJDEoZGlyLCBub2RlLCBjb250ZXh0KTtcclxuICAgIC8vIGJhc2UgdHJhbnNmb3JtIGhhcyBlcnJvcnMgT1IgY29tcG9uZW50IHYtbW9kZWwgKG9ubHkgbmVlZCBwcm9wcylcclxuICAgIGlmICghYmFzZVJlc3VsdC5wcm9wcy5sZW5ndGggfHwgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaWYgKGRpci5hcmcpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NCAvKiBYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi8sIGRpci5hcmcubG9jKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGZpbmRQcm9wKG5vZGUsICd2YWx1ZScpO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NiAvKiBYX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUUgKi8sIHZhbHVlLmxvYykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgdGFnIH0gPSBub2RlO1xyXG4gICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gY29udGV4dC5pc0N1c3RvbUVsZW1lbnQodGFnKTtcclxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHxcclxuICAgICAgICB0YWcgPT09ICd0ZXh0YXJlYScgfHxcclxuICAgICAgICB0YWcgPT09ICdzZWxlY3QnIHx8XHJcbiAgICAgICAgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9URVhUO1xyXG4gICAgICAgIGxldCBpc0ludmFsaWRUeXBlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGZpbmRQcm9wKG5vZGUsIGB0eXBlYCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZS50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDp0eXBlPVwiZm9vXCJcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUudmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfUkFESU87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0NIRUNLQk9YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkVHlwZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NSAvKiBYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRleHQgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGhhcyBiaW5kaW5ncyB3aXRoIGR5bmFtaWMga2V5cywgd2hpY2ggY2FuIHBvc3NpYmx5IGNvbnRhaW5cclxuICAgICAgICAgICAgICAgIC8vIFwidHlwZVwiLlxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1NFTEVDVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRleHRhcmVhXHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcnVudGltZSBkaXJlY3RpdmVcclxuICAgICAgICAvLyBieSByZXR1cm5pbmcgdGhlIGhlbHBlciBzeW1ib2wgdmlhIG5lZWRSdW50aW1lXHJcbiAgICAgICAgLy8gdGhlIGltcG9ydCB3aWxsIHJlcGxhY2VkIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxyXG4gICAgICAgIGlmICghaXNJbnZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICBiYXNlUmVzdWx0Lm5lZWRSdW50aW1lID0gY29udGV4dC5oZWxwZXIoZGlyZWN0aXZlVG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUzIC8qIFhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlQgKi8sIGRpci5sb2MpKTtcclxuICAgIH1cclxuICAgIC8vIG5hdGl2ZSB2bW9kZWwgZG9lc24ndCBuZWVkIHRoZSBgbW9kZWxWYWx1ZWAgcHJvcHMgc2luY2UgdGhleSBhcmUgYWxzb1xyXG4gICAgLy8gcGFzc2VkIHRvIHRoZSBydW50aW1lIGFzIGBiaW5kaW5nLnZhbHVlYC4gcmVtb3ZpbmcgaXQgcmVkdWNlcyBjb2RlIHNpemUuXHJcbiAgICBiYXNlUmVzdWx0LnByb3BzID0gYmFzZVJlc3VsdC5wcm9wcy5maWx0ZXIocCA9PiAhKHAua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICBwLmtleS5jb250ZW50ID09PSAnbW9kZWxWYWx1ZScpKTtcclxuICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG59O1xuXG5jb25zdCBpc0V2ZW50T3B0aW9uTW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHBhc3NpdmUsb25jZSxjYXB0dXJlYCk7XHJcbmNvbnN0IGlzTm9uS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIGV2ZW50IHByb3BhZ2F0aW9uIG1hbmFnZW1lbnRcclxuYHN0b3AscHJldmVudCxzZWxmLGAgK1xyXG4gICAgLy8gc3lzdGVtIG1vZGlmaWVycyArIGV4YWN0XHJcbiAgICBgY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCxgICtcclxuICAgIC8vIG1vdXNlXHJcbiAgICBgbWlkZGxlYCk7XHJcbi8vIGxlZnQgJiByaWdodCBjb3VsZCBiZSBtb3VzZSBvciBrZXkgbW9kaWZpZXJzIGJhc2VkIG9uIGV2ZW50IHR5cGVcclxuY29uc3QgbWF5YmVLZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnbGVmdCxyaWdodCcpO1xyXG5jb25zdCBpc0tleWJvYXJkRXZlbnQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYG9ua2V5dXAsb25rZXlkb3duLG9ua2V5cHJlc3NgLCB0cnVlKTtcclxuY29uc3QgcmVzb2x2ZU1vZGlmaWVycyA9IChrZXksIG1vZGlmaWVycywgY29udGV4dCwgbG9jKSA9PiB7XHJcbiAgICBjb25zdCBrZXlNb2RpZmllcnMgPSBbXTtcclxuICAgIGNvbnN0IG5vbktleU1vZGlmaWVycyA9IFtdO1xyXG4gICAgY29uc3QgZXZlbnRPcHRpb25Nb2RpZmllcnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBtb2RpZmllcnNbaV07XHJcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnbmF0aXZlJyAmJlxyXG4gICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENPTVBJTEVSX1ZfT05fTkFUSVZFICovLCBjb250ZXh0LCBsb2MpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0V2ZW50T3B0aW9uTW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgIC8vIGV2ZW50T3B0aW9uTW9kaWZpZXJzOiBtb2RpZmllcnMgZm9yIGFkZEV2ZW50TGlzdGVuZXIoKSBvcHRpb25zLFxyXG4gICAgICAgICAgICAvLyBlLmcuIC5wYXNzaXZlICYgLmNhcHR1cmVcclxuICAgICAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBydW50aW1lTW9kaWZpZXJzOiBtb2RpZmllcnMgdGhhdCBuZWVkcyBydW50aW1lIGd1YXJkc1xyXG4gICAgICAgICAgICBpZiAobWF5YmVLZXlNb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25LZXlNb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleU1vZGlmaWVycyxcclxuICAgICAgICBub25LZXlNb2RpZmllcnMsXHJcbiAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnNcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IHRyYW5zZm9ybUNsaWNrID0gKGtleSwgZXZlbnQpID0+IHtcclxuICAgIGNvbnN0IGlzU3RhdGljQ2xpY2sgPSBpc1N0YXRpY0V4cChrZXkpICYmIGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkgPT09ICdvbmNsaWNrJztcclxuICAgIHJldHVybiBpc1N0YXRpY0NsaWNrXHJcbiAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV2ZW50LCB0cnVlKVxyXG4gICAgICAgIDoga2V5LnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi9cclxuICAgICAgICAgICAgPyBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYChgLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgYCkgPT09IFwib25DbGlja1wiID8gXCIke2V2ZW50fVwiIDogKGAsXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBgKWBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgOiBrZXk7XHJcbn07XHJcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybU9uJDEoZGlyLCBub2RlLCBjb250ZXh0LCBiYXNlUmVzdWx0ID0+IHtcclxuICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0gZGlyO1xyXG4gICAgICAgIGlmICghbW9kaWZpZXJzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGJhc2VSZXN1bHQ7XHJcbiAgICAgICAgbGV0IHsga2V5LCB2YWx1ZTogaGFuZGxlckV4cCB9ID0gYmFzZVJlc3VsdC5wcm9wc1swXTtcclxuICAgICAgICBjb25zdCB7IGtleU1vZGlmaWVycywgbm9uS2V5TW9kaWZpZXJzLCBldmVudE9wdGlvbk1vZGlmaWVycyB9ID0gcmVzb2x2ZU1vZGlmaWVycyhrZXksIG1vZGlmaWVycywgY29udGV4dCwgZGlyLmxvYyk7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5pbmNsdWRlcygncmlnaHQnKSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbkNvbnRleHRtZW51YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ21pZGRsZScpKSB7XHJcbiAgICAgICAgICAgIGtleSA9IHRyYW5zZm9ybUNsaWNrKGtleSwgYG9uTW91c2V1cGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX01PRElGSUVSUyksIFtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShub25LZXlNb2RpZmllcnMpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBpZiBldmVudCBuYW1lIGlzIGR5bmFtaWMsIGFsd2F5cyB3cmFwIHdpdGgga2V5cyBndWFyZFxyXG4gICAgICAgICAgICAoIWlzU3RhdGljRXhwKGtleSkgfHwgaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50KSkpIHtcclxuICAgICAgICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9LRVlTKSwgW1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlckV4cCxcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGtleU1vZGlmaWVycylcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudE9wdGlvbk1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJQb3N0Zml4ID0gZXZlbnRPcHRpb25Nb2RpZmllcnMubWFwKGNhcGl0YWxpemUpLmpvaW4oJycpO1xyXG4gICAgICAgICAgICBrZXkgPSBpc1N0YXRpY0V4cChrZXkpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5LmNvbnRlbnR9JHttb2RpZmllclBvc3RmaXh9YCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgKGAsIGtleSwgYCkgKyBcIiR7bW9kaWZpZXJQb3N0Zml4fVwiYF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgaGFuZGxlckV4cCldXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1TaG93ID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xyXG4gICAgaWYgKCFleHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NyAvKiBYX1ZfU0hPV19OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtdLFxyXG4gICAgICAgIG5lZWRSdW50aW1lOiBjb250ZXh0LmhlbHBlcihWX1NIT1cpXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB3YXJuVHJhbnNpdGlvbkNoaWxkcmVuID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudChub2RlLnRhZyk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gVFJBTlNJVElPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1OCAvKiBYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5jaGlsZHJlblswXS5sb2Muc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpIHtcclxuICAgIC8vICMxMzUyIGZpbHRlciBvdXQgcG90ZW50aWFsIGNvbW1lbnQgbm9kZXMuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IChub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5maWx0ZXIoYyA9PiBjLnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykpO1xyXG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8XHJcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovIHx8XHJcbiAgICAgICAgKGNoaWxkLnR5cGUgPT09IDkgLyogSUYgKi8gJiYgY2hpbGQuYnJhbmNoZXMuc29tZShoYXNNdWx0aXBsZUNoaWxkcmVuKSkpO1xyXG59XG5cbmNvbnN0IGlnbm9yZVNpZGVFZmZlY3RUYWdzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgKG5vZGUudGFnID09PSAnc2NyaXB0JyB8fCBub2RlLnRhZyA9PT0gJ3N0eWxlJykpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1OSAvKiBYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovLCBub2RlLmxvYykpO1xyXG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCBET01Ob2RlVHJhbnNmb3JtcyA9IFtcclxuICAgIHRyYW5zZm9ybVN0eWxlLFxyXG4gICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IFt3YXJuVHJhbnNpdGlvbkNoaWxkcmVuXSA6IFtdKVxyXG5dO1xyXG5jb25zdCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zID0ge1xyXG4gICAgY2xvYWs6IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sXHJcbiAgICBodG1sOiB0cmFuc2Zvcm1WSHRtbCxcclxuICAgIHRleHQ6IHRyYW5zZm9ybVZUZXh0LFxyXG4gICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsLFxyXG4gICAgb246IHRyYW5zZm9ybU9uLFxyXG4gICAgc2hvdzogdHJhbnNmb3JtU2hvd1xyXG59O1xyXG5mdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAgICAgLy8gaWdub3JlIDxzY3JpcHQ+IGFuZCA8dGFnPlxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBwdXQgaW5zaWRlIERPTU5vZGVUcmFuc2Zvcm1zIGJlY2F1c2UgdGhhdCBsaXN0IGlzIHVzZWRcclxuICAgICAgICAgICAgLy8gYnkgY29tcGlsZXItc3NyIHRvIGdlbmVyYXRlIHZub2RlIGZhbGxiYWNrIGJyYW5jaGVzXHJcbiAgICAgICAgICAgIGlnbm9yZVNpZGVFZmZlY3RUYWdzLFxyXG4gICAgICAgICAgICAuLi5ET01Ob2RlVHJhbnNmb3JtcyxcclxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW10pXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoe30sIERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fSksXHJcbiAgICAgICAgdHJhbnNmb3JtSG9pc3Q6IG51bGwgXHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIGJhc2VQYXJzZSh0ZW1wbGF0ZSwgZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zKSk7XHJcbn1cblxuZXhwb3J0IHsgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcywgRE9NTm9kZVRyYW5zZm9ybXMsIFRSQU5TSVRJT04sIFRSQU5TSVRJT05fR1JPVVAsIFZfTU9ERUxfQ0hFQ0tCT1gsIFZfTU9ERUxfRFlOQU1JQywgVl9NT0RFTF9SQURJTywgVl9NT0RFTF9TRUxFQ1QsIFZfTU9ERUxfVEVYVCwgVl9PTl9XSVRIX0tFWVMsIFZfT05fV0lUSF9NT0RJRklFUlMsIFZfU0hPVywgY29tcGlsZSwgY3JlYXRlRE9NQ29tcGlsZXJFcnJvciwgcGFyc2UsIHBhcnNlck9wdGlvbnMsIHRyYW5zZm9ybVN0eWxlIH07XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkosIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBleHRlbmQsIGhhc093biwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBlZmZlY3RTdGFjayA9IFtdO1xyXG5sZXQgYWN0aXZlRWZmZWN0O1xyXG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnaXRlcmF0ZScgOiAnJyk7XHJcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ01hcCBrZXkgaXRlcmF0ZScgOiAnJyk7XHJcbmZ1bmN0aW9uIGlzRWZmZWN0KGZuKSB7XHJcbiAgICByZXR1cm4gZm4gJiYgZm4uX2lzRWZmZWN0ID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xyXG4gICAgaWYgKGlzRWZmZWN0KGZuKSkge1xyXG4gICAgICAgIGZuID0gZm4ucmF3O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0ID0gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpO1xyXG4gICAgaWYgKCFvcHRpb25zLmxhenkpIHtcclxuICAgICAgICBlZmZlY3QoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlZmZlY3Q7XHJcbn1cclxuZnVuY3Rpb24gc3RvcChlZmZlY3QpIHtcclxuICAgIGlmIChlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgY2xlYW51cChlZmZlY3QpO1xyXG4gICAgICAgIGlmIChlZmZlY3Qub3B0aW9ucy5vblN0b3ApIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMub25TdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVmZmVjdC5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGVmZmVjdCA9IGZ1bmN0aW9uIHJlYWN0aXZlRWZmZWN0KCkge1xyXG4gICAgICAgIGlmICghZWZmZWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlZmZlY3RTdGFjay5pbmNsdWRlcyhlZmZlY3QpKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXAoZWZmZWN0KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RTdGFjay5wdXNoKGVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdFN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0U3RhY2tbZWZmZWN0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZWZmZWN0LmlkID0gdWlkKys7XHJcbiAgICBlZmZlY3QuYWxsb3dSZWN1cnNlID0gISFvcHRpb25zLmFsbG93UmVjdXJzZTtcclxuICAgIGVmZmVjdC5faXNFZmZlY3QgPSB0cnVlO1xyXG4gICAgZWZmZWN0LmFjdGl2ZSA9IHRydWU7XHJcbiAgICBlZmZlY3QucmF3ID0gZm47XHJcbiAgICBlZmZlY3QuZGVwcyA9IFtdO1xyXG4gICAgZWZmZWN0Lm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgcmV0dXJuIGVmZmVjdDtcclxufVxyXG5mdW5jdGlvbiBjbGVhbnVwKGVmZmVjdCkge1xyXG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG59XHJcbmxldCBzaG91bGRUcmFjayA9IHRydWU7XHJcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xyXG4gICAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XHJcbiAgICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBsYXN0O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XHJcbiAgICBpZiAoIXNob3VsZFRyYWNrIHx8IGFjdGl2ZUVmZmVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgKGRlcHNNYXAgPSBuZXcgTWFwKCkpKTtcclxuICAgIH1cclxuICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xyXG4gICAgaWYgKCFkZXApIHtcclxuICAgICAgICBkZXBzTWFwLnNldChrZXksIChkZXAgPSBuZXcgU2V0KCkpKTtcclxuICAgIH1cclxuICAgIGlmICghZGVwLmhhcyhhY3RpdmVFZmZlY3QpKSB7XHJcbiAgICAgICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2spIHtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjayh7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCxcclxuICAgICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBrZXlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XHJcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgLy8gbmV2ZXIgYmVlbiB0cmFja2VkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0cyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IGFkZCA9IChlZmZlY3RzVG9BZGQpID0+IHtcclxuICAgICAgICBpZiAoZWZmZWN0c1RvQWRkKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdHNUb0FkZC5mb3JFYWNoKGVmZmVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0ICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0LmFsbG93UmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHMuYWRkKGVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAodHlwZSA9PT0gXCJjbGVhclwiIC8qIENMRUFSICovKSB7XHJcbiAgICAgICAgLy8gY29sbGVjdGlvbiBiZWluZyBjbGVhcmVkXHJcbiAgICAgICAgLy8gdHJpZ2dlciBhbGwgZWZmZWN0cyBmb3IgdGFyZ2V0XHJcbiAgICAgICAgZGVwc01hcC5mb3JFYWNoKGFkZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcgfHwga2V5ID49IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGQoZGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2NoZWR1bGUgcnVucyBmb3IgU0VUIHwgQUREIHwgREVMRVRFXHJcbiAgICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWxzbyBydW4gZm9yIGl0ZXJhdGlvbiBrZXkgb24gQUREIHwgREVMRVRFIHwgTWFwLlNFVFxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkXCIgLyogQUREICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGluZGV4IGFkZGVkIHRvIGFycmF5IC0+IGxlbmd0aCBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KCdsZW5ndGgnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNldFwiIC8qIFNFVCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW4gPSAoZWZmZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlZmZlY3Qub3B0aW9ucy5vblRyaWdnZXIpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMub25UcmlnZ2VyKHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdCxcclxuICAgICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkVGFyZ2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0Lm9wdGlvbnMuc2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vcHRpb25zLnNjaGVkdWxlcihlZmZlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWZmZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGVmZmVjdHMuZm9yRWFjaChydW4pO1xyXG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XHJcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpXHJcbiAgICAubWFwKGtleSA9PiBTeW1ib2xba2V5XSlcclxuICAgIC5maWx0ZXIoaXNTeW1ib2wpKTtcclxuY29uc3QgZ2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd0dldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcclxuY29uc3QgcmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XHJcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xyXG5bJ2luY2x1ZGVzJywgJ2luZGV4T2YnLCAnbGFzdEluZGV4T2YnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBjb25zdCBtZXRob2QgPSBBcnJheS5wcm90b3R5cGVba2V5XTtcclxuICAgIGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiAvKiBHRVQgKi8sIGkgKyAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdlIHJ1biB0aGUgbWV0aG9kIHVzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGZpcnN0ICh3aGljaCBtYXkgYmUgcmVhY3RpdmUpXHJcbiAgICAgICAgY29uc3QgcmVzID0gbWV0aG9kLmFwcGx5KGFyciwgYXJncyk7XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGF0IGRpZG4ndCB3b3JrLCBydW4gaXQgYWdhaW4gdXNpbmcgcmF3IHZhbHVlcy5cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShhcnIsIGFyZ3MubWFwKHRvUmF3KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pO1xyXG5bJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XHJcbiAgICBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn0pO1xyXG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXIoaXNSZWFkb25seSA9IGZhbHNlLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovICYmXHJcbiAgICAgICAgICAgIHJlY2VpdmVyID09PVxyXG4gICAgICAgICAgICAgICAgKGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFkb25seU1hcFxyXG4gICAgICAgICAgICAgICAgICAgIDogc2hhbGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFjdGl2ZU1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICAgICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYocmVzKSkge1xyXG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIGRvZXMgbm90IGFwcGx5IGZvciBBcnJheSArIGludGVnZXIga2V5LlxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRVbndyYXAgPSAhdGFyZ2V0SXNBcnJheSB8fCAhaXNJbnRlZ2VyS2V5KGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRVbndyYXAgPyByZXMudmFsdWUgOiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgaW50byBhIHByb3h5IGFzIHdlbGwuIHdlIGRvIHRoZSBpc09iamVjdCBjaGVja1xyXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGF2b2lkIGludmFsaWQgdmFsdWUgd2FybmluZy4gQWxzbyBuZWVkIHRvIGxhenkgYWNjZXNzIHJlYWRvbmx5XHJcbiAgICAgICAgICAgIC8vIGFuZCByZWFjdGl2ZSBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IHNldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcih0cnVlKTtcclxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKCFzaGFsbG93KSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSlcclxuICAgICAgICAgICAgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGhcclxuICAgICAgICAgICAgOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIC8vIGRvbid0IHRyaWdnZXIgaWYgdGFyZ2V0IGlzIHNvbWV0aGluZyB1cCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIG9yaWdpbmFsXHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcclxuICAgIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNBcnJheSh0YXJnZXQpID8gJ2xlbmd0aCcgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbn1cclxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0LFxyXG4gICAgc2V0LFxyXG4gICAgZGVsZXRlUHJvcGVydHksXHJcbiAgICBoYXMsXHJcbiAgICBvd25LZXlzXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IHJlYWRvbmx5R2V0LFxyXG4gICAgc2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd0dldCxcclxuICAgIHNldDogc2hhbGxvd1NldFxyXG59KTtcclxuLy8gUHJvcHMgaGFuZGxlcnMgYXJlIHNwZWNpYWwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgc2hvdWxkIG5vdCB1bndyYXAgdG9wLWxldmVsXHJcbi8vIHJlZnMgKGluIG9yZGVyIHRvIGFsbG93IHJlZnMgdG8gYmUgZXhwbGljaXRseSBwYXNzZWQgZG93biksIGJ1dCBzaG91bGRcclxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IGV4dGVuZCh7fSwgcmVhZG9ubHlIYW5kbGVycywge1xyXG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcclxufSk7XG5cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xyXG5jb25zdCB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcclxuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcclxuZnVuY3Rpb24gZ2V0JDEodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIC8vICMxNzcyOiByZWFkb25seShyZWFjdGl2ZShNYXApKSBzaG91bGQgcmV0dXJuIHJlYWRvbmx5ICsgcmVhY3RpdmUgdmVyc2lvblxyXG4gICAgLy8gb2YgdGhlIHZhbHVlXHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgIH1cclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIHJhd0tleSk7XHJcbiAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcclxuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xyXG4gICAgICAgIC8vICMzNjAyIHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpXHJcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG5lc3RlZCByZWFjdGl2ZSBgTWFwYCBjYW4gZG8gdHJhY2tpbmcgZm9yIGl0c2VsZlxyXG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywgcmF3S2V5KTtcclxuICAgIHJldHVybiBrZXkgPT09IHJhd0tleVxyXG4gICAgICAgID8gdGFyZ2V0LmhhcyhrZXkpXHJcbiAgICAgICAgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgJ3NpemUnLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcclxuICAgIGlmIChoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xyXG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBpc01hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgID8gbmV3IE1hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgIDogbmV3IFNldCh0YXJnZXQpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XHJcbiAgICBpZiAoaGFkSXRlbXMpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiIC8qIENMRUFSICovLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IG1ha2Ugc3VyZSB0aGUgY2FsbGJhY2sgaXNcclxuICAgICAgICAgICAgLy8gMS4gaW52b2tlZCB3aXRoIHRoZSByZWFjdGl2ZSBtYXAgYXMgYHRoaXNgIGFuZCAzcmQgYXJnXHJcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2YWx1ZSByZWNlaXZlZCBzaG91bGQgYmUgYSBjb3JyZXNwb25kaW5nIHJlYWN0aXZlL3JlYWRvbmx5LlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XHJcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcclxuICAgICAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09ICdrZXlzJyAmJiB0YXJnZXRJc01hcDtcclxuICAgICAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJlxyXG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgd3JhcHBlZCBpdGVyYXRvciB3aGljaCByZXR1cm5zIG9ic2VydmVkIHZlcnNpb25zIG9mIHRoZVxyXG4gICAgICAgIC8vIHZhbHVlcyBlbWl0dGVkIGZyb20gdGhlIHJlYWwgaXRlcmF0b3JcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZSwgZG9uZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcclxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRvUmF3KHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgLyogREVMRVRFICovID8gZmFsc2UgOiB0aGlzO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5KTtcclxuICAgIH0sXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBoYXM6IGhhcyQxLFxyXG4gICAgYWRkLFxyXG4gICAgc2V0OiBzZXQkMSxcclxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICBjbGVhcixcclxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgaGFzOiBoYXMkMSxcclxuICAgIGFkZCxcclxuICAgIHNldDogc2V0JDEsXHJcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgY2xlYXIsXHJcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxyXG59O1xyXG5jb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgaGFzKGtleSkge1xyXG4gICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIEFERCAqLyksXHJcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBERUxFVEUgKi8pLFxyXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBDTEVBUiAqLyksXHJcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGhhcyhrZXkpIHtcclxuICAgICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBBREQgKi8pLFxyXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFNFVCAqLyksXHJcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogQ0xFQVIgKi8pLFxyXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxyXG59O1xyXG5jb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnLCBTeW1ib2wuaXRlcmF0b3JdO1xyXG5pdGVyYXRvck1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xyXG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcclxuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XHJcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIHRydWUpO1xyXG59KTtcclxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcclxuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93XHJcbiAgICAgICAgPyBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgOiBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XHJcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiB0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXHJcbn07XHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIGAgK1xyXG4gICAgICAgICAgICBgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIGAgK1xyXG4gICAgICAgICAgICBgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBgICtcclxuICAgICAgICAgICAgYEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIGAgK1xyXG4gICAgICAgICAgICBgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcclxuICAgICAgICBjYXNlICdPYmplY3QnOlxyXG4gICAgICAgIGNhc2UgJ0FycmF5JzpcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xyXG4gICAgICAgIGNhc2UgJ01hcCc6XHJcbiAgICAgICAgY2FzZSAnU2V0JzpcclxuICAgICAgICBjYXNlICdXZWFrTWFwJzpcclxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcclxuICAgICAgICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpXHJcbiAgICAgICAgPyAwIC8qIElOVkFMSUQgKi9cclxuICAgICAgICA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXHJcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldFtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIGEgc2hhbGxvd2x5LXJlYWN0aXZlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdFxyXG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxyXG4gKiByb290IGxldmVsKS5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycywgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJlYWRvbmx5IGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdC4gTm90ZSB0aGUgcmV0dXJuZWQgY29weSBpcyBub3RcclxuICogbWFkZSByZWFjdGl2ZSwgYnV0IGByZWFkb25seWAgY2FuIGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHJlYWN0aXZlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxyXG4gKiBwcm9wZXJ0aWVzIGFyZSByZWFkb25seSwgYW5kIGRvZXMgTk9UIHVud3JhcCByZWZzIG5vciByZWN1cnNpdmVseSBjb252ZXJ0XHJcbiAqIHJldHVybmVkIHByb3BlcnRpZXMuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seU1hcCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5LCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcclxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cclxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XHJcbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL10gJiZcclxuICAgICAgICAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XHJcbiAgICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBhIHdoaXRlbGlzdCBvZiB2YWx1ZSB0eXBlcyBjYW4gYmUgb2JzZXJ2ZWQuXHJcbiAgICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVycyk7XHJcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUkFXICovXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xyXG4gICAgcmV0dXJuICgob2JzZXJ2ZWQgJiYgdG9SYXcob2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXSkpIHx8IG9ic2VydmVkKTtcclxufVxyXG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XHJcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBTS0lQICovLCB0cnVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxuXG5jb25zdCBjb252ZXJ0ID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSA/IHJlYWN0aXZlKHZhbCkgOiB2YWw7XHJcbmZ1bmN0aW9uIGlzUmVmKHIpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XHJcbn1cclxuY2xhc3MgUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfcmF3VmFsdWUsIF9zaGFsbG93ID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IF9yYXdWYWx1ZTtcclxuICAgICAgICB0aGlzLl9zaGFsbG93ID0gX3NoYWxsb3c7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3NoYWxsb3cgPyBfcmF3VmFsdWUgOiBjb252ZXJ0KF9yYXdWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgdHJhY2sodG9SYXcodGhpcyksIFwiZ2V0XCIgLyogR0VUICovLCAndmFsdWUnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQodG9SYXcobmV3VmFsKSwgdGhpcy5fcmF3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3NoYWxsb3cgPyBuZXdWYWwgOiBjb252ZXJ0KG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIHRyaWdnZXIodG9SYXcodGhpcyksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnLCBuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcclxuICAgIHRyaWdnZXIodG9SYXcocmVmKSwgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHJlZi52YWx1ZSA6IHZvaWQgMCk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWYocmVmKSB7XHJcbiAgICByZXR1cm4gaXNSZWYocmVmKSA/IHJlZi52YWx1ZSA6IHJlZjtcclxufVxyXG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxyXG4gICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcylcclxuICAgICAgICA/IG9iamVjdFdpdGhSZWZzXHJcbiAgICAgICAgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XHJcbn1cclxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoKCkgPT4gdHJhY2sodGhpcywgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpLCAoKSA9PiB0cmlnZ2VyKHRoaXMsIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnKSk7XHJcbiAgICAgICAgdGhpcy5fZ2V0ID0gZ2V0O1xyXG4gICAgICAgIHRoaXMuX3NldCA9IHNldDtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5KSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXkpIHtcclxuICAgIHJldHVybiBpc1JlZihvYmplY3Rba2V5XSlcclxuICAgICAgICA/IG9iamVjdFtrZXldXHJcbiAgICAgICAgOiBuZXcgT2JqZWN0UmVmSW1wbChvYmplY3QsIGtleSk7XHJcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGdldHRlciwgX3NldHRlciwgaXNSZWFkb25seSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdChnZXR0ZXIsIHtcclxuICAgICAgICAgICAgbGF6eTogdHJ1ZSxcclxuICAgICAgICAgICAgc2NoZWR1bGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIodG9SYXcodGhpcyksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSA9IGlzUmVhZG9ubHk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcclxuICAgICAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgaWYgKHNlbGYuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3ZhbHVlID0gdGhpcy5lZmZlY3QoKTtcclxuICAgICAgICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2soc2VsZiwgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpO1xyXG4gICAgICAgIHJldHVybiBzZWxmLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IHNldHRlcjtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XHJcbiAgICAgICAgc2V0dGVyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogTk9PUDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XHJcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykgfHwgIWdldHRlck9yT3B0aW9ucy5zZXQpO1xyXG59XG5cbmV4cG9ydCB7IElURVJBVEVfS0VZLCBjb21wdXRlZCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVuYWJsZVRyYWNraW5nLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgbWFya1JhdywgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiIsImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgaXNSZWFjdGl2ZSwgZWZmZWN0LCBzdG9wLCByZWYsIHJlYWN0aXZlLCBwcm94eVJlZnMsIHRvUmVmLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUHJveHksIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgY3VzdG9tUmVmLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgbWFya1JhdywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBleHRlbmQsIGhhc093biwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIHJlbW92ZSwgTk9PUCwgaGFzQ2hhbmdlZCwgaXNPYmplY3QsIGlzU2V0LCBpc01hcCwgaXNQbGFpbk9iamVjdCwgaW52b2tlQXJyYXlGbnMsIGRlZiwgaXNSZXNlcnZlZFByb3AsIEVNUFRZX0FSUiwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBtYWtlTWFwLCBOTywgZ2V0R2xvYmFsVGhpcywgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XHJcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xyXG4gICAgc3RhY2sucHVzaCh2bm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XHJcbiAgICBzdGFjay5wb3AoKTtcclxufVxyXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xyXG4gICAgLy8gYXZvaWQgcHJvcHMgZm9ybWF0dGluZyBvciB3YXJuIGhhbmRsZXIgdHJhY2tpbmcgZGVwcyB0aGF0IG1pZ2h0IGJlIG11dGF0ZWRcclxuICAgIC8vIGR1cmluZyBwYXRjaCwgbGVhZGluZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXHJcbiAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XHJcbiAgICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xyXG4gICAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xyXG4gICAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcFdhcm5IYW5kbGVyLCBpbnN0YW5jZSwgMTEgLyogQVBQX1dBUk5fSEFORExFUiAqLywgW1xyXG4gICAgICAgICAgICBtc2cgKyBhcmdzLmpvaW4oJycpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcclxuICAgICAgICAgICAgdHJhY2VcclxuICAgICAgICAgICAgICAgIC5tYXAoKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0cmFjZS5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcclxuICAgICAgICAgICAgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIHdhcm5BcmdzLnB1c2goYFxcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYWNraW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XHJcbiAgICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoIWN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIC8vIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBzdGFjayBiZWNhdXNlIGl0IHdpbGwgYmUgaW5jb21wbGV0ZSBkdXJpbmcgdXBkYXRlc1xyXG4gICAgLy8gdGhhdCBkaWQgbm90IHN0YXJ0IGZyb20gdGhlIHJvb3QuIFJlLWNvbnN0cnVjdCB0aGUgcGFyZW50IGNoYWluIHVzaW5nXHJcbiAgICAvLyBpbnN0YW5jZSBwYXJlbnQgcG9pbnRlcnMuXHJcbiAgICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcclxuICAgIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xyXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2VDb3VudDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xyXG4gICAgICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xyXG4gICAgY29uc3QgbG9ncyA9IFtdO1xyXG4gICAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcclxuICAgICAgICBsb2dzLnB1c2goLi4uKGkgPT09IDAgPyBbXSA6IFtgXFxuYF0pLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBsb2dzO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcclxuICAgIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XHJcbiAgICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcclxuICAgIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUodm5vZGUuY29tcG9uZW50LCB2bm9kZS50eXBlLCBpc1Jvb3QpfWA7XHJcbiAgICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XHJcbiAgICByZXR1cm4gdm5vZGUucHJvcHNcclxuICAgICAgICA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXVxyXG4gICAgICAgIDogW29wZW4gKyBjbG9zZV07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcclxuICAgIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XHJcbiAgICB9KTtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICByZXMucHVzaChgIC4uLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcclxuICAgICAgICB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSB7XHJcbiAgICBbXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi9dOiAnYmVmb3JlQ3JlYXRlIGhvb2snLFxyXG4gICAgW1wiY1wiIC8qIENSRUFURUQgKi9dOiAnY3JlYXRlZCBob29rJyxcclxuICAgIFtcImJtXCIgLyogQkVGT1JFX01PVU5UICovXTogJ2JlZm9yZU1vdW50IGhvb2snLFxyXG4gICAgW1wibVwiIC8qIE1PVU5URUQgKi9dOiAnbW91bnRlZCBob29rJyxcclxuICAgIFtcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqL106ICdiZWZvcmVVcGRhdGUgaG9vaycsXHJcbiAgICBbXCJ1XCIgLyogVVBEQVRFRCAqL106ICd1cGRhdGVkJyxcclxuICAgIFtcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovXTogJ2JlZm9yZVVubW91bnQgaG9vaycsXHJcbiAgICBbXCJ1bVwiIC8qIFVOTU9VTlRFRCAqL106ICd1bm1vdW50ZWQgaG9vaycsXHJcbiAgICBbXCJhXCIgLyogQUNUSVZBVEVEICovXTogJ2FjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImRhXCIgLyogREVBQ1RJVkFURUQgKi9dOiAnZGVhY3RpdmF0ZWQgaG9vaycsXHJcbiAgICBbXCJlY1wiIC8qIEVSUk9SX0NBUFRVUkVEICovXTogJ2Vycm9yQ2FwdHVyZWQgaG9vaycsXHJcbiAgICBbXCJydGNcIiAvKiBSRU5ERVJfVFJBQ0tFRCAqL106ICdyZW5kZXJUcmFja2VkIGhvb2snLFxyXG4gICAgW1wicnRnXCIgLyogUkVOREVSX1RSSUdHRVJFRCAqL106ICdyZW5kZXJUcmlnZ2VyZWQgaG9vaycsXHJcbiAgICBbMCAvKiBTRVRVUF9GVU5DVElPTiAqL106ICdzZXR1cCBmdW5jdGlvbicsXHJcbiAgICBbMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi9dOiAncmVuZGVyIGZ1bmN0aW9uJyxcclxuICAgIFsyIC8qIFdBVENIX0dFVFRFUiAqL106ICd3YXRjaGVyIGdldHRlcicsXHJcbiAgICBbMyAvKiBXQVRDSF9DQUxMQkFDSyAqL106ICd3YXRjaGVyIGNhbGxiYWNrJyxcclxuICAgIFs0IC8qIFdBVENIX0NMRUFOVVAgKi9dOiAnd2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uJyxcclxuICAgIFs1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovXTogJ25hdGl2ZSBldmVudCBoYW5kbGVyJyxcclxuICAgIFs2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovXTogJ2NvbXBvbmVudCBldmVudCBoYW5kbGVyJyxcclxuICAgIFs3IC8qIFZOT0RFX0hPT0sgKi9dOiAndm5vZGUgaG9vaycsXHJcbiAgICBbOCAvKiBESVJFQ1RJVkVfSE9PSyAqL106ICdkaXJlY3RpdmUgaG9vaycsXHJcbiAgICBbOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi9dOiAndHJhbnNpdGlvbiBob29rJyxcclxuICAgIFsxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqL106ICdhcHAgZXJyb3JIYW5kbGVyJyxcclxuICAgIFsxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovXTogJ2FwcCB3YXJuSGFuZGxlcicsXHJcbiAgICBbMTIgLyogRlVOQ1RJT05fUkVGICovXTogJ3JlZiBmdW5jdGlvbicsXHJcbiAgICBbMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqL106ICdhc3luYyBjb21wb25lbnQgbG9hZGVyJyxcclxuICAgIFsxNCAvKiBTQ0hFRFVMRVIgKi9dOiAnc2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiAnICtcclxuICAgICAgICAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9uZXctaXNzdWUudnVlanMub3JnLz9yZXBvPXZ1ZWpzL3Z1ZS1uZXh0J1xyXG59O1xyXG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXMgPSBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcclxuICAgICAgICAgICAgcmVzLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcclxuICAgIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcclxuICAgICAgICAvLyB0aGUgZXhwb3NlZCBpbnN0YW5jZSBpcyB0aGUgcmVuZGVyIHByb3h5IHRvIGtlZXAgaXQgY29uc2lzdGVudCB3aXRoIDIueFxyXG4gICAgICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xyXG4gICAgICAgIC8vIGluIHByb2R1Y3Rpb24gdGhlIGhvb2sgcmVjZWl2ZXMgb25seSB0aGUgZXJyb3IgY29kZVxyXG4gICAgICAgIGNvbnN0IGVycm9ySW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IEVycm9yVHlwZVN0cmluZ3NbdHlwZV0gOiB0eXBlO1xyXG4gICAgICAgIHdoaWxlIChjdXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwLWxldmVsIGhhbmRsaW5nXHJcbiAgICAgICAgY29uc3QgYXBwRXJyb3JIYW5kbGVyID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZXJyb3JIYW5kbGVyO1xyXG4gICAgICAgIGlmIChhcHBFcnJvckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcEVycm9ySGFuZGxlciwgbnVsbCwgMTAgLyogQVBQX0VSUk9SX0hBTkRMRVIgKi8sIFtlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldik7XHJcbn1cclxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3NbdHlwZV07XHJcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XHJcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmFzaCBpbiBkZXYgYnkgZGVmYXVsdCBzbyBpdCdzIG1vcmUgbm90aWNlYWJsZVxyXG4gICAgICAgIGlmICh0aHJvd0luRGV2KSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZWNvdmVyIGluIHByb2QgdG8gcmVkdWNlIHRoZSBpbXBhY3Qgb24gZW5kLXVzZXJcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICB9XHJcbn1cblxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcclxubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbmNvbnN0IHF1ZXVlID0gW107XHJcbmxldCBmbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1ByZUZsdXNoQ2JzID0gW107XHJcbmxldCBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbmxldCBwcmVGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxubGV0IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IG51bGw7XHJcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcclxuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcclxuICAgIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcclxuICAgIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XHJcbn1cclxuLy8gIzI3NjhcclxuLy8gVXNlIGJpbmFyeS1zZWFyY2ggdG8gZmluZCBhIHN1aXRhYmxlIHBvc2l0aW9uIGluIHRoZSBxdWV1ZSxcclxuLy8gc28gdGhhdCB0aGUgcXVldWUgbWFpbnRhaW5zIHRoZSBpbmNyZWFzaW5nIG9yZGVyIG9mIGpvYidzIGlkLFxyXG4vLyB3aGljaCBjYW4gcHJldmVudCB0aGUgam9iIGZyb20gYmVpbmcgc2tpcHBlZCBhbmQgYWxzbyBjYW4gYXZvaWQgcmVwZWF0ZWQgcGF0Y2hpbmcuXHJcbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChqb2IpIHtcclxuICAgIC8vIHRoZSBzdGFydCBpbmRleCBzaG91bGQgYmUgYGZsdXNoSW5kZXggKyAxYFxyXG4gICAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XHJcbiAgICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xyXG4gICAgY29uc3Qgam9iSWQgPSBnZXRJZChqb2IpO1xyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuICAgICAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKHF1ZXVlW21pZGRsZV0pO1xyXG4gICAgICAgIG1pZGRsZUpvYklkIDwgam9iSWQgPyAoc3RhcnQgPSBtaWRkbGUgKyAxKSA6IChlbmQgPSBtaWRkbGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXJ0O1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xyXG4gICAgLy8gdGhlIGRlZHVwZSBzZWFyY2ggdXNlcyB0aGUgc3RhcnRJbmRleCBhcmd1bWVudCBvZiBBcnJheS5pbmNsdWRlcygpXHJcbiAgICAvLyBieSBkZWZhdWx0IHRoZSBzZWFyY2ggaW5kZXggaW5jbHVkZXMgdGhlIGN1cnJlbnQgam9iIHRoYXQgaXMgYmVpbmcgcnVuXHJcbiAgICAvLyBzbyBpdCBjYW5ub3QgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgYWdhaW4uXHJcbiAgICAvLyBpZiB0aGUgam9iIGlzIGEgd2F0Y2goKSBjYWxsYmFjaywgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IHdpdGggYSArMSBpbmRleCB0b1xyXG4gICAgLy8gYWxsb3cgaXQgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgLSBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvXHJcbiAgICAvLyBlbnN1cmUgaXQgZG9lc24ndCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcC5cclxuICAgIGlmICgoIXF1ZXVlLmxlbmd0aCB8fFxyXG4gICAgICAgICFxdWV1ZS5pbmNsdWRlcyhqb2IsIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleCkpICYmXHJcbiAgICAgICAgam9iICE9PSBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IpIHtcclxuICAgICAgICBjb25zdCBwb3MgPSBmaW5kSW5zZXJ0aW9uSW5kZXgoam9iKTtcclxuICAgICAgICBpZiAocG9zID4gLTEpIHtcclxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKHBvcywgMCwgam9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goam9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVGbHVzaCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XHJcbiAgICBpZiAoIWlzRmx1c2hpbmcgJiYgIWlzRmx1c2hQZW5kaW5nKSB7XHJcbiAgICAgICAgaXNGbHVzaFBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGludmFsaWRhdGVKb2Ioam9iKSB7XHJcbiAgICBjb25zdCBpID0gcXVldWUuaW5kZXhPZihqb2IpO1xyXG4gICAgaWYgKGkgPiBmbHVzaEluZGV4KSB7XHJcbiAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlQ2IoY2IsIGFjdGl2ZVF1ZXVlLCBwZW5kaW5nUXVldWUsIGluZGV4KSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoY2IpKSB7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVRdWV1ZSB8fFxyXG4gICAgICAgICAgICAhYWN0aXZlUXVldWUuaW5jbHVkZXMoY2IsIGNiLmFsbG93UmVjdXJzZSA/IGluZGV4ICsgMSA6IGluZGV4KSkge1xyXG4gICAgICAgICAgICBwZW5kaW5nUXVldWUucHVzaChjYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgY2IgaXMgYW4gYXJyYXksIGl0IGlzIGEgY29tcG9uZW50IGxpZmVjeWNsZSBob29rIHdoaWNoIGNhbiBvbmx5IGJlXHJcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5IGEgam9iLCB3aGljaCBpcyBhbHJlYWR5IGRlZHVwZWQgaW4gdGhlIG1haW4gcXVldWUsIHNvXHJcbiAgICAgICAgLy8gd2UgY2FuIHNraXAgZHVwbGljYXRlIGNoZWNrIGhlcmUgdG8gaW1wcm92ZSBwZXJmXHJcbiAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goLi4uY2IpO1xyXG4gICAgfVxyXG4gICAgcXVldWVGbHVzaCgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUHJlRmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUHJlRmx1c2hDYnMsIHBlbmRpbmdQcmVGbHVzaENicywgcHJlRmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUG9zdEZsdXNoQ2JzLCBwZW5kaW5nUG9zdEZsdXNoQ2JzLCBwb3N0Rmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhzZWVuLCBwYXJlbnRKb2IgPSBudWxsKSB7XHJcbiAgICBpZiAocGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgIGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IHBhcmVudEpvYjtcclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQcmVGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHByZUZsdXNoSW5kZXggPSAwOyBwcmVGbHVzaEluZGV4IDwgYWN0aXZlUHJlRmx1c2hDYnMubGVuZ3RoOyBwcmVGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnNbcHJlRmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG4gICAgICAgIHByZUZsdXNoSW5kZXggPSAwO1xyXG4gICAgICAgIGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IG51bGw7XHJcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmx1c2ggdW50aWwgaXQgZHJhaW5zXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyhzZWVuLCBwYXJlbnRKb2IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcclxuICAgIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV07XHJcbiAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vICMxOTQ3IGFscmVhZHkgaGFzIGFjdGl2ZSBxdWV1ZSwgbmVzdGVkIGZsdXNoUG9zdEZsdXNoQ2JzIGNhbGxcclxuICAgICAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgICAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xyXG4gICAgICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcclxuICAgIH1cclxufVxyXG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gSW5maW5pdHkgOiBqb2IuaWQ7XHJcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XHJcbiAgICBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgaXNGbHVzaGluZyA9IHRydWU7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQcmVGbHVzaENicyhzZWVuKTtcclxuICAgIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxyXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XHJcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXHJcbiAgICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQgc28gaXRzIHJlbmRlciBlZmZlY3Qgd2lsbCBoYXZlIHNtYWxsZXJcclxuICAgIC8vICAgIHByaW9yaXR5IG51bWJlcilcclxuICAgIC8vIDIuIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3MgdXBkYXRlLFxyXG4gICAgLy8gICAgaXRzIHVwZGF0ZSBjYW4gYmUgc2tpcHBlZC5cclxuICAgIHF1ZXVlLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmb3IgKGZsdXNoSW5kZXggPSAwOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChqb2IgJiYgam9iLmFjdGl2ZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhqb2IsIG51bGwsIDE0IC8qIFNDSEVEVUxFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBmbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xyXG4gICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAvLyBzb21lIHBvc3RGbHVzaENiIHF1ZXVlZCBqb2JzIVxyXG4gICAgICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZHJhaW5zLlxyXG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmbHVzaEpvYnMoc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xyXG4gICAgaWYgKCFzZWVuLmhhcyhmbikpIHtcclxuICAgICAgICBzZWVuLnNldChmbiwgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcclxuICAgICAgICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBmbi5vd25lckluc3RhbmNlO1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICAgICAgd2FybihgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIGAgK1xyXG4gICAgICAgICAgICAgICAgYFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGAgK1xyXG4gICAgICAgICAgICAgICAgYGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3IgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSBuZXcgU2V0KCk7XHJcbi8vIEV4cG9zZSB0aGUgSE1SIHJ1bnRpbWUgb24gdGhlIGdsb2JhbCBvYmplY3RcclxuLy8gVGhpcyBtYWtlcyBpdCBlbnRpcmVseSB0cmVlLXNoYWthYmxlIHdpdGhvdXQgcG9sbHV0aW5nIHRoZSBleHBvcnRzIGFuZCBtYWtlc1xyXG4vLyBpdCBlYXNpZXIgdG8gYmUgdXNlZCBpbiB0b29saW5ncyBsaWtlIHZ1ZS1sb2FkZXJcclxuLy8gTm90ZTogZm9yIGEgY29tcG9uZW50IHRvIGJlIGVsaWdpYmxlIGZvciBITVIgaXQgYWxzbyBuZWVkcyB0aGUgX19obXJJZCBvcHRpb25cclxuLy8gdG8gYmUgc2V0IHNvIHRoYXQgaXRzIGluc3RhbmNlcyBjYW4gYmUgcmVnaXN0ZXJlZCAvIHJlbW92ZWQuXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGNvbnN0IGdsb2JhbE9iamVjdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICA/IHNlbGZcclxuICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgIDoge307XHJcbiAgICBnbG9iYWxPYmplY3QuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcclxuICAgICAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXHJcbiAgICAgICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcclxuICAgIH07XHJcbn1cclxuY29uc3QgbWFwID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XHJcbiAgICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICB9XHJcbiAgICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgY29tcG9uZW50KSB7XHJcbiAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgIHdhcm4oYEhNUiBBUEkgdXNhZ2UgaXMgb3V0IG9mIGRhdGUuXFxuYCArXHJcbiAgICAgICAgICAgIGBQbGVhc2UgdXBncmFkZSB2dWUtbG9hZGVyL3ZpdGUvcm9sbHVwLXBsdWdpbi12dWUgb3Igb3RoZXIgcmVsZXZhbnQgYCArXHJcbiAgICAgICAgICAgIGBkZXBlbmRlbmN5IHRoYXQgaGFuZGxlcyBWdWUgU0ZDIGNvbXBpbGF0aW9uLmApO1xyXG4gICAgICAgIGNvbXBvbmVudCA9IHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKG1hcC5oYXMoaWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWFwLnNldChpZCwge1xyXG4gICAgICAgIGNvbXBvbmVudDogaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudCxcclxuICAgICAgICBpbnN0YW5jZXM6IG5ldyBTZXQoKVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGlmIChuZXdSZW5kZXIpXHJcbiAgICAgICAgcmVjb3JkLmNvbXBvbmVudC5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAvLyBBcnJheS5mcm9tIGNyZWF0ZXMgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZ1xyXG4gICAgLy8gdXBkYXRlc1xyXG4gICAgQXJyYXkuZnJvbShyZWNvcmQuaW5zdGFuY2VzKS5mb3JFYWNoKGluc3RhbmNlID0+IHtcclxuICAgICAgICBpZiAobmV3UmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcclxuICAgICAgICAvLyB0aGlzIGZsYWcgZm9yY2VzIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBzbG90IGNvbnRlbnQgdG8gdXBkYXRlXHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIC8vIEFycmF5LmZyb20gY3JlYXRlcyBhIHNuYXBzaG90IHdoaWNoIGF2b2lkcyB0aGUgc2V0IGJlaW5nIG11dGF0ZWQgZHVyaW5nXHJcbiAgICAvLyB1cGRhdGVzXHJcbiAgICBjb25zdCB7IGNvbXBvbmVudCwgaW5zdGFuY2VzIH0gPSByZWNvcmQ7XHJcbiAgICBpZiAoIWhtckRpcnR5Q29tcG9uZW50cy5oYXMoY29tcG9uZW50KSkge1xyXG4gICAgICAgIC8vIDEuIFVwZGF0ZSBleGlzdGluZyBjb21wIGRlZmluaXRpb24gdG8gbWF0Y2ggbmV3IG9uZVxyXG4gICAgICAgIG5ld0NvbXAgPSBpc0NsYXNzQ29tcG9uZW50KG5ld0NvbXApID8gbmV3Q29tcC5fX3ZjY09wdHMgOiBuZXdDb21wO1xyXG4gICAgICAgIGV4dGVuZChjb21wb25lbnQsIG5ld0NvbXApO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnX19maWxlJyAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDIuIE1hcmsgY29tcG9uZW50IGRpcnR5LiBUaGlzIGZvcmNlcyB0aGUgcmVuZGVyZXIgdG8gcmVwbGFjZSB0aGUgY29tcG9uZW50XHJcbiAgICAgICAgLy8gb24gcGF0Y2guXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChjb21wb25lbnQpO1xyXG4gICAgICAgIC8vIDMuIE1ha2Ugc3VyZSB0byB1bm1hcmsgdGhlIGNvbXBvbmVudCBhZnRlciB0aGUgcmVsb2FkLlxyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKGNvbXBvbmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBBcnJheS5mcm9tKGluc3RhbmNlcykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyA0LiBGb3JjZSB0aGUgcGFyZW50IGluc3RhbmNlIHRvIHJlLXJlbmRlci4gVGhpcyB3aWxsIGNhdXNlIGFsbCB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGZvcmNpbmcgdGhlIHNhbWUgcGFyZW50IHRvIHJlLXJlbmRlciBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgbW91bnRlZCB2aWEgY3JlYXRlQXBwKCkgaGFzIGEgcmVsb2FkIG1ldGhvZFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xyXG4gICAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxubGV0IGRldnRvb2xzO1xyXG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2soaG9vaykge1xyXG4gICAgZGV2dG9vbHMgPSBob29rO1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcclxuICAgIC8vIFRPRE8gcXVldWUgaWYgZGV2dG9vbHMgaXMgdW5kZWZpbmVkXHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcclxuICAgICAgICBGcmFnbWVudCxcclxuICAgICAgICBUZXh0LFxyXG4gICAgICAgIENvbW1lbnQ6IENvbW1lbnQkMSxcclxuICAgICAgICBTdGF0aWNcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcclxuICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgZGV2dG9vbHMuZW1pdChcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGFwcCk7XHJcbn1cclxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovKTtcclxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovKTtcclxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovKTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcclxuICAgIHJldHVybiAoY29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGRldnRvb2xzLmVtaXQoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQucGFyZW50ID8gY29tcG9uZW50LnBhcmVudC51aWQgOiB1bmRlZmluZWQsIGNvbXBvbmVudCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IGRldnRvb2xzUGVyZlN0YXJ0ID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzUGVyZkVuZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqLyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcclxuICAgIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XHJcbiAgICAgICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGRldnRvb2xzLmVtaXQoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcyk7XHJcbn1cblxuY29uc3QgZGVwcmVjYXRpb25EYXRhID0ge1xyXG4gICAgW1wiR0xPQkFMX01PVU5UXCIgLyogR0xPQkFMX01PVU5UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgZ2xvYmFsIGFwcCBib290c3RyYXBwaW5nIEFQSSBoYXMgY2hhbmdlZDogdm0uJG1vdW50KCkgYW5kIHRoZSBcImVsXCIgYCArXHJcbiAgICAgICAgICAgIGBvcHRpb24gaGF2ZSBiZWVuIHJlbW92ZWQuIFVzZSBjcmVhdGVBcHAoUm9vdENvbXBvbmVudCkubW91bnQoKSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9nbG9iYWwtYXBpLmh0bWwjbW91bnRpbmctYXBwLWluc3RhbmNlYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9NT1VOVF9DT05UQUlORVJcIiAvKiBHTE9CQUxfTU9VTlRfQ09OVEFJTkVSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUgZGV0ZWN0ZWQgZGlyZWN0aXZlcyBvbiB0aGUgbW91bnQgY29udGFpbmVyLiBgICtcclxuICAgICAgICAgICAgYEluIFZ1ZSAzLCB0aGUgY29udGFpbmVyIGlzIG5vIGxvbmdlciBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHRlbXBsYXRlIGAgK1xyXG4gICAgICAgICAgICBgYW5kIHdpbGwgbm90IGJlIHByb2Nlc3NlZC9yZXBsYWNlZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vbW91bnQtY2hhbmdlcy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9FWFRFTkRcIiAvKiBHTE9CQUxfRVhURU5EICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUuZXh0ZW5kKCkgaGFzIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgZGVmaW5lQ29tcG9uZW50KCkgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9hcGkvZ2xvYmFsLWFwaS5odG1sI2RlZmluZWNvbXBvbmVudGBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfUFJPVE9UWVBFXCIgLyogR0xPQkFMX1BST1RPVFlQRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLnByb3RvdHlwZSBpcyBubyBsb25nZXIgYXZhaWxhYmxlIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFVzZSBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI3Z1ZS1wcm90b3R5cGUtcmVwbGFjZWQtYnktY29uZmlnLWdsb2JhbHByb3BlcnRpZXNgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1NFVFwiIC8qIEdMT0JBTF9TRVQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS5zZXQoKSBoYXMgYmVlbiByZW1vdmVkIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgU2ltcGx5IHVzZSBuYXRpdmUgSmF2YVNjcmlwdCBtdXRhdGlvbnMuYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9ERUxFVEVcIiAvKiBHTE9CQUxfREVMRVRFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUuZGVsZXRlKCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfT0JTRVJWQUJMRVwiIC8qIEdMT0JBTF9PQlNFUlZBQkxFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUub2JzZXJ2YWJsZSgpIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFxcYGltcG9ydCB7IHJlYWN0aXZlIH0gZnJvbSBcInZ1ZVwiXFxgIGZyb20gQ29tcG9zaXRpb24gQVBJIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvYXBpL2Jhc2ljLXJlYWN0aXZpdHkuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfUFJJVkFURV9VVElMXCIgLyogR0xPQkFMX1BSSVZBVEVfVVRJTCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLnV0aWwgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHJlZmFjdG9yIHRvIGF2b2lkIGl0cyB1c2FnZSBgICtcclxuICAgICAgICAgICAgYHNpbmNlIGl0IHdhcyBhbiBpbnRlcm5hbCBBUEkgZXZlbiBpbiBWdWUgMi5gXHJcbiAgICB9LFxyXG4gICAgW1wiQ09ORklHX1NJTEVOVFwiIC8qIENPTkZJR19TSUxFTlQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGNvbmZpZy5zaWxlbnQgaGFzIGJlZW4gcmVtb3ZlZCBiZWNhdXNlIGl0IGlzIG5vdCBnb29kIHByYWN0aWNlIHRvIGAgK1xyXG4gICAgICAgICAgICBgaW50ZW50aW9uYWxseSBzdXBwcmVzcyB3YXJuaW5ncy4gWW91IGNhbiB1c2UgeW91ciBicm93c2VyIGNvbnNvbGUncyBgICtcclxuICAgICAgICAgICAgYGZpbHRlciBmZWF0dXJlcyB0byBmb2N1cyBvbiByZWxldmFudCBtZXNzYWdlcy5gXHJcbiAgICB9LFxyXG4gICAgW1wiQ09ORklHX0RFVlRPT0xTXCIgLyogQ09ORklHX0RFVlRPT0xTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcuZGV2dG9vbHMgaGFzIGJlZW4gcmVtb3ZlZC4gVG8gZW5hYmxlIGRldnRvb2xzIGZvciBgICtcclxuICAgICAgICAgICAgYHByb2R1Y3Rpb24sIGNvbmZpZ3VyZSB0aGUgX19WVUVfUFJPRF9ERVZUT09MU19fIGNvbXBpbGUtdGltZSBmbGFnLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtbmV4dC90cmVlL21hc3Rlci9wYWNrYWdlcy92dWUjYnVuZGxlci1idWlsZC1mZWF0dXJlLWZsYWdzYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19LRVlfQ09ERVNcIiAvKiBDT05GSUdfS0VZX0NPREVTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcua2V5Q29kZXMgaGFzIGJlZW4gcmVtb3ZlZC4gYCArXHJcbiAgICAgICAgICAgIGBJbiBWdWUgMywgeW91IGNhbiBkaXJlY3RseSB1c2UgdGhlIGtlYmFiLWNhc2Uga2V5IG5hbWVzIGFzIHYtb24gbW9kaWZpZXJzLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9rZXljb2RlLW1vZGlmaWVycy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19QUk9EVUNUSU9OX1RJUFwiIC8qIENPTkZJR19QUk9EVUNUSU9OX1RJUCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLnByb2R1Y3Rpb25UaXAgaGFzIGJlZW4gcmVtb3ZlZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI2NvbmZpZy1wcm9kdWN0aW9udGlwLXJlbW92ZWRgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09ORklHX0lHTk9SRURfRUxFTUVOVFNcIiAvKiBDT05GSUdfSUdOT1JFRF9FTEVNRU5UUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBgY29uZmlnLmlnbm9yZWRFbGVtZW50cyBoYXMgYmVlbiByZW1vdmVkLmA7XHJcbiAgICAgICAgICAgIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgICAgICAgICAgICAgIG1zZyArPSBgIFBhc3MgdGhlIFwiaXNDdXN0b21FbGVtZW50XCIgb3B0aW9uIHRvIEB2dWUvY29tcGlsZXItZG9tIGluc3RlYWQuYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1zZyArPSBgIFVzZSBjb25maWcuaXNDdXN0b21FbGVtZW50IGluc3RlYWQuYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9nbG9iYWwtYXBpLmh0bWwjY29uZmlnLWlnbm9yZWRlbGVtZW50cy1pcy1ub3ctY29uZmlnLWlzY3VzdG9tZWxlbWVudGBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfV0hJVEVTUEFDRVwiIC8qIENPTkZJR19XSElURVNQQUNFICovXToge1xyXG4gICAgICAgIC8vIHRoaXMgd2FybmluZyBpcyBvbmx5IHJlbGV2YW50IGluIHRoZSBmdWxsIGJ1aWxkIHdoZW4gdXNpbmcgcnVudGltZVxyXG4gICAgICAgIC8vIGNvbXBpbGF0aW9uLCBzbyBpdCdzIHB1dCBpbiB0aGUgcnVudGltZSBjb21wYXRDb25maWcgbGlzdC5cclxuICAgICAgICBtZXNzYWdlOiBgVnVlIDMgY29tcGlsZXIncyB3aGl0ZXNwYWNlIG9wdGlvbiB3aWxsIGRlZmF1bHQgdG8gXCJjb25kZW5zZVwiIGluc3RlYWQgb2YgYCArXHJcbiAgICAgICAgICAgIGBcInByZXNlcnZlXCIuIFRvIHN1cHByZXNzIHRoaXMgd2FybmluZywgcHJvdmlkZSBhbiBleHBsaWNpdCB2YWx1ZSBmb3IgYCArXHJcbiAgICAgICAgICAgIGBcXGBjb25maWcuY29tcGlsZXJPcHRpb25zLndoaXRlc3BhY2VcXGAuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19PUFRJT05fTUVSR0VfU1RSQVRTXCIgLyogQ09ORklHX09QVElPTl9NRVJHRV9TVFJBVFMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgbm8gbG9uZ2VyIGV4cG9zZXMgaW50ZXJuYWwgc3RyYXRlZ2llcy4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgY3VzdG9tIG1lcmdlIGZ1bmN0aW9ucyBpbnN0ZWFkLmBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9TRVRcIiAvKiBJTlNUQU5DRV9TRVQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRzZXQoKSBoYXMgYmVlbiByZW1vdmVkIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgU2ltcGx5IHVzZSBuYXRpdmUgSmF2YVNjcmlwdCBtdXRhdGlvbnMuYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0RFTEVURVwiIC8qIElOU1RBTkNFX0RFTEVURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJGRlbGV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBTaW1wbHkgdXNlIG5hdGl2ZSBKYXZhU2NyaXB0IG11dGF0aW9ucy5gXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfREVTVFJPWVwiIC8qIElOU1RBTkNFX0RFU1RST1kgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRkZXN0cm95KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGFwcC51bm1vdW50KCkgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9hcGkvYXBwbGljYXRpb24tYXBpLmh0bWwjdW5tb3VudGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9FVkVOVF9FTUlUVEVSXCIgLyogSU5TVEFOQ0VfRVZFTlRfRU1JVFRFUiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJG9uLyRvbmNlLyRvZmYoKSBoYXZlIGJlZW4gcmVtb3ZlZC4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgYW4gZXh0ZXJuYWwgZXZlbnQgZW1pdHRlciBsaWJyYXJ5IGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2V2ZW50cy1hcGkuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9FVkVOVF9IT09LU1wiIC8qIElOU1RBTkNFX0VWRU5UX0hPT0tTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50ID0+IGBcIiR7ZXZlbnR9XCIgbGlmZWN5Y2xlIGV2ZW50cyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gRnJvbSB0ZW1wbGF0ZXMsIGAgK1xyXG4gICAgICAgICAgICBgdXNlIHRoZSBcInZub2RlXCIgcHJlZml4IGluc3RlYWQgb2YgXCJob29rOlwiLiBGb3IgZXhhbXBsZSwgQCR7ZXZlbnR9IGAgK1xyXG4gICAgICAgICAgICBgc2hvdWxkIGJlIGNoYW5nZWQgdG8gQHZub2RlLSR7ZXZlbnQuc2xpY2UoNSl9LiBgICtcclxuICAgICAgICAgICAgYEZyb20gSmF2YVNjcmlwdCwgdXNlIENvbXBvc2l0aW9uIEFQSSB0byBkeW5hbWljYWxseSByZWdpc3RlciBsaWZlY3ljbGUgYCArXHJcbiAgICAgICAgICAgIGBob29rcy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdm5vZGUtbGlmZWN5Y2xlLWV2ZW50cy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0NISUxEUkVOXCIgLyogSU5TVEFOQ0VfQ0hJTERSRU4gKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRjaGlsZHJlbiBoYXMgYmVlbiByZW1vdmVkLiBDb25zaWRlciByZWZhY3RvcmluZyB5b3VyIGxvZ2ljIGAgK1xyXG4gICAgICAgICAgICBgdG8gYXZvaWQgcmVseWluZyBvbiBkaXJlY3QgYWNjZXNzIHRvIGNoaWxkIGNvbXBvbmVudHMuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2NoaWxkcmVuLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfTElTVEVORVJTXCIgLyogSU5TVEFOQ0VfTElTVEVORVJTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kbGlzdGVuZXJzIGhhcyBiZWVuIHJlbW92ZWQuIEluIFZ1ZSAzLCBwYXJlbnQgdi1vbiBsaXN0ZW5lcnMgYXJlIGAgK1xyXG4gICAgICAgICAgICBgaW5jbHVkZWQgaW4gdm0uJGF0dHJzIGFuZCBpdCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IHRvIHNlcGFyYXRlbHkgdXNlIGAgK1xyXG4gICAgICAgICAgICBgdi1vbj1cIiRsaXN0ZW5lcnNcIiBpZiB5b3UgYXJlIGFscmVhZHkgdXNpbmcgdi1iaW5kPVwiJGF0dHJzXCIuIGAgK1xyXG4gICAgICAgICAgICBgKE5vdGU6IHRoZSBWdWUgMyBiZWhhdmlvciBvbmx5IGFwcGxpZXMgaWYgdGhpcyBjb21wYXQgY29uZmlnIGlzIGRpc2FibGVkKWAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9saXN0ZW5lcnMtcmVtb3ZlZC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX1NDT1BFRF9TTE9UU1wiIC8qIElOU1RBTkNFX1NDT1BFRF9TTE9UUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJHNjb3BlZFNsb3RzIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2bS4kc2xvdHMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vc2xvdHMtdW5pZmljYXRpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRVwiIC8qIElOU1RBTkNFX0FUVFJTX0NMQVNTX1NUWUxFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGNvbXBvbmVudE5hbWUgPT4gYENvbXBvbmVudCA8JHtjb21wb25lbnROYW1lIHx8XHJcbiAgICAgICAgICAgICdBbm9ueW1vdXMnfT4gaGFzIFxcYGluaGVyaXRBdHRyczogZmFsc2VcXGAgYnV0IGlzIGAgK1xyXG4gICAgICAgICAgICBgcmVseWluZyBvbiBjbGFzcy9zdHlsZSBmYWxsdGhyb3VnaCBmcm9tIHBhcmVudC4gSW4gVnVlIDMsIGNsYXNzL3N0eWxlIGAgK1xyXG4gICAgICAgICAgICBgYXJlIG5vdyBpbmNsdWRlZCBpbiAkYXR0cnMgYW5kIHdpbGwgbm8gbG9uZ2VyIGZhbGx0aHJvdWdoIHdoZW4gYCArXHJcbiAgICAgICAgICAgIGBpbmhlcml0QXR0cnMgaXMgZmFsc2UuIElmIHlvdSBhcmUgYWxyZWFkeSB1c2luZyB2LWJpbmQ9XCIkYXR0cnNcIiBvbiBgICtcclxuICAgICAgICAgICAgYGNvbXBvbmVudCByb290IGl0IHNob3VsZCByZW5kZXIgdGhlIHNhbWUgZW5kIHJlc3VsdC4gYCArXHJcbiAgICAgICAgICAgIGBJZiB5b3UgYXJlIGJpbmRpbmcgJGF0dHJzIHRvIGEgbm9uLXJvb3QgZWxlbWVudCBhbmQgZXhwZWN0aW5nIGAgK1xyXG4gICAgICAgICAgICBgY2xhc3Mvc3R5bGUgdG8gZmFsbHRocm91Z2ggb24gcm9vdCwgeW91IHdpbGwgbmVlZCB0byBub3cgbWFudWFsbHkgYmluZCBgICtcclxuICAgICAgICAgICAgYHRoZW0gb24gcm9vdCB2aWEgOmNsYXNzPVwiJGF0dHJzLmNsYXNzXCIuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2F0dHJzLWluY2x1ZGVzLWNsYXNzLXN0eWxlLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiT1BUSU9OU19EQVRBX0ZOXCIgLyogT1BUSU9OU19EQVRBX0ZOICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgXCJkYXRhXCIgb3B0aW9uIGNhbiBubyBsb25nZXIgYmUgYSBwbGFpbiBvYmplY3QuIGAgK1xyXG4gICAgICAgICAgICBgQWx3YXlzIHVzZSBhIGZ1bmN0aW9uLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9kYXRhLW9wdGlvbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfREFUQV9NRVJHRVwiIC8qIE9QVElPTlNfREFUQV9NRVJHRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoa2V5KSA9PiBgRGV0ZWN0ZWQgY29uZmxpY3Rpbmcga2V5IFwiJHtrZXl9XCIgd2hlbiBtZXJnaW5nIGRhdGEgb3B0aW9uIHZhbHVlcy4gYCArXHJcbiAgICAgICAgICAgIGBJbiBWdWUgMywgZGF0YSBrZXlzIGFyZSBtZXJnZWQgc2hhbGxvd2x5IGFuZCB3aWxsIG92ZXJyaWRlIG9uZSBhbm90aGVyLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9kYXRhLW9wdGlvbi5odG1sI21peGluLW1lcmdlLWJlaGF2aW9yLWNoYW5nZWBcclxuICAgIH0sXHJcbiAgICBbXCJPUFRJT05TX0JFRk9SRV9ERVNUUk9ZXCIgLyogT1BUSU9OU19CRUZPUkVfREVTVFJPWSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgXFxgYmVmb3JlRGVzdHJveVxcYCBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYGJlZm9yZVVubW91bnRcXGAuYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfREVTVFJPWUVEXCIgLyogT1BUSU9OU19ERVNUUk9ZRUQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFxcYGRlc3Ryb3llZFxcYCBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHVubW91bnRlZFxcYC5gXHJcbiAgICB9LFxyXG4gICAgW1wiV0FUQ0hfQVJSQVlcIiAvKiBXQVRDSF9BUlJBWSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgXCJ3YXRjaFwiIG9wdGlvbiBvciB2bS4kd2F0Y2ggb24gYW4gYXJyYXkgdmFsdWUgd2lsbCBubyBsb25nZXIgYCArXHJcbiAgICAgICAgICAgIGB0cmlnZ2VyIG9uIGFycmF5IG11dGF0aW9uIHVubGVzcyB0aGUgXCJkZWVwXCIgb3B0aW9uIGlzIHNwZWNpZmllZC4gYCArXHJcbiAgICAgICAgICAgIGBJZiBjdXJyZW50IHVzYWdlIGlzIGludGVuZGVkLCB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgYCArXHJcbiAgICAgICAgICAgIGBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgd2l0aDpgICtcclxuICAgICAgICAgICAgYFxcblxcbiAgY29uZmlndXJlQ29tcGF0KHsgJHtcIldBVENIX0FSUkFZXCIgLyogV0FUQ0hfQVJSQVkgKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi93YXRjaC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlBST1BTX0RFRkFVTFRfVEhJU1wiIC8qIFBST1BTX0RFRkFVTFRfVEhJUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoa2V5KSA9PiBgcHJvcHMgZGVmYXVsdCB2YWx1ZSBmdW5jdGlvbiBubyBsb25nZXIgaGFzIGFjY2VzcyB0byBcInRoaXNcIi4gVGhlIGNvbXBhdCBgICtcclxuICAgICAgICAgICAgYGJ1aWxkIG9ubHkgb2ZmZXJzIGFjY2VzcyB0byB0aGlzLiRvcHRpb25zLmAgK1xyXG4gICAgICAgICAgICBgKGZvdW5kIGluIHByb3AgXCIke2tleX1cIilgLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vcHJvcHMtZGVmYXVsdC10aGlzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ1VTVE9NX0RJUlwiIC8qIENVU1RPTV9ESVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGxlZ2FjeUhvb2ssIG5ld0hvb2spID0+IGBDdXN0b20gZGlyZWN0aXZlIGhvb2sgXCIke2xlZ2FjeUhvb2t9XCIgaGFzIGJlZW4gcmVtb3ZlZC4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgXCIke25ld0hvb2t9XCIgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vY3VzdG9tLWRpcmVjdGl2ZXMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJWX0ZPUl9SRUZcIiAvKiBWX0ZPUl9SRUYgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFJlZiB1c2FnZSBvbiB2LWZvciBubyBsb25nZXIgY3JlYXRlcyBhcnJheSByZWYgdmFsdWVzIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYENvbnNpZGVyIHVzaW5nIGZ1bmN0aW9uIHJlZnMgb3IgcmVmYWN0b3IgdG8gYXZvaWQgcmVmIHVzYWdlIGFsdG9nZXRoZXIuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2FycmF5LXJlZnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJWX09OX0tFWUNPREVfTU9ESUZJRVJcIiAvKiBWX09OX0tFWUNPREVfTU9ESUZJRVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFVzaW5nIGtleUNvZGUgYXMgdi1vbiBtb2RpZmllciBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBgICtcclxuICAgICAgICAgICAgYFVzZSBrZWJhYi1jYXNlIGtleSBuYW1lIG1vZGlmaWVycyBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9rZXljb2RlLW1vZGlmaWVycy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkFUVFJfRkFMU0VfVkFMVUVcIiAvKiBBVFRSX0ZBTFNFX1ZBTFVFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IChuYW1lKSA9PiBgQXR0cmlidXRlIFwiJHtuYW1lfVwiIHdpdGggdi1iaW5kIHZhbHVlIFxcYGZhbHNlXFxgIHdpbGwgcmVuZGVyIGAgK1xyXG4gICAgICAgICAgICBgJHtuYW1lfT1cImZhbHNlXCIgaW5zdGVhZCBvZiByZW1vdmluZyBpdCBpbiBWdWUgMy4gVG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUsIGAgK1xyXG4gICAgICAgICAgICBgdXNlIFxcYG51bGxcXGAgb3IgXFxgdW5kZWZpbmVkXFxgIGluc3RlYWQuIElmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZCwgYCArXHJcbiAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJBVFRSX0ZBTFNFX1ZBTFVFXCIgLyogQVRUUl9GQUxTRV9WQUxVRSAqL306IGZhbHNlIH0pXFxuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2F0dHJpYnV0ZS1jb2VyY2lvbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTlwiIC8qIEFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAobmFtZSwgdmFsdWUsIGNvZXJjZWQpID0+IGBFbnVtZXJhdGVkIGF0dHJpYnV0ZSBcIiR7bmFtZX1cIiB3aXRoIHYtYmluZCB2YWx1ZSBcXGAke3ZhbHVlfVxcYCB3aWxsIGAgK1xyXG4gICAgICAgICAgICBgJHt2YWx1ZSA9PT0gbnVsbCA/IGBiZSByZW1vdmVkYCA6IGByZW5kZXIgdGhlIHZhbHVlIGFzLWlzYH0gaW5zdGVhZCBvZiBjb2VyY2luZyB0aGUgdmFsdWUgdG8gXCIke2NvZXJjZWR9XCIgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgQWx3YXlzIHVzZSBleHBsaWNpdCBcInRydWVcIiBvciBcImZhbHNlXCIgdmFsdWVzIGZvciBlbnVtZXJhdGVkIGF0dHJpYnV0ZXMuIGAgK1xyXG4gICAgICAgICAgICBgSWYgdGhlIHVzYWdlIGlzIGludGVuZGVkLCBgICtcclxuICAgICAgICAgICAgYHlvdSBjYW4gZGlzYWJsZSB0aGUgY29tcGF0IGJlaGF2aW9yIGFuZCBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgd2l0aDpgICtcclxuICAgICAgICAgICAgYFxcblxcbiAgY29uZmlndXJlQ29tcGF0KHsgJHtcIkFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTlwiIC8qIEFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTiAqL306IGZhbHNlIH0pXFxuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2F0dHJpYnV0ZS1jb2VyY2lvbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlRSQU5TSVRJT05fQ0xBU1NFU1wiIC8qIFRSQU5TSVRJT05fQ0xBU1NFUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgYCAvLyB0aGlzIGZlYXR1cmUgY2Fubm90IGJlIHJ1bnRpbWUtZGV0ZWN0ZWRcclxuICAgIH0sXHJcbiAgICBbXCJUUkFOU0lUSU9OX0dST1VQX1JPT1RcIiAvKiBUUkFOU0lUSU9OX0dST1VQX1JPT1QgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYDxUcmFuc2l0aW9uR3JvdXA+IG5vIGxvbmdlciByZW5kZXJzIGEgcm9vdCA8c3Bhbj4gZWxlbWVudCBieSBgICtcclxuICAgICAgICAgICAgYGRlZmF1bHQgaWYgbm8gXCJ0YWdcIiBwcm9wIGlzIHNwZWNpZmllZC4gSWYgeW91IGRvIG5vdCByZWx5IG9uIHRoZSBzcGFuIGAgK1xyXG4gICAgICAgICAgICBgZm9yIHN0eWxpbmcsIHlvdSBjYW4gZGlzYWJsZSB0aGUgY29tcGF0IGJlaGF2aW9yIGFuZCBzdXBwcmVzcyB0aGlzIGAgK1xyXG4gICAgICAgICAgICBgd2FybmluZyB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiVFJBTlNJVElPTl9HUk9VUF9ST09UXCIgLyogVFJBTlNJVElPTl9HUk9VUF9ST09UICovfTogZmFsc2UgfSlcXG5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdHJhbnNpdGlvbi1ncm91cC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBPTkVOVF9BU1lOQ1wiIC8qIENPTVBPTkVOVF9BU1lOQyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wKTtcclxuICAgICAgICAgICAgcmV0dXJuIChgQXN5bmMgY29tcG9uZW50JHtuYW1lID8gYCA8JHtuYW1lfT5gIDogYHNgfSBzaG91bGQgYmUgZXhwbGljaXRseSBjcmVhdGVkIHZpYSBcXGBkZWZpbmVBc3luY0NvbXBvbmVudCgpXFxgIGAgK1xyXG4gICAgICAgICAgICAgICAgYGluIFZ1ZSAzLiBQbGFpbiBmdW5jdGlvbnMgd2lsbCBiZSB0cmVhdGVkIGFzIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBpbiBgICtcclxuICAgICAgICAgICAgICAgIGBub24tY29tcGF0IGJ1aWxkLiBJZiB5b3UgaGF2ZSBhbHJlYWR5IG1pZ3JhdGVkIGFsbCBhc3luYyBjb21wb25lbnQgYCArXHJcbiAgICAgICAgICAgICAgICBgdXNhZ2UgYW5kIGludGVuZCB0byB1c2UgcGxhaW4gZnVuY3Rpb25zIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIGAgK1xyXG4gICAgICAgICAgICAgICAgYHlvdSBjYW4gZGlzYWJsZSB0aGUgY29tcGF0IGJlaGF2aW9yIGFuZCBzdXBwcmVzcyB0aGlzIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhcm5pbmcgd2l0aDpgICtcclxuICAgICAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJDT01QT05FTlRfQVNZTkNcIiAvKiBDT01QT05FTlRfQVNZTkMgKi99OiBmYWxzZSB9KVxcbmApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hc3luYy1jb21wb25lbnRzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUE9ORU5UX0ZVTkNUSU9OQUxcIiAvKiBDT01QT05FTlRfRlVOQ1RJT05BTCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wKTtcclxuICAgICAgICAgICAgcmV0dXJuIChgRnVuY3Rpb25hbCBjb21wb25lbnQke25hbWUgPyBgIDwke25hbWV9PmAgOiBgc2B9IHNob3VsZCBiZSBkZWZpbmVkIGFzIGEgcGxhaW4gZnVuY3Rpb24gaW4gVnVlIDMuIFRoZSBcImZ1bmN0aW9uYWxcIiBgICtcclxuICAgICAgICAgICAgICAgIGBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gTk9URTogQmVmb3JlIG1pZ3JhdGluZyB0byB1c2UgcGxhaW4gYCArXHJcbiAgICAgICAgICAgICAgICBgZnVuY3Rpb25zIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IGFsbCBhc3luYyBgICtcclxuICAgICAgICAgICAgICAgIGBjb21wb25lbnRzIHVzYWdlIGhhdmUgYmVlbiBtaWdyYXRlZCBhbmQgaXRzIGNvbXBhdCBiZWhhdmlvciBoYXMgYCArXHJcbiAgICAgICAgICAgICAgICBgYmVlbiBkaXNhYmxlZC5gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZnVuY3Rpb25hbC1jb21wb25lbnRzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUE9ORU5UX1ZfTU9ERUxcIiAvKiBDT01QT05FTlRfVl9NT0RFTCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb25maWdNc2cgPSBgb3B0LWluIHRvIGAgK1xyXG4gICAgICAgICAgICAgICAgYFZ1ZSAzIGJlaGF2aW9yIG9uIGEgcGVyLWNvbXBvbmVudCBiYXNpcyB3aXRoIFxcYGNvbXBhdENvbmZpZzogeyAke1wiQ09NUE9ORU5UX1ZfTU9ERUxcIiAvKiBDT01QT05FTlRfVl9NT0RFTCAqL306IGZhbHNlIH1cXGAuYDtcclxuICAgICAgICAgICAgaWYgKGNvbXAucHJvcHMgJiYgaXNBcnJheShjb21wLnByb3BzKVxyXG4gICAgICAgICAgICAgICAgPyBjb21wLnByb3BzLmluY2x1ZGVzKCdtb2RlbFZhbHVlJylcclxuICAgICAgICAgICAgICAgIDogaGFzT3duKGNvbXAucHJvcHMsICdtb2RlbFZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYENvbXBvbmVudCBkZWxjYXJlcyBcIm1vZGVsVmFsdWVcIiBwcm9wLCB3aGljaCBpcyBWdWUgMyB1c2FnZSwgYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBpcyBydW5uaW5nIHVuZGVyIFZ1ZSAyIGNvbXBhdCB2LW1vZGVsIGJlaGF2aW9yLiBZb3UgY2FuICR7Y29uZmlnTXNnfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoYHYtbW9kZWwgdXNhZ2Ugb24gY29tcG9uZW50IGhhcyBjaGFuZ2VkIGluIFZ1ZSAzLiBDb21wb25lbnQgdGhhdCBleHBlY3RzIGAgK1xyXG4gICAgICAgICAgICAgICAgYHRvIHdvcmsgd2l0aCB2LW1vZGVsIHNob3VsZCBub3cgdXNlIHRoZSBcIm1vZGVsVmFsdWVcIiBwcm9wIGFuZCBlbWl0IHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGBcInVwZGF0ZTptb2RlbFZhbHVlXCIgZXZlbnQuIFlvdSBjYW4gdXBkYXRlIHRoZSB1c2FnZSBhbmQgdGhlbiAke2NvbmZpZ01zZ31gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdi1tb2RlbC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlJFTkRFUl9GVU5DVElPTlwiIC8qIFJFTkRFUl9GVU5DVElPTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlIDMncyByZW5kZXIgZnVuY3Rpb24gQVBJIGhhcyBjaGFuZ2VkLiBgICtcclxuICAgICAgICAgICAgYFlvdSBjYW4gb3B0LWluIHRvIHRoZSBuZXcgQVBJIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJSRU5ERVJfRlVOQ1RJT05cIiAvKiBSRU5ERVJfRlVOQ1RJT04gKi99OiBmYWxzZSB9KVxcbmAgK1xyXG4gICAgICAgICAgICBgXFxuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIHBlci1jb21wb25lbnQgdmlhIHRoZSBcImNvbXBhdENvbmZpZ1wiIG9wdGlvbi4pYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3JlbmRlci1mdW5jdGlvbi1hcGkuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJGSUxURVJTXCIgLyogRklMVEVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgZmlsdGVycyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBUaGUgXCJ8XCIgc3ltYm9sIHdpbGwgYmUgdHJlYXRlZCBhcyBuYXRpdmUgSmF2YVNjcmlwdCBiaXR3aXNlIE9SIG9wZXJhdG9yLiBgICtcclxuICAgICAgICAgICAgYFVzZSBtZXRob2QgY2FsbHMgb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9maWx0ZXJzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiUFJJVkFURV9BUElTXCIgLyogUFJJVkFURV9BUElTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IG5hbWUgPT4gYFwiJHtuYW1lfVwiIGlzIGEgVnVlIDIgcHJpdmF0ZSBBUEkgdGhhdCBubyBsb25nZXIgZXhpc3RzIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgd2FybmluZyBvbmx5IGR1ZSB0byBhIGRlcGVuZGVuY3ksIHlvdSBjYW4gYCArXHJcbiAgICAgICAgICAgIGBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgdmlhIHsgUFJJVkFURV9BUElTOiAnc3VwcmVzcy13YXJuaW5nJyB9LmBcclxuICAgIH1cclxufTtcclxuY29uc3QgaW5zdGFuY2VXYXJuZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5jb25zdCB3YXJuQ291bnQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRpb24oa2V5LCBpbnN0YW5jZSwgLi4uYXJncykge1xyXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlIHx8IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgLy8gY2hlY2sgdXNlciBjb25maWdcclxuICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbXBhdENvbmZpZ0ZvcktleShrZXksIGluc3RhbmNlKTtcclxuICAgIGlmIChjb25maWcgPT09ICdzdXBwcmVzcy13YXJuaW5nJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGR1cEtleSA9IGtleSArIGFyZ3Muam9pbignJyk7XHJcbiAgICBsZXQgY29tcElkID0gaW5zdGFuY2UgJiYgZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSk7XHJcbiAgICBpZiAoY29tcElkID09PSAnQW5vbnltb3VzJyAmJiBpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbXBJZCA9IGluc3RhbmNlLnVpZDtcclxuICAgIH1cclxuICAgIC8vIHNraXAgaWYgdGhlIHNhbWUgd2FybmluZyBpcyBlbWl0dGVkIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdHlwZVxyXG4gICAgY29uc3QgY29tcG9uZW50RHVwS2V5ID0gZHVwS2V5ICsgY29tcElkO1xyXG4gICAgaWYgKGNvbXBvbmVudER1cEtleSBpbiBpbnN0YW5jZVdhcm5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGluc3RhbmNlV2FybmVkW2NvbXBvbmVudER1cEtleV0gPSB0cnVlO1xyXG4gICAgLy8gc2FtZSB3YXJuaW5nLCBidXQgZGlmZmVyZW50IGNvbXBvbmVudC4gc2tpcCB0aGUgbG9uZyBtZXNzYWdlIGFuZCBqdXN0XHJcbiAgICAvLyBsb2cgdGhlIGtleSBhbmQgY291bnQuXHJcbiAgICBpZiAoZHVwS2V5IGluIHdhcm5Db3VudCkge1xyXG4gICAgICAgIHdhcm4oYChkZXByZWNhdGlvbiAke2tleX0pICgkeysrd2FybkNvdW50W2R1cEtleV0gKyAxfSlgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB3YXJuQ291bnRbZHVwS2V5XSA9IDA7XHJcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGxpbmsgfSA9IGRlcHJlY2F0aW9uRGF0YVtrZXldO1xyXG4gICAgd2FybihgKGRlcHJlY2F0aW9uICR7a2V5fSkgJHt0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IG1lc3NhZ2UoLi4uYXJncykgOiBtZXNzYWdlfSR7bGluayA/IGBcXG4gIERldGFpbHM6ICR7bGlua31gIDogYGB9YCk7XHJcbiAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChrZXksIGluc3RhbmNlLCB0cnVlKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYF4gVGhlIGFib3ZlIGRlcHJlY2F0aW9uJ3MgY29tcGF0IGJlaGF2aW9yIGlzIGRpc2FibGVkIGFuZCB3aWxsIGxpa2VseSBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gcnVudGltZSBlcnJvcnMuYCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2xvYmFsQ29tcGF0Q29uZmlnID0ge1xyXG4gICAgTU9ERTogMlxyXG59O1xyXG5mdW5jdGlvbiBnZXRDb21wYXRDb25maWdGb3JLZXkoa2V5LCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaW5zdGFuY2VDb25maWcgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLmNvbXBhdENvbmZpZztcclxuICAgIGlmIChpbnN0YW5jZUNvbmZpZyAmJiBrZXkgaW4gaW5zdGFuY2VDb25maWcpIHtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2VDb25maWdba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBnbG9iYWxDb21wYXRDb25maWdba2V5XTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBhdEVuYWJsZWQoa2V5LCBpbnN0YW5jZSwgZW5hYmxlRm9yQnVpbHRJbiA9IGZhbHNlKSB7XHJcbiAgICAvLyBza2lwIGNvbXBhdCBmb3IgYnVpbHQtaW4gY29tcG9uZW50c1xyXG4gICAgaWYgKCFlbmFibGVGb3JCdWlsdEluICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19pc0J1aWx0SW4pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXdNb2RlID0gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KCdNT0RFJywgaW5zdGFuY2UpIHx8IDI7XHJcbiAgICBjb25zdCB2YWwgPSBnZXRDb21wYXRDb25maWdGb3JLZXkoa2V5LCBpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBtb2RlID0gaXNGdW5jdGlvbihyYXdNb2RlKVxyXG4gICAgICAgID8gcmF3TW9kZShpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlKVxyXG4gICAgICAgIDogcmF3TW9kZTtcclxuICAgIGlmIChtb2RlID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCAhPT0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gJ3N1cHByZXNzLXdhcm5pbmcnO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCB7IGVtaXRzT3B0aW9ucywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGVtaXRzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmXHJcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGFyZ3MgPSByYXdBcmdzO1xyXG4gICAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aCgndXBkYXRlOicpO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFwcGx5IG1vZGlmaWVycyBvbiBhcmdzXHJcbiAgICBjb25zdCBtb2RlbEFyZyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBldmVudC5zbGljZSg3KTtcclxuICAgIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSAnbW9kZWxWYWx1ZScgPyAnbW9kZWwnIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcclxuICAgICAgICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gcHJvcHNbbW9kaWZpZXJzS2V5XSB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGEgPT4gYS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1iZXIpIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKHRvTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcclxuICAgICAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBgICtcclxuICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcclxuICAgICAgICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXHJcbiAgICAgICAgICAgICAgICBgWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGhhbmRsZXJOYW1lO1xyXG4gICAgbGV0IGhhbmRsZXIgPSBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpKV0gfHxcclxuICAgICAgICAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXHJcbiAgICAgICAgcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkpXTtcclxuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhbHNvIHRyaWdnZXIga2ViYWItY2FzZSBlcXVpdmFsZW50XHJcbiAgICAvLyBmb3IgcHJvcHMgcGFzc2VkIHZpYSBrZWJhYi1jYXNlXHJcbiAgICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XHJcbiAgICAgICAgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKSldO1xyXG4gICAgfVxyXG4gICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhoYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcclxuICAgIGlmIChvbmNlSGFuZGxlcikge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xyXG4gICAgICAgICAgICAoaW5zdGFuY2UuZW1pdHRlZCA9IHt9KVtoYW5kbGVyTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKG9uY2VIYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XHJcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcclxuICAgIGxldCBub3JtYWxpemVkID0ge307XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIHJhdy5mb3JFYWNoKGtleSA9PiAobm9ybWFsaXplZFtrZXldID0gbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG4vLyBDaGVjayBpZiBhbiBpbmNvbWluZyBwcm9wIGtleSBpcyBhIGRlY2xhcmVkIGVtaXQgZXZlbnQgbGlzdGVuZXIuXHJcbi8vIGUuZy4gV2l0aCBgZW1pdHM6IHsgY2xpY2s6IG51bGwgfWAsIHByb3BzIG5hbWVkIGBvbkNsaWNrYCBhbmQgYG9uY2xpY2tgIGFyZVxyXG4vLyBib3RoIGNvbnNpZGVyZWQgbWF0Y2hlZCBsaXN0ZW5lcnMuXHJcbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xyXG4gICAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCAnJyk7XHJcbiAgICByZXR1cm4gKGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHxcclxuICAgICAgICBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGtleSkpO1xyXG59XG5cbi8qKlxyXG4gKiBtYXJrIHRoZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZSBmb3IgYXNzZXQgcmVzb2x1dGlvbiAoZS5nLlxyXG4gKiByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlKSBkdXJpbmcgcmVuZGVyXHJcbiAqL1xyXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcclxuLyoqXHJcbiAqIE5vdGU6IHJlbmRlcmluZyBjYWxscyBtYXliZSBuZXN0ZWQuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBwYXJlbnQgcmVuZGVyaW5nXHJcbiAqIGluc3RhbmNlIGlmIHByZXNlbnQsIHdoaWNoIHNob3VsZCBiZSByZXN0b3JlZCBhZnRlciB0aGUgcmVuZGVyIGlzIGRvbmU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaSlcclxuICogLy8gLi4ucmVuZGVyXHJcbiAqIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSAoaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQpIHx8IG51bGw7XHJcbiAgICByZXR1cm4gcHJldjtcclxufVxyXG4vKipcclxuICogU2V0IHNjb3BlIGlkIHdoZW4gY3JlYXRpbmcgaG9pc3RlZCB2bm9kZXMuXHJcbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxyXG4gKi9cclxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gaWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlY2huaWNhbGx5IHdlIG5vIGxvbmdlciBuZWVkIHRoaXMgYWZ0ZXIgMy4wLjggYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgc2FtZVxyXG4gKiBBUEkgZm9yIGJhY2t3YXJkcyBjb21wYXQgdy8gY29kZSBnZW5lcmF0ZWQgYnkgY29tcGlsZXJzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcclxufVxyXG4vKipcclxuICogT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xyXG4vKipcclxuICogV3JhcCBhIHNsb3QgZnVuY3Rpb24gdG8gbWVtb2l6ZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90IC8vIGZhbHNlIG9ubHlcclxuKSB7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWRcclxuICAgIGlmIChmbi5fbikge1xyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIC8vIElmIGEgdXNlciBjYWxscyBhIGNvbXBpbGVkIHNsb3QgaW5zaWRlIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiAoIzE3NDUpLCBpdFxyXG4gICAgICAgIC8vIGNhbiBtZXNzIHVwIGJsb2NrIHRyYWNraW5nLCBzbyBieSBkZWZhdWx0IHdlIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYW5kXHJcbiAgICAgICAgLy8gZm9yY2UgYmFpbCBvdXQgd2hlbiBpbnZva2luZyBhIGNvbXBpbGVkIHNsb3QgKGluZGljYXRlZCBieSB0aGUgLl9kIGZsYWcpLlxyXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgbmVjZXNzYXJ5IGlmIHJlbmRlcmluZyBhIGNvbXBpbGVkIGA8c2xvdD5gLCBzbyB3ZSBmbGlwIHRoZVxyXG4gICAgICAgIC8vIC5fZCBmbGFnIG9mZiB3aGVuIGludm9raW5nIHRoZSB3cmFwcGVkIGZuIGluc2lkZSBgcmVuZGVyU2xvdGAuXHJcbiAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcclxuICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xyXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XHJcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIG1hcmsgbm9ybWFsaXplZCB0byBhdm9pZCBkdXBsaWNhdGVkIHdyYXBwaW5nXHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcclxuICAgIC8vIG1hcmsgdGhpcyBhcyBjb21waWxlZCBieSBkZWZhdWx0XHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gdm5vZGUudHMgLT4gbm9ybWFsaXplQ2hpbGRyZW4oKSB0byBzZXQgdGhlIHNsb3RcclxuICAgIC8vIHJlbmRlcmluZyBmbGFnLlxyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XHJcbiAgICAvLyBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHRcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XHJcbn1cblxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgdG8gdHJhY2sgd2hldGhlciAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlci5cclxuICogSWYgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIgdGhlbiB0aGUgd2FybmluZyBmb3IgZmFpbGVkIGF0dHJzXHJcbiAqIGZhbGx0aHJvdWdoIGNhbiBiZSBzdXBwcmVzc2VkLlxyXG4gKi9cclxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XHJcbiAgICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCwgdm5vZGUsIHByb3h5LCB3aXRoUHJveHksIHByb3BzLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLCBzbG90cywgYXR0cnMsIGVtaXQsIHJlbmRlciwgcmVuZGVyQ2FjaGUsIGRhdGEsIHNldHVwU3RhdGUsIGN0eCwgaW5oZXJpdEF0dHJzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAvLyB3aXRoUHJveHkgaXMgYSBwcm94eSB3aXRoIGEgZGlmZmVyZW50IGBoYXNgIHRyYXAgb25seSBmb3JcclxuICAgICAgICAgICAgLy8gcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9jay5cclxuICAgICAgICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmNhbGwocHJveHlUb1VzZSwgcHJveHlUb1VzZSwgcmVuZGVyQ2FjaGUsIHByb3BzLCBzZXR1cFN0YXRlLCBkYXRhLCBjdHgpKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbFxyXG4gICAgICAgICAgICBjb25zdCByZW5kZXIgPSBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIC8vIGluIGRldiwgbWFyayBhdHRycyBhY2Nlc3NlZCBpZiBvcHRpb25hbCBwcm9wcyAoYXR0cnMgPT09IHByb3BzKVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGF0dHJzID09PSBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyByZW5kZXIocHJvcHMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH0pXHJcbiAgICAgICAgICAgICAgICA6IHJlbmRlcihwcm9wcywgbnVsbCAvKiB3ZSBrbm93IGl0IGRvZXNuJ3QgbmVlZCBpdCAqLykpO1xyXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzXHJcbiAgICAgICAgICAgICAgICA/IGF0dHJzXHJcbiAgICAgICAgICAgICAgICA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF0dHIgbWVyZ2luZ1xyXG4gICAgICAgIC8vIGluIGRldiBtb2RlLCBjb21tZW50cyBhcmUgcHJlc2VydmVkLCBhbmQgaXQncyBwb3NzaWJsZSBmb3IgYSB0ZW1wbGF0ZVxyXG4gICAgICAgIC8vIHRvIGhhdmUgY29tbWVudHMgYWxvbmcgc2lkZSB0aGUgcm9vdCBlbGVtZW50IHdoaWNoIG1ha2VzIGl0IGEgZnJhZ21lbnRcclxuICAgICAgICBsZXQgcm9vdCA9IHJlc3VsdDtcclxuICAgICAgICBsZXQgc2V0Um9vdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgW3Jvb3QsIHNldFJvb3RdID0gZ2V0Q2hpbGRSb290KHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcclxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgdi1tb2RlbCBsaXN0ZW5lciAob25VcGRhdGU6eHh4KSBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY2xhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3AsIGl0IGluZGljYXRlcyB0aGlzIGNvbXBvbmVudCBleHBlY3RzIHRvIGhhbmRsZSB2LW1vZGVsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgbm90IGZhbGx0aHJvdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGVkOiAjMTU0MywgIzE2NDMsICMxOTg5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhmYWxsdGhyb3VnaEF0dHJzLCBwcm9wc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGhhbmRsZXJzIHdoZW4gdGhleSBmYWlsIHRvIGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V2ZW50QXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYWxzZSAmJlxyXG4gICAgICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRVwiIC8qIElOU1RBTkNFX0FUVFJTX0NMQVNTX1NUWUxFICovLCBpbnN0YW5jZSkgJiZcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8gJiZcclxuICAgICAgICAgICAgKHJvb3Quc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICByb290LnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSkgO1xyXG4gICAgICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgICAgIGlmICh2bm9kZS5kaXJzKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaGVyaXQgdHJhbnNpdGlvbiBkYXRhXHJcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0Um9vdCkge1xyXG4gICAgICAgICAgICBzZXRSb290KHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcm9vdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEgLyogUkVOREVSX0ZVTkNUSU9OICovKTtcclxuICAgICAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50JDEpO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICogSW4gZGV2IG1vZGUsIHRlbXBsYXRlIHJvb3QgbGV2ZWwgY29tbWVudHMgYXJlIHJlbmRlcmVkLCB3aGljaCB0dXJucyB0aGVcclxuICogdGVtcGxhdGUgaW50byBhIGZyYWdtZW50IHJvb3QsIGJ1dCB3ZSBuZWVkIHRvIGxvY2F0ZSB0aGUgc2luZ2xlIGVsZW1lbnRcclxuICogcm9vdCBmb3IgYXR0cnMgYW5kIHNjb3BlIGlkIHByb2Nlc3NpbmcuXHJcbiAqL1xyXG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuKTtcclxuICAgIGlmICghY2hpbGRSb290KSB7XHJcbiAgICAgICAgcmV0dXJuIFt2bm9kZSwgdW5kZWZpbmVkXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xyXG4gICAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xyXG4gICAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xyXG4gICAgICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xyXG59O1xyXG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgc2luZ2xlUm9vdDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAvLyBpZ25vcmUgdXNlciBjb21tZW50XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50JDEgfHwgY2hpbGQuY2hpbGRyZW4gPT09ICd2LWlmJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9yZSB0aGFuIDEgbm9uLWNvbW1lbnQgY2hpbGQsIHJldHVybiBub3dcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2luZ2xlUm9vdDtcclxufVxyXG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcclxuICAgIGxldCByZXM7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICByZXR1cm4gKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgdm5vZGUudHlwZSA9PT0gQ29tbWVudCQxIC8vIHBvdGVudGlhbCB2LWlmIGJyYW5jaCBzd2l0Y2hcclxuICAgICk7XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xyXG4gICAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcclxuICAgIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcclxuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXHJcbiAgICAvLyBjYXVzZWQgdGhlIGNoaWxkIGNvbXBvbmVudCdzIHNsb3RzIGNvbnRlbnQgdG8gaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmb3JjZSB0aGUgY2hpbGQgdG8gdXBkYXRlIGFzIHdlbGwuXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxyXG4gICAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLykge1xyXG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgdGhhdCByZWZlcmVuY2VzIHZhbHVlcyB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHRha2VuIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xyXG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcclxuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcclxuKSB7XHJcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XHJcbi8vIFN1c3BlbnNlIGV4cG9zZXMgYSBjb21wb25lbnQtbGlrZSBBUEksIGFuZCBpcyB0cmVhdGVkIGxpa2UgYSBjb21wb25lbnRcclxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3NcclxuLy8gZGlyZWN0bHkgaW50byB0aGUgcmVuZGVyZXIuXHJcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcclxuICAgIG5hbWU6ICdTdXNwZW5zZScsXHJcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XHJcbiAgICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xyXG4gICAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXHJcbiAgICAvLyBpbnRlcm5hbHMuXHJcbiAgICBfX2lzU3VzcGVuc2U6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgXHJcbiAgICAvLyBwbGF0Zm9ybS1zcGVjaWZpYyBpbXBsIHBhc3NlZCBmcm9tIHJlbmRlcmVyXHJcbiAgICByZW5kZXJlckludGVybmFscykge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50U3VzcGVuc2UobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxyXG4gICAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5LFxyXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXHJcbn07XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbFxyXG4gICAgKTtcclxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSk7XHJcbiAgICAvLyBzdGFydCBtb3VudGluZyB0aGUgY29udGVudCBzdWJ0cmVlIGluIGFuIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICBwYXRjaChudWxsLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIGhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbnkgYXN5bmMgZGVwc1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XHJcbiAgICAgICAgLy8gaGFzIGFzeW5jXHJcbiAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBTdXNwZW5zZSBoYXMgbm8gYXN5bmMgZGVwcy4gSnVzdCByZXNvbHZlLlxyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAobjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZSk7XHJcbiAgICBzdXNwZW5zZS52bm9kZSA9IG4yO1xyXG4gICAgbjIuZWwgPSBuMS5lbDtcclxuICAgIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcclxuICAgIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcclxuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcclxuICAgIGlmIChwZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gc2FtZSByb290IHR5cGUgYnV0IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgcGF0Y2gocGVuZGluZ0JyYW5jaCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRvZ2dsZWQgYmVmb3JlIHBlbmRpbmcgdHJlZSBpcyByZXNvbHZlZFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcclxuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b2dnbGVkIGJlZm9yZSBoeWRyYXRpb24gaXMgZmluaXNoZWQsIHRoZSBjdXJyZW50IERPTSB0cmVlIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdmFsaWQuIHNldCBpdCBhcyB0aGUgYWN0aXZlIGJyYW5jaCBzbyBpdCB3aWxsIGJlIHVubW91bnRlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBwZW5kaW5nIElELiB0aGlzIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSBhc3luYyBjYWxsYmFja3NcclxuICAgICAgICAgICAgLy8gcmVzZXQgc3VzcGVuc2Ugc3RhdGVcclxuICAgICAgICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgZWZmZWN0cyBmcm9tIHBlbmRpbmcgYnJhbmNoXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaW4gZmFsbGJhY2sgc3RhdGVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlZCBcImJhY2tcIiB0byBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHJlc29sdmVcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hlZCB0byBhIDNyZCBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyByb290IGRpZCBub3QgY2hhbmdlLCBqdXN0IG5vcm1hbCBwYXRjaFxyXG4gICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSB0b2dnbGVkXHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcGVuZGluZyBldmVudFxyXG4gICAgICAgICAgICBjb25zdCBvblBlbmRpbmcgPSBuMi5wcm9wcyAmJiBuMi5wcm9wcy5vblBlbmRpbmc7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uUGVuZGluZykpIHtcclxuICAgICAgICAgICAgICAgIG9uUGVuZGluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1vdW50IHBlbmRpbmcgYnJhbmNoIGluIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5jb21pbmcgYnJhbmNoIGhhcyBubyBhc3luYyBkZXBzLCByZXNvbHZlIG5vdy5cclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgYGNvbnNvbGUuaW5mb2AgY2Fubm90IGJlIG51bGwgZXJyb3JcclxuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogdW5tb3VudCwgbjogbmV4dCwgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gdG9OdW1iZXIodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudGltZW91dCk7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9IHtcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIGlzU1ZHLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBoaWRkZW5Db250YWluZXIsXHJcbiAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgIGRlcHM6IDAsXHJcbiAgICAgICAgcGVuZGluZ0lkOiAwLFxyXG4gICAgICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiAtMSxcclxuICAgICAgICBhY3RpdmVCcmFuY2g6IG51bGwsXHJcbiAgICAgICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcclxuICAgICAgICBpc0luRmFsbGJhY2s6IHRydWUsXHJcbiAgICAgICAgaXNIeWRyYXRpbmcsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGVmZmVjdHM6IFtdLFxyXG4gICAgICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgcGVuZGluZ0lkLCBlZmZlY3RzLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghcmVzdW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW5pdGlhbCBhbmNob3Igb24gbW91bnRcclxuICAgICAgICAgICAgICAgIGxldCB7IGFuY2hvciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIHRyZWVcclxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmFsbGJhY2sgdHJlZSB3YXMgbW91bnRlZCwgaXQgbWF5IGhhdmUgYmVlbiBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHBhcnQgb2YgYSBwYXJlbnQgc3VzcGVuc2UuIGdldCB0aGUgbGF0ZXN0IGFuY2hvciBmb3IgaW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgY29udGVudCBmcm9tIG9mZi1kb20gY29udGFpbmVyIHRvIGFjdHVhbCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGZsdXNoIGJ1ZmZlcmVkIGVmZmVjdHNcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZVxyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xyXG4gICAgICAgICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIG1lcmdlIGJ1ZmZlcmVkIHBvc3Qgam9ic1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhhdCBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlLCBmbHVzaCBhbGwgam9ic1xyXG4gICAgICAgICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcmVzb2x2ZSBldmVudFxyXG4gICAgICAgICAgICBjb25zdCBvblJlc29sdmUgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblJlc29sdmU7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uUmVzb2x2ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9uUmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGlzU1ZHIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxyXG4gICAgICAgICAgICBjb25zdCBvbkZhbGxiYWNrID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25GYWxsYmFjaztcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25GYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgIG9uRmFsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBmYWxsYmFja1ZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xyXG4gICAgICAgICAgICB0cnVlIC8vIHNob3VsZFJlbW92ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50RmFsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW92ZShjb250YWluZXIsIGFuY2hvciwgdHlwZSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgdHlwZSk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5kZXBzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgLmFzeW5jRGVwLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jU2V0dXBSZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgd2hlbiB0aGUgc2V0dXAoKSBwcm9taXNlIHJlc29sdmVzLlxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gdW5tb3VudGVkIGJlZm9yZSByZXNvbHZlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXRyeSBmcm9tIHRoaXMgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkIGlmIGFuIHVwZGF0ZSBoYXBwZW5lZCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgZGVwIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksIHN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlLmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gc3VzcGVuc2U7XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIG5vZGUucGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIG51bGwsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIHRydWUgLyogaHlkcmF0aW5nICovKSk7XHJcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxyXG4gICAgLy8gLSBzdWNjZXNzOiBzc3IgY29udGVudCBzaG91bGQgYmUgZnVsbHkgcmVzb2x2ZWRcclxuICAgIC8vIC0gZmFpbHVyZTogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIHRoZSBmYWxsYmFjayBicmFuY2guXHJcbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XHJcbiAgICAvLyBhdHRlbXB0IHRvIGh5ZHJhdGUgdGhlIERPTSBhc3N1bWluZyBpdCBoYXMgc3VjY2VlZGVkLCBidXQgd2Ugc3RpbGxcclxuICAgIC8vIG5lZWQgdG8gY29uc3RydWN0IGEgc3VzcGVuc2UgYm91bmRhcnkgZmlyc3RcclxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlbik7XHJcbiAgICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW5cclxuICAgICAgICA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaylcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XHJcbiAgICBsZXQgYmxvY2s7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzKSkge1xyXG4gICAgICAgIGNvbnN0IGlzQ29tcGlsZWRTbG90ID0gcy5fYztcclxuICAgICAgICBpZiAoaXNDb21waWxlZFNsb3QpIHtcclxuICAgICAgICAgICAgLy8gZGlzYWJsZVRyYWNraW5nOiBmYWxzZVxyXG4gICAgICAgICAgICAvLyBhbGxvdyBibG9jayB0cmFja2luZyBmb3IgY29tcGlsZWQgc2xvdHNcclxuICAgICAgICAgICAgLy8gKHNlZSAuL2NvbXBvbmVudFJlbmRlckNvbnRleHQudHMpXHJcbiAgICAgICAgICAgIHMuX2QgPSBmYWxzZTtcclxuICAgICAgICAgICAgb3BlbkJsb2NrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPSBzKCk7XHJcbiAgICAgICAgaWYgKGlzQ29tcGlsZWRTbG90KSB7XHJcbiAgICAgICAgICAgIHMuX2QgPSB0cnVlO1xyXG4gICAgICAgICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcclxuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHMpKSB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xyXG4gICAgfVxyXG4gICAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG4gICAgaWYgKGJsb2NrKSB7XHJcbiAgICAgICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoYyA9PiBjICE9PSBzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xyXG4gICAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShmbikpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcclxuICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XHJcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XHJcbiAgICAvLyBpbiBjYXNlIHN1c3BlbnNlIGlzIHRoZSByb290IG5vZGUgb2YgYSBjb21wb25lbnQsXHJcbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdGhlIEhPQyBlbFxyXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcclxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2UgaW5oZXJpdHMgaXRzIHBhcmVudCdzIHByb3ZpZGVzIG9iamVjdFxyXG4gICAgICAgIC8vIGJ1dCB3aGVuIGl0IG5lZWRzIHRvIHByb3ZpZGUgdmFsdWVzIG9mIGl0cyBvd24sIGl0IGNyZWF0ZXMgaXRzXHJcbiAgICAgICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cclxuICAgICAgICAvLyB0aGlzIHdheSBpbiBgaW5qZWN0YCB3ZSBjYW4gc2ltcGx5IGxvb2sgdXAgaW5qZWN0aW9ucyBmcm9tIGRpcmVjdFxyXG4gICAgICAgIC8vIHBhcmVudCBhbmQgbGV0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG8gdGhlIHdvcmsuXHJcbiAgICAgICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICAgICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xyXG4gICAgICAgICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcclxuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXHJcbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyAjMjQwMFxyXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXHJcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGludGFuY2UgaXMgYXQgcm9vdFxyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaW5zdGFuY2UucGFyZW50ID09IG51bGxcclxuICAgICAgICAgICAgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXNcclxuICAgICAgICAgICAgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xyXG4gICAgICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWUoKVxyXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcclxuICAgIH1cclxufVxuXG4vLyBTaW1wbGUgZWZmZWN0LlxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XHJcbn1cclxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcclxuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XHJcbiAgICAgICAgd2FybihgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgYCArXHJcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKLCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLCBzLCBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYCArXHJcbiAgICAgICAgICAgIGBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYCk7XHJcbiAgICB9O1xyXG4gICAgbGV0IGdldHRlcjtcclxuICAgIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcclxuICAgIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XHJcbiAgICBpZiAoaXNSZWYoc291cmNlKSkge1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSAhIXNvdXJjZS5fc2hhbGxvdztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZTtcclxuICAgICAgICBkZWVwID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xyXG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKGlzUmVhY3RpdmUpO1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS5tYXAocyA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1JlZihzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHMudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsV2l0aEVycm9ySGFuZGxpbmcocywgaW5zdGFuY2UsIDIgLyogV0FUQ0hfR0VUVEVSICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtvbkludmFsaWRhdGVdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnZXR0ZXIgPSBOT09QO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiICYmIGRlZXApIHtcclxuICAgICAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2xlYW51cDtcclxuICAgIGxldCBvbkludmFsaWRhdGUgPSAoZm4pID0+IHtcclxuICAgICAgICBjbGVhbnVwID0gcnVubmVyLm9wdGlvbnMub25TdG9wID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0IC8qIFdBVENIX0NMRUFOVVAgKi8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xyXG4gICAgY29uc3Qgam9iID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghcnVubmVyLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJ1bm5lcigpO1xyXG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxyXG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNNdWx0aVNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoZmFsc2UgICkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdW5kZWZpbmVkIDogb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25JbnZhbGlkYXRlXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XHJcbiAgICAgICAgICAgIHJ1bm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBpbXBvcnRhbnQ6IG1hcmsgdGhlIGpvYiBhcyBhIHdhdGNoZXIgY2FsbGJhY2sgc28gdGhhdCBzY2hlZHVsZXIga25vd3NcclxuICAgIC8vIGl0IGlzIGFsbG93ZWQgdG8gc2VsZi10cmlnZ2VyICgjMTcyNylcclxuICAgIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xyXG4gICAgbGV0IHNjaGVkdWxlcjtcclxuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gam9iOyAvLyB0aGUgc2NoZWR1bGVyIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGRpcmVjdGx5XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGVmYXVsdDogJ3ByZSdcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UgfHwgaW5zdGFuY2UuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVByZUZsdXNoQ2Ioam9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHdpdGggJ3ByZScgb3B0aW9uLCB0aGUgZmlyc3QgY2FsbCBtdXN0IGhhcHBlbiBiZWZvcmVcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCBzbyBpdCBpcyBjYWxsZWQgc3luY2hyb25vdXNseS5cclxuICAgICAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJ1bm5lciA9IGVmZmVjdChnZXR0ZXIsIHtcclxuICAgICAgICBsYXp5OiB0cnVlLFxyXG4gICAgICAgIG9uVHJhY2ssXHJcbiAgICAgICAgb25UcmlnZ2VyLFxyXG4gICAgICAgIHNjaGVkdWxlclxyXG4gICAgfSk7XHJcbiAgICByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KHJ1bm5lciwgaW5zdGFuY2UpO1xyXG4gICAgLy8gaW5pdGlhbCBydW5cclxuICAgIGlmIChjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgam9iKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHJ1bm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QocnVubmVyLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBydW5uZXIoKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgc3RvcChydW5uZXIpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICByZW1vdmUoaW5zdGFuY2UuZWZmZWN0cywgcnVubmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHRoaXMuJHdhdGNoXHJcbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XHJcbiAgICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpXHJcbiAgICAgICAgPyBzb3VyY2UuaW5jbHVkZXMoJy4nKVxyXG4gICAgICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKVxyXG4gICAgICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxyXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICBsZXQgY2I7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICBjYiA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xyXG4gICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucywgdGhpcyk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcclxuICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBsZXQgY3VyID0gY3R4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoICYmIGN1cjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXI7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbHVlLCBzZWVuID0gbmV3IFNldCgpKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fFxyXG4gICAgICAgIHNlZW4uaGFzKHZhbHVlKSB8fFxyXG4gICAgICAgIHZhbHVlW1wiX192X3NraXBcIiAvKiBTS0lQICovXSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNlZW4uYWRkKHZhbHVlKTtcclxuICAgIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc0xlYXZpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzVW5tb3VudGluZzogZmFsc2UsXHJcbiAgICAgICAgbGVhdmluZ1ZOb2RlczogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdGF0ZTtcclxufVxyXG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XHJcbiAgICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBtb2RlOiBTdHJpbmcsXHJcbiAgICAgICAgYXBwZWFyOiBCb29sZWFuLFxyXG4gICAgICAgIHBlcnNpc3RlZDogQm9vbGVhbixcclxuICAgICAgICAvLyBlbnRlclxyXG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgLy8gbGVhdmVcclxuICAgICAgICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGFwcGVhclxyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldlRyYW5zaXRpb25LZXk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgd2FybignPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhY2sgcmVhY3Rpdml0eSBmb3IgdGhlc2UgcHJvcHMgc28gdXNlIHRoZSByYXdcclxuICAgICAgICAgICAgLy8gcHJvcHMgZm9yIGEgYml0IGJldHRlciBwZXJmXHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBtb2RlXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbW9kZSAmJiAhWydpbi1vdXQnLCAnb3V0LWluJywgJ2RlZmF1bHQnXS5pbmNsdWRlcyhtb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgY2hpbGRyZW4gaGFzIGEgZ3VhcmFudGVlZCBsZW5ndGggb2YgMS5cclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIDx0cmFuc2l0aW9uPjxrZWVwLWFsaXZlLz48L3RyYW5zaXRpb24+LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIHR5cGUgb2YgdGhlIGtlcHQtYWxpdmUgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgICAgIGlmICghaW5uZXJDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkSW5uZXJDaGlsZCA9IG9sZENoaWxkICYmIGdldEtlZXBBbGl2ZUNoaWxkKG9sZENoaWxkKTtcclxuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0VHJhbnNpdGlvbktleSB9ID0gaW5uZXJDaGlsZC50eXBlO1xyXG4gICAgICAgICAgICBpZiAoZ2V0VHJhbnNpdGlvbktleSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0VHJhbnNpdGlvbktleSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gcHJldlRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaGFuZGxlIG1vZGVcclxuICAgICAgICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiZcclxuICAgICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCQxICYmXHJcbiAgICAgICAgICAgICAgICAoIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSB8fCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb2xkIHRyZWUncyBob29rcyBpbiBjYXNlIG9mIGR5bmFtaWMgdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgYmV0d2VlbiBkaWZmZXJlbnQgdmlld3NcclxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgb2xkSW5uZXJDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhcmx5IHJlbW92YWwgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcclxuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcclxuICAgIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XHJcbiAgICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XHJcbiAgICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xyXG4gICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XHJcbn1cclxuLy8gVGhlIHRyYW5zaXRpb24gaG9va3MgYXJlIGF0dGFjaGVkIHRvIHRoZSB2bm9kZSBhcyB2bm9kZS50cmFuc2l0aW9uXHJcbi8vIGFuZCB3aWxsIGJlIGNhbGxlZCBhdCBhcHByb3ByaWF0ZSB0aW1pbmcgaW4gdGhlIHJlbmRlcmVyLlxyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IGFwcGVhciwgbW9kZSwgcGVyc2lzdGVkID0gZmFsc2UsIG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uQWZ0ZXJFbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25CZWZvcmVMZWF2ZSwgb25MZWF2ZSwgb25BZnRlckxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciwgb25BcHBlYXIsIG9uQWZ0ZXJBcHBlYXIsIG9uQXBwZWFyQ2FuY2VsbGVkIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xyXG4gICAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xyXG4gICAgICAgIGhvb2sgJiZcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDkgLyogVFJBTlNJVElPTl9IT09LICovLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBob29rcyA9IHtcclxuICAgICAgICBtb2RlLFxyXG4gICAgICAgIHBlcnNpc3RlZCxcclxuICAgICAgICBiZWZvcmVFbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHNhbWUgZWxlbWVudCAodi1zaG93KVxyXG4gICAgICAgICAgICBpZiAoZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3IgdG9nZ2xlZCBlbGVtZW50IHdpdGggc2FtZSBrZXkgKHYtaWYpXHJcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2RlICYmXHJcbiAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiZcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgZWFybHkgcmVtb3ZhbCAobm90IGNhbmNlbGxlZClcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGhvb2ssIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xyXG4gICAgICAgICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJIb29rID0gb25BZnRlckFwcGVhciB8fCBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhvb2spIHtcclxuICAgICAgICAgICAgICAgIGhvb2soZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChlbC5fZW50ZXJDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9sZWF2ZUNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPT09IHZub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPSB2bm9kZTtcclxuICAgICAgICAgICAgaWYgKG9uTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIG9uTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uTGVhdmUubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lKHZub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhvb2tzO1xyXG59XHJcbi8vIHRoZSBwbGFjZWhvbGRlciByZWFsbHkgb25seSBoYW5kbGVzIG9uZSBzcGVjaWFsIGNhc2U6IEtlZXBBbGl2ZVxyXG4vLyBpbiB0aGUgY2FzZSBvZiBhIEtlZXBBbGl2ZSBpbiBhIGxlYXZlIHBoYXNlIHdlIG5lZWQgdG8gcmV0dXJuIGEgS2VlcEFsaXZlXHJcbi8vIHBsYWNlaG9sZGVyIHdpdGggZW1wdHkgY29udGVudCB0byBhdm9pZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGZyb20gYmVpbmdcclxuLy8gdW5tb3VudGVkLlxyXG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XHJcbiAgICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XHJcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEtlZXBBbGl2ZUNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gaXNLZWVwQWxpdmUodm5vZGUpXHJcbiAgICAgICAgPyB2bm9kZS5jaGlsZHJlblxyXG4gICAgICAgICAgICA/IHZub2RlLmNoaWxkcmVuWzBdXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgICAgOiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiYgdm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XHJcbiAgICAgICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgcmV0ID0gW107XHJcbiAgICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vIGhhbmRsZSBmcmFnbWVudCBjaGlsZHJlbiBjYXNlLCBlLmcuIHYtZm9yXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8pXHJcbiAgICAgICAgICAgICAgICBrZXllZEZyYWdtZW50Q291bnQrKztcclxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbW1lbnQgcGxhY2Vob2xkZXJzIHNob3VsZCBiZSBza2lwcGVkLCBlLmcuIHYtaWZcclxuICAgICAgICBlbHNlIGlmIChrZWVwQ29tbWVudCB8fCBjaGlsZC50eXBlICE9PSBDb21tZW50JDEpIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICMxMTI2IGlmIGEgdHJhbnNpdGlvbiBjaGlsZHJlbiBsaXN0IGNvbnRhaW5zIG11bHRpcGxlIHN1YiBmcmFnbWVudHMsIHRoZXNlXHJcbiAgICAvLyBmcmFnbWVudHMgd2lsbCBiZSBtZXJnZWQgaW50byBhIGZsYXQgY2hpbGRyZW4gYXJyYXkuIFNpbmNlIGVhY2ggdi1mb3JcclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXHJcbiAgICAvLyB0aGVzZSBjaGlsZHJlbiB0byBmb3JjZSBmdWxsIGRpZmZzIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLlxyXG4gICAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTIgLyogQkFJTCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8vIGltcGxlbWVudGF0aW9uLCBjbG9zZSB0byBuby1vcFxyXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyB7IHNldHVwOiBvcHRpb25zLCBuYW1lOiBvcHRpb25zLm5hbWUgfSA6IG9wdGlvbnM7XHJcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcclxuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2FkZXIsIGxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50LCBkZWxheSA9IDIwMCwgdGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XHJcbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgbGV0IHJlc29sdmVkQ29tcDtcclxuICAgIGxldCByZXRyaWVzID0gMDtcclxuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHJpZXMrKztcclxuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcclxuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XHJcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKClcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGludGVyb3AgbW9kdWxlIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIGlmIChjb21wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xyXG4gICAgICAgIG5hbWU6ICdBc3luY0NvbXBvbmVudFdyYXBwZXInLFxyXG4gICAgICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXHJcbiAgICAgICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHVwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovLCAhZXJyb3JDb21wb25lbnQgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqLyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxyXG4gICAgICAgICAgICBpZiAoKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihjb21wID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBpcyBrZWVwLWFsaXZlLCBmb3JjZSB1cGRhdGUgc28gdGhlIGxvYWRlZCBjb21wb25lbnQnc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaXMgdGFrZW4gaW50byBhY2NvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgeyB2bm9kZTogeyByZWYsIHByb3BzLCBjaGlsZHJlbiB9IH0pIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcclxuICAgIC8vIGVuc3VyZSBpbm5lciBjb21wb25lbnQgaW5oZXJpdHMgdGhlIGFzeW5jIHdyYXBwZXIncyByZWYgb3duZXJcclxuICAgIHZub2RlLnJlZiA9IHJlZjtcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xyXG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xyXG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXHJcbiAgICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxyXG4gICAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcclxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cclxuICAgIF9faXNLZWVwQWxpdmU6IHRydWUsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8vIEtlZXBBbGl2ZSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgaW5zdGFudGlhdGVkIHJlbmRlcmVyIHZpYSB0aGVcclxuICAgICAgICAvLyBjdHggd2hlcmUgdGhlIHJlbmRlcmVyIHBhc3NlcyBpbiBpdHMgaW50ZXJuYWxzLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGV4cG9zZXMgYWN0aXZhdGUvZGVhY3RpdmF0ZSBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IG9mIHRoaXMgaXMgdG8gYXZvaWQgaW1wb3J0aW5nIEtlZXBBbGl2ZSBkaXJlY3RseSBpbiB0aGVcclxuICAgICAgICAvLyByZW5kZXJlciB0byBmYWNpbGl0YXRlIHRyZWUtc2hha2luZy5cclxuICAgICAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xyXG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcm5hbCByZW5kZXJlciBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsXHJcbiAgICAgICAgLy8gZm9yIEtlZXBBbGl2ZSwgd2UganVzdCBuZWVkIHRvIHJlbmRlciBpdHMgY2hpbGRyZW5cclxuICAgICAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNsb3RzLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xyXG4gICAgICAgIGNvbnN0IHsgcmVuZGVyZXI6IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiBfdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSB9ID0gc2hhcmVkQ29udGV4dDtcclxuICAgICAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2UgcHJvcHMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgIHBhdGNoKGluc3RhbmNlLnZub2RlLCB2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHZub2RlLnNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSAvKiBMRUFWRSAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuZGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc2hhcGVGbGFnIHNvIGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IGNhY2hlZC50eXBlICE9PSBjdXJyZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBpbnN0YW5jZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGtlcHQtYWxpdmUuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1bm1vdW50IGl0IG5vdyBidXQgaXQgbWlnaHQgYmUgbGF0ZXIsIHNvIHJlc2V0IGl0cyBmbGFnIG5vdy5cclxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcnVuZSBjYWNoZSBvbiBpbmNsdWRlL2V4Y2x1ZGUgcHJvcCBjaGFuZ2VcclxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcclxuICAgICAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgIHsgZmx1c2g6ICdwb3N0JywgZGVlcDogdHJ1ZSB9KTtcclxuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcclxuICAgICAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goY2FjaGVkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XHJcbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBjb21wb25lbnRzLCBuYW1lIGNoZWNrIHNob3VsZCBiZSBiYXNlZCBpbiBpdHMgbG9hZGVkXHJcbiAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoaXNBc3luY1dyYXBwZXIodm5vZGUpXHJcbiAgICAgICAgICAgICAgICA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9XHJcbiAgICAgICAgICAgICAgICA6IGNvbXApO1xyXG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgLy8gY2xvbmUgdm5vZGUgaWYgaXQncyByZXVzZWQgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gbXV0YXRlIGl0XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAjMTUxMyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgcmV0dXJuZWQgdm5vZGUgdG8gYmUgY2xvbmVkIGR1ZSB0byBhdHRyXHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xyXG4gICAgICAgICAgICAvLyBrZXkgYW5kIGNhY2hlIGBpbnN0YW5jZS5zdWJUcmVlYCAodGhlIG5vcm1hbGl6ZWQgdm5vZGUpIGluXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcclxuICAgICAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMga2V5IHRoZSBmcmVzaGVzdFxyXG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xyXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcclxuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0dGVybi50ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIERFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIC8vIGNhY2hlIHRoZSBkZWFjdGl2YXRlIGJyYW5jaCBjaGVjayB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZVxyXG4gICAgLy8gaG9vayBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2RjXCIgc3RhbmRzIGZvciBcIndpdGhcclxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxyXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8XHJcbiAgICAgICAgKGhvb2suX193ZGMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvb2soKTtcclxuICAgICAgICB9KTtcclxuICAgIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XHJcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcclxuICAgIC8vIGNoYWluIGFuZCByZWdpc3RlciBpdCBvbiBhbGwgYW5jZXN0b3IgaW5zdGFuY2VzIHRoYXQgYXJlIGtlZXAtYWxpdmUgcm9vdHMuXHJcbiAgICAvLyBUaGlzIGF2b2lkcyB0aGUgbmVlZCB0byB3YWxrIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUgd2hlbiBpbnZva2luZyB0aGVzZVxyXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxyXG4gICAgLy8gYXJyYXlzLlxyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XHJcbiAgICAvLyBpbmplY3RIb29rIHdyYXBzIHRoZSBvcmlnaW5hbCBmb3IgZXJyb3IgaGFuZGxpbmcsIHNvIG1ha2Ugc3VyZSB0byByZW1vdmVcclxuICAgIC8vIHRoZSB3cmFwcGVkIHZlcnNpb24uXHJcbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcclxuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xyXG4gICAgfSwgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xyXG4gICAgbGV0IHNoYXBlRmxhZyA9IHZub2RlLnNoYXBlRmxhZztcclxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLztcclxuICAgIH1cclxuICAgIHZub2RlLnNoYXBlRmxhZyA9IHNoYXBlRmxhZztcclxufVxyXG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XHJcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XHJcbiAgICAgICAgLy8gY2FjaGUgdGhlIGVycm9yIGhhbmRsaW5nIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lIGhvb2tcclxuICAgICAgICAvLyBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2VoXCIgc3RhbmRzIGZvciBcIndpdGggZXJyb3JcclxuICAgICAgICAvLyBoYW5kbGluZ1wiLlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fFxyXG4gICAgICAgICAgICAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSB0cmFja2luZyBpbnNpZGUgYWxsIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRJbnN0YW5jZSBkdXJpbmcgaG9vayBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBob29rIGRvZXMgbm90IHN5bmNocm9ub3VzbHkgdHJpZ2dlciBvdGhlciBob29rcywgd2hpY2hcclxuICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IGJlIGZhbHNlIHdoZW4gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgcmVhbGx5IGZ1bmt5LlxyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHByZXBlbmQpIHtcclxuICAgICAgICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRIb29rO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sICcnKSk7XHJcbiAgICAgICAgd2FybihgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGAgK1xyXG4gICAgICAgICAgICBgYXNzb2NpYXRlZCB3aXRoLiBgICtcclxuICAgICAgICAgICAgYExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICtcclxuICAgICAgICAgICAgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gXHJcbiAgICAgICAgICAgICAgICApKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4gXHJcbi8vIHBvc3QtY3JlYXRlIGxpZmVjeWNsZSByZWdpc3RyYXRpb25zIGFyZSBub29wcyBkdXJpbmcgU1NSIChleGNlcHQgZm9yIHNlcnZlclByZWZldGNoKVxyXG4oIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pICYmXHJcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgaG9vaywgdGFyZ2V0KTtcclxuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiIC8qIEJFRk9SRV9NT1VOVCAqLyk7XHJcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIgLyogTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqLyk7XHJcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIgLyogVVBEQVRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIiAvKiBCRUZPUkVfVU5NT1VOVCAqLyk7XHJcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIgLyogVU5NT1VOVEVEICovKTtcclxuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXCJzcFwiIC8qIFNFUlZFUl9QUkVGRVRDSCAqLyk7XHJcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiIC8qIFJFTkRFUl9UUklHR0VSRUQgKi8pO1xyXG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIgLyogUkVOREVSX1RSQUNLRUQgKi8pO1xyXG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpbmplY3RIb29rKFwiZWNcIiAvKiBFUlJPUl9DQVBUVVJFRCAqLywgaG9vaywgdGFyZ2V0KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcclxuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xyXG4gICAgICAgICAgICB3YXJuKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWNoZVtrZXldID0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XHJcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcclxuICAgIC8vIGRvIG5vdCBjYWNoZSBwcm9wZXJ0eSBhY2Nlc3Mgb24gcHVibGljIHByb3h5IGR1cmluZyBzdGF0ZSBpbml0aWFsaXphdGlvblxyXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcclxuICAgIC8vIGNhbGwgYmVmb3JlQ3JlYXRlIGZpcnN0IGJlZm9yZSBhY2Nlc3Npbmcgb3RoZXIgb3B0aW9ucyBzaW5jZVxyXG4gICAgLy8gdGhlIGhvb2sgbWF5IG11dGF0ZSByZXNvbHZlZCBvcHRpb25zICgjMjc5MSlcclxuICAgIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xyXG4gICAgICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi8pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBcclxuICAgIC8vIHN0YXRlXHJcbiAgICBkYXRhOiBkYXRhT3B0aW9ucywgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucywgbWV0aG9kcywgd2F0Y2g6IHdhdGNoT3B0aW9ucywgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsIGluamVjdDogaW5qZWN0T3B0aW9ucywgXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGNyZWF0ZWQsIGJlZm9yZU1vdW50LCBtb3VudGVkLCBiZWZvcmVVcGRhdGUsIHVwZGF0ZWQsIGFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQsIGJlZm9yZURlc3Ryb3ksIGJlZm9yZVVubW91bnQsIGRlc3Ryb3llZCwgdW5tb3VudGVkLCByZW5kZXIsIHJlbmRlclRyYWNrZWQsIHJlbmRlclRyaWdnZXJlZCwgZXJyb3JDYXB0dXJlZCwgc2VydmVyUHJlZmV0Y2gsIFxyXG4gICAgLy8gcHVibGljIEFQSVxyXG4gICAgZXhwb3NlLCBpbmhlcml0QXR0cnMsIFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBmaWx0ZXJzIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgICAgICBpZiAocHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgaW5pdGlhbGl6YXRpb24gb3JkZXIgKHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBWdWUgMik6XHJcbiAgICAvLyAtIHByb3BzIChhbHJlYWR5IGRvbmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uKVxyXG4gICAgLy8gLSBpbmplY3RcclxuICAgIC8vIC0gbWV0aG9kc1xyXG4gICAgLy8gLSBkYXRhIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIC8vIC0gY29tcHV0ZWRcclxuICAgIC8vIC0gd2F0Y2ggKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxyXG4gICAgaWYgKGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyk7XHJcbiAgICB9XHJcbiAgICBpZiAobWV0aG9kcykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obWV0aG9kSGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluIGRldiBtb2RlLCB3ZSB1c2UgdGhlIGBjcmVhdGVSZW5kZXJDb250ZXh0YCBmdW5jdGlvbiB0byBkZWZpbmUgbWV0aG9kcyB0byB0aGUgcHJveHkgdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRob3NlIGFyZSByZWFkLW9ubHkgYnV0IHJlY29uZmlndXJhYmxlLCBzbyBpdCBuZWVkcyB0byBiZSByZWRlZmluZWQgaGVyZVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRhdGFPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihkYXRhT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gYCArXHJcbiAgICAgICAgICAgICAgICBgUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNQcm9taXNlKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBgICtcclxuICAgICAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvc2UgZGF0YSBvbiBjdHggZHVyaW5nIGRldlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICckJyAmJiBrZXlbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzdGF0ZSBpbml0aWFsaXphdGlvbiBjb21wbGV0ZSBhdCB0aGlzIHBvaW50IC0gc3RhcnQgY2FjaGluZyBhY2Nlc3NcclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcclxuICAgIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KVxyXG4gICAgICAgICAgICAgICAgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ2V0ID09PSBOT09QKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgICAgICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xyXG4gICAgICAgICAgICAgICAgZ2V0LFxyXG4gICAgICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGMudmFsdWUgPSB2KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwcm92aWRlT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucylcclxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbnM7XHJcbiAgICAgICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChjcmVhdGVkKSB7XHJcbiAgICAgICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiIC8qIENSRUFURUQgKi8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICAgICAgaG9vay5mb3JFYWNoKF9ob29rID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XHJcbiAgICBpZiAoaXNBcnJheShleHBvc2UpKSB7XHJcbiAgICAgICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSBwcm94eVJlZnMoe30pKTtcclxuICAgICAgICAgICAgZXhwb3NlLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIGV4cG9zZWRba2V5XSA9IHRvUmVmKHB1YmxpY1RoaXMsIGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCB3aGVuIGNyZWF0aW5nIHRoZSBpbnN0YW5jZSBidXQgYWxzbyBuZWVkIHRvIGJlXHJcbiAgICAvLyBhcHBsaWVkIGZyb20gbWl4aW5zXHJcbiAgICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIH1cclxuICAgIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xyXG4gICAgICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcclxuICAgIH1cclxuICAgIC8vIGFzc2V0IG9wdGlvbnMuXHJcbiAgICBpZiAoY29tcG9uZW50cylcclxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuICAgIGlmIChkaXJlY3RpdmVzKVxyXG4gICAgICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xyXG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcclxuICAgICAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcclxuICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xyXG4gICAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIG9wdCkge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3Qob3B0LmZyb20gfHwga2V5LCBvcHQuZGVmYXVsdCwgdHJ1ZSAvKiB0cmVhdCBkZWZhdWx0IGZ1bmN0aW9uIGFzIGZhY3RvcnkgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3Qob3B0LmZyb20gfHwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3Qob3B0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBJTkpFQ1QgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhpc0FycmF5KGhvb2spXHJcbiAgICAgICAgPyBob29rLm1hcChoID0+IGguYmluZChpbnN0YW5jZS5wcm94eSkpXHJcbiAgICAgICAgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLCBpbnN0YW5jZSwgdHlwZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XHJcbiAgICBjb25zdCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoJy4nKVxyXG4gICAgICAgID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpXHJcbiAgICAgICAgOiAoKSA9PiBwdWJsaWNUaGlzW2tleV07XHJcbiAgICBpZiAoaXNTdHJpbmcocmF3KSkge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xyXG4gICAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICAgICAgcmF3LmZvckVhY2gociA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbihyYXcuaGFuZGxlcilcclxuICAgICAgICAgICAgICAgID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiBjdHhbcmF3LmhhbmRsZXJdO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmUgbWVyZ2VkIG9wdGlvbnMgYW5kIGNhY2hlIGl0IG9uIHRoZSBjb21wb25lbnQuXHJcbiAqIFRoaXMgaXMgZG9uZSBvbmx5IG9uY2UgcGVyLWNvbXBvbmVudCBzaW5jZSB0aGUgbWVyZ2luZyBkb2VzIG5vdCBpbnZvbHZlXHJcbiAqIGluc3RhbmNlcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBiYXNlID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcclxuICAgIGNvbnN0IHsgbWl4aW5zOiBnbG9iYWxNaXhpbnMsIG9wdGlvbnNDYWNoZTogY2FjaGUsIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfSB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcclxuICAgIGxldCByZXNvbHZlZDtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXNvbHZlZCA9IGNhY2hlZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXNvbHZlZCA9IGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzb2x2ZWQgPSB7fTtcclxuICAgICAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChtID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgYmFzZSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzKTtcclxuICAgIH1cclxuICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XHJcbiAgICByZXR1cm4gcmVzb2x2ZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xyXG4gICAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XHJcbiAgICAgICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGlmIChtaXhpbnMpIHtcclxuICAgICAgICBtaXhpbnMuZm9yRWFjaCgobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcclxuICAgICAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09ICdleHBvc2UnKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IChzdHJhdHMgJiYgc3RyYXRzW2tleV0pO1xyXG4gICAgICAgICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0bztcclxufVxyXG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xyXG4gICAgZGF0YTogbWVyZ2VEYXRhRm4sXHJcbiAgICBwcm9wczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgZW1pdHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIC8vIG9iamVjdHNcclxuICAgIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGJlZm9yZUNyZWF0ZTogbWVyZ2VIb29rLFxyXG4gICAgY3JlYXRlZDogbWVyZ2VIb29rLFxyXG4gICAgYmVmb3JlTW91bnQ6IG1lcmdlSG9vayxcclxuICAgIG1vdW50ZWQ6IG1lcmdlSG9vayxcclxuICAgIGJlZm9yZVVwZGF0ZTogbWVyZ2VIb29rLFxyXG4gICAgdXBkYXRlZDogbWVyZ2VIb29rLFxyXG4gICAgYmVmb3JlRGVzdHJveTogbWVyZ2VIb29rLFxyXG4gICAgZGVzdHJveWVkOiBtZXJnZUhvb2ssXHJcbiAgICBhY3RpdmF0ZWQ6IG1lcmdlSG9vayxcclxuICAgIGRlYWN0aXZhdGVkOiBtZXJnZUhvb2ssXHJcbiAgICBlcnJvckNhcHR1cmVkOiBtZXJnZUhvb2ssXHJcbiAgICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VIb29rLFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyB3YXRjaCBoYXMgc3BlY2lhbCBtZXJnZSBiZWhhdmlvciBpbiB2MiwgYnV0IGlzbid0IGFjdHVhbGx5IG5lZWRlZCBpbiB2My5cclxuICAgIC8vIHNpbmNlIHdlIGFyZSBvbmx5IGV4cG9zaW5nIHRoZXNlIGZvciBjb21wYXQgYW5kIG5vYm9keSBzaG91bGQgYmUgcmVseWluZ1xyXG4gICAgLy8gb24gdGhlIHdhdGNoLXNwZWNpZmljIGJlaGF2aW9yLCBqdXN0IGV4cG9zZSB0aGUgb2JqZWN0IG1lcmdlIHN0cmF0LlxyXG4gICAgd2F0Y2g6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIC8vIHByb3ZpZGUgLyBpbmplY3RcclxuICAgIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxyXG4gICAgaW5qZWN0OiBtZXJnZUluamVjdFxyXG59O1xyXG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xyXG4gICAgaWYgKCFmcm9tKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0bykge1xyXG4gICAgICAgIHJldHVybiBmcm9tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcclxuICAgICAgICByZXR1cm4gKGV4dGVuZCkoaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcclxuICAgIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSG9vayh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcclxuICAgIHJldHVybiB0byA/IGV4dGVuZChleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pLCBmcm9tKSA6IGZyb207XHJcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgLy8gcmVzdWx0IG9mIGJpdHdpc2UgZmxhZyBjb21wYXJpc29uXHJcbmlzU1NSID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHByb3BzID0ge307XHJcbiAgICBjb25zdCBhdHRycyA9IHt9O1xyXG4gICAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XHJcbiAgICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XHJcbiAgICAvLyBlbnN1cmUgYWxsIGRlY2xhcmVkIHByb3Aga2V5cyBhcmUgcHJlc2VudFxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHZhbGlkYXRpb25cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RhdGVmdWwpIHtcclxuICAgICAgICAvLyBzdGF0ZWZ1bFxyXG4gICAgICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBvcHRpb25hbCBwcm9wcywgcHJvcHMgPT09IGF0dHJzXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIGRlY2xhcmVkIHByb3BzXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UuYXR0cnMgPSBhdHRycztcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHJhd1ByZXZQcm9wcywgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzLCBhdHRycywgdm5vZGU6IHsgcGF0Y2hGbGFnIH0gfSA9IGluc3RhbmNlO1xyXG4gICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgY29uc3QgW29wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgaWYgKFxyXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcclxuICAgIC8vIC0gIzE5NDIgaWYgaG1yIGlzIGVuYWJsZWQgd2l0aCBzZmMgY29tcG9uZW50XHJcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxyXG4gICAgISgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAoaW5zdGFuY2UudHlwZS5fX2htcklkIHx8XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5wYXJlbnQgJiYgaW5zdGFuY2UucGFyZW50LnR5cGUuX19obXJJZCkpKSAmJlxyXG4gICAgICAgIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiZcclxuICAgICAgICAhKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgLy8gQ29tcGlsZXItZ2VuZXJhdGVkIHByb3BzICYgbm8ga2V5cyBjaGFuZ2UsIGp1c3Qgc2V0IHRoZSB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIHRoZSBwcm9wcy5cclxuICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgIC8vIFBST1BTIGZsYWcgZ3VhcmFudGVlcyByYXdQcm9wcyB0byBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyIC8gcHJvcHMgc2VwYXJhdGlvbiB3YXMgZG9uZSBvbiBpbml0IGFuZCB3aWxsIGJlIGNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNvZGUgcGF0aCwgc28ganVzdCBjaGVjayBpZiBhdHRycyBoYXZlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGNhbWVsaXplZEtleSwgdmFsdWUsIGluc3RhbmNlLCBmYWxzZSAvKiBpc0Fic2VudCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBmdWxsIHByb3BzIHVwZGF0ZS5cclxuICAgICAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xyXG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiBjYXNlIG9mIGR5bmFtaWMgcHJvcHMsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIGtleXMgZnJvbVxyXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcclxuICAgICAgICBsZXQga2ViYWJLZXk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcclxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXHJcbiAgICAgICAgICAgICAgICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UsIHRydWUgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bmN0aW9uYWwgY29tcG9uZW50IHcvbyBwcm9wcyBkZWNsYXJhdGlvbiwgcHJvcHMgYW5kXHJcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHJpZ2dlciB1cGRhdGVzIGZvciAkYXR0cnMgaW4gY2FzZSBpdCdzIHVzZWQgaW4gY29tcG9uZW50IHNsb3RzXHJcbiAgICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XHJcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiAvKiBTRVQgKi8sICckYXR0cnMnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xyXG4gICAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBsZXQgcmF3Q2FzdFZhbHVlcztcclxuICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICAvLyBrZXksIHJlZiBhcmUgcmVzZXJ2ZWQgYW5kIG5ldmVyIHBhc3NlZCBkb3duXHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgIC8vIHByb3Agb3B0aW9uIG5hbWVzIGFyZSBjYW1lbGl6ZWQgZHVyaW5nIG5vcm1hbGl6YXRpb24sIHNvIHRvIHN1cHBvcnRcclxuICAgICAgICAgICAgLy8ga2ViYWIgLT4gY2FtZWwgY29udmVyc2lvbiBoZXJlIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIGtleS5cclxuICAgICAgICAgICAgbGV0IGNhbWVsS2V5O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgKGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRDYXN0S2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgY2FzdFZhbHVlc1trZXldLCBpbnN0YW5jZSwgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgaWYgKG9wdCAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXNcclxuICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKG51bGwsIHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBib29sZWFuIGNhc3RpbmdcclxuICAgICAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcclxuICAgICAgICAgICAgaWYgKGlzQWJzZW50ICYmICFoYXNEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJlxyXG4gICAgICAgICAgICAgICAgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XHJcbiAgICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcclxuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcclxuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdykgPT4ge1xyXG4gICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAoa2V5cylcclxuICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xyXG4gICAgICAgICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcclxuICAgICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcclxuICAgICAgICByZXR1cm4gRU1QVFlfQVJSO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzU3RyaW5nKHJhd1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShyYXdbaV0pO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJhdykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICAgICAgd2FybihgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gKG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogb3B0KTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BbMCAvKiBzaG91bGRDYXN0ICovXSA9IGJvb2xlYW5JbmRleCA+IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByb3AgbmVlZHMgYm9vbGVhbiBjYXN0aW5nIG9yIGRlZmF1bHQgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEgfHwgaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2gobm9ybWFsaXplZEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wTmFtZShrZXkpIHtcclxuICAgIGlmIChrZXlbMF0gIT09ICckJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyB1c2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgdHlwZSBjb25zdHJ1Y3RvcnNcclxuLy8gc28gdGhhdCBpdCB3b3JrcyBhY3Jvc3Mgdm1zIC8gaWZyYW1lcy5cclxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IGN0b3IgJiYgY3Rvci50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xyXG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBpZiAoaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBleHBlY3RlZFR5cGVzLmZpbmRJbmRleCh0ID0+IGlzU2FtZVR5cGUodCwgdHlwZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICBpZiAob3B0ID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcChrZXksIHJlc29sdmVkVmFsdWVzW2tleV0sIG9wdCwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yIH0gPSBwcm9wO1xyXG4gICAgLy8gcmVxdWlyZWQhXHJcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcclxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtaXNzaW5nIGJ1dCBvcHRpb25hbFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0eXBlIGNoZWNrXHJcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xyXG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xyXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIGxldCB2YWxpZDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcclxuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcclxuICAgICAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xyXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpfWA7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXHJcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXHJcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xyXG4gICAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XHJcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xyXG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09ICdfJyB8fCBrZXkgPT09ICckc3RhYmxlJztcclxuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKVxyXG4gICAgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpXHJcbiAgICA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xyXG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgocHJvcHMpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IGAgK1xyXG4gICAgICAgICAgICAgICAgYHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QocHJvcHMpKTtcclxuICAgIH0sIGN0eCk7XHJcbiAgICBub3JtYWxpemVkLl9jID0gZmFsc2U7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xyXG4gICAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XHJcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICEoZmFsc2UgKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBzbG90IFwiJHtrZXl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiZcclxuICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gYCArXHJcbiAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xyXG4gICAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XHJcbn07XHJcbmNvbnN0IGluaXRTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZXJzIGNhbiBnZXQgdGhlIHNoYWxsb3cgcmVhZG9ubHkgdmVyc2lvbiBvZiB0aGUgc2xvdHMgb2JqZWN0IHRocm91Z2ggYHRoaXMuJHNsb3RzYCxcclxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGF2b2lkIHRoZSBwcm94eSBvYmplY3QgcG9sbHV0aW5nIHRoZSBzbG90cyBvZiB0aGUgaW50ZXJuYWwgaW5zdGFuY2VcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB0b1JhdyhjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIC8vIG1ha2UgY29tcGlsZXIgbWFya2VyIG5vbi1lbnVtZXJhYmxlXHJcbiAgICAgICAgICAgIGRlZihjaGlsZHJlbiwgJ18nLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCAoaW5zdGFuY2Uuc2xvdHMgPSB7fSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLnNsb3RzID0ge307XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWYoaW5zdGFuY2Uuc2xvdHMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxufTtcclxuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XHJcbiAgICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gY29tcGlsZWQgc2xvdHMuXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IHdhcyBITVIgdXBkYXRlZCBzbyBzbG90IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBzbG90cyBhbmQgbWFyayBpbnN0YW5jZSBmb3IgaG1yIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgQU5EIHN0YWJsZS5cclxuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdXBkYXRlLCBhbmQgc2tpcCBzdGFsZSBzbG90cyByZW1vdmFsLlxyXG4gICAgICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIGJ1dCBkeW5hbWljICh2LWlmL3YtZm9yIG9uIHNsb3RzKSAtIHVwZGF0ZSBzbG90cywgYnV0IHNraXBcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIC8vICMyODkzXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlbmRlcmluZyB0aGUgb3B0aW1pemVkIHNsb3RzIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxldGUgdGhlIGBzbG90cy5fYCBmbGFnIGlmIG5lY2Vzc2FyeSB0byBtYWtlIHN1YnNlcXVlbnQgdXBkYXRlcyByZWxpYWJsZSxcclxuICAgICAgICAgICAgICAgIC8vIGkuZS4gbGV0IHRoZSBgcmVuZGVyU2xvdGAgY3JlYXRlIHRoZSBiYWlsZWQgRnJhZ21lbnRcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzLl87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAvLyBub24gc2xvdCBvYmplY3QgY2hpbGRyZW4gKGRpcmVjdCB2YWx1ZSkgcGFzc2VkIHRvIGEgY29tcG9uZW50XHJcbiAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xyXG4gICAgfVxyXG4gICAgLy8gZGVsZXRlIHN0YWxlIHNsb3RzXHJcbiAgICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xyXG4gICAgICAgICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiAhKGtleSBpbiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcblxuLyoqXHJcblJ1bnRpbWUgaGVscGVyIGZvciBhcHBseWluZyBkaXJlY3RpdmVzIHRvIGEgdm5vZGUuIEV4YW1wbGUgdXNhZ2U6XHJcblxuY29uc3QgY29tcCA9IHJlc29sdmVDb21wb25lbnQoJ2NvbXAnKVxyXG5jb25zdCBmb28gPSByZXNvbHZlRGlyZWN0aXZlKCdmb28nKVxyXG5jb25zdCBiYXIgPSByZXNvbHZlRGlyZWN0aXZlKCdiYXInKVxyXG5cbnJldHVybiB3aXRoRGlyZWN0aXZlcyhoKGNvbXApLCBbXHJcbiAgW2ZvbywgdGhpcy54XSxcclxuICBbYmFyLCB0aGlzLnldXHJcbl0pXHJcbiovXHJcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQnKTtcclxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcclxuICAgIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcclxuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogJyArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGRpcmVjdGl2ZXMgdG8gYSBWTm9kZS5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBkaXJlY3RpdmVzKSB7XHJcbiAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2Fybihgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xyXG4gICAgICAgICAgICBkaXIgPSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudGVkOiBkaXIsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkOiBkaXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGRpcixcclxuICAgICAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVyc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcclxuICAgIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcclxuICAgICAgICBpZiAob2xkQmluZGluZ3MpIHtcclxuICAgICAgICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xyXG4gICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4IC8qIERJUkVDVElWRV9IT09LICovLCBbXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCxcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICAgIHByZXZWTm9kZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhcHA6IG51bGwsXHJcbiAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgIGlzTmF0aXZlVGFnOiBOTyxcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcclxuICAgICAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHdhcm5IYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1peGluczogW10sXHJcbiAgICAgICAgY29tcG9uZW50czoge30sXHJcbiAgICAgICAgZGlyZWN0aXZlczoge30sXHJcbiAgICAgICAgcHJvdmlkZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgICAgb3B0aW9uc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIHByb3BzQ2FjaGU6IG5ldyBXZWFrTWFwKCksXHJcbiAgICAgICAgZW1pdHNDYWNoZTogbmV3IFdlYWtNYXAoKVxyXG4gICAgfTtcclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcclxuICAgICAgICAgICAgcm9vdFByb3BzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XHJcbiAgICAgICAgICAgIF91aWQ6IHVpZCsrLFxyXG4gICAgICAgICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcclxuICAgICAgICAgICAgX2NvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgIHZlcnNpb24sXHJcbiAgICAgICAgICAgIGdldCBjb25maWcoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCBjb25maWcodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtaXhpbihtaXhpbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogJycpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBpc1NWRykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwIGNvbnRleHQgb24gdGhlIHJvb3QgVk5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHNldCBvbiB0aGUgcm9vdCBpbnN0YW5jZSBvbiBpbml0aWFsIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhNUiByb290IHJlbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZS5jb21wb25lbnQucHJveHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bm1vdW50KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgYWxsb3cgc3ltYm9scyBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI0NTg3XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgfTtcclxufVxuXG5sZXQgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiAvc3ZnLy50ZXN0KGNvbnRhaW5lci5uYW1lc3BhY2VVUkkpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENPTU1FTlQgKi87XHJcbi8vIE5vdGU6IGh5ZHJhdGlvbiBpcyBET00tc3BlY2lmaWNcclxuLy8gQnV0IHdlIGhhdmUgdG8gcGxhY2UgaXQgaW4gY29yZSBkdWUgdG8gdGlnaHQgY291cGxpbmcgd2l0aCBjb3JlIC0gc3BsaXR0aW5nXHJcbi8vIGl0IG91dCBjcmVhdGVzIGEgdG9uIG9mIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkuXHJcbi8vIEh5ZHJhdGlvbiBhbHNvIGRlcGVuZHMgb24gc29tZSByZW5kZXJlciBpbnRlcm5hbCBsb2dpYyB3aGljaCBuZWVkcyB0byBiZVxyXG4vLyBwYXNzZWQgaW4gdmlhIGFyZ3VtZW50cy5cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IG10OiBtb3VudENvbXBvbmVudCwgcDogcGF0Y2gsIG86IHsgcGF0Y2hQcm9wLCBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcmVtb3ZlLCBpbnNlcnQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gYCArXHJcbiAgICAgICAgICAgICAgICBgUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc01pc21hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICAgIGlmIChoYXNNaXNtYXRjaCAmJiAhZmFsc2UpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBlcnJvciBzaG91bGQgc2hvdyB1cCBpbiBwcm9kdWN0aW9uXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snO1xyXG4gICAgICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50U3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGNvbnN0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xyXG4gICAgICAgIHZub2RlLmVsID0gbm9kZTtcclxuICAgICAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMyAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gQ2xpZW50OiAke0pTT04uc3RyaW5naWZ5KG5vZGUuZGF0YSl9YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50JDE6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovIHx8IGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBhbmNob3IsIGFkb3B0IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRpYyB2bm9kZSBoYXMgaXRzIGNvbnRlbnQgc3RyaXBwZWQgZHVyaW5nIGJ1aWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkb3B0IGl0IGZyb20gdGhlIHNlcnZlci1yZW5kZXJlZCBIVE1MLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPSBuZXh0Tm9kZS5vdXRlckhUTUw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcclxuICAgICAgICAgICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyB1cCB0aGUgcmVuZGVyIGVmZmVjdCwgaWYgdGhlIGluaXRpYWwgdm5vZGUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyAuZWwgc2V0LCB0aGUgY29tcG9uZW50IHdpbGwgcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGl0cyBzdWItdHJlZS5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudCh2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgYmUgYXN5bmMsIHNvIGluIHRoZSBjYXNlIG9mIGZyYWdtZW50cyB3ZSBjYW5ub3QgcmVseVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGNvbXBvbmVudCdzIHJlbmRlcmVkIG91dHB1dCB0byBkZXRlcm1pbmUgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLCB3ZSBkbyBhIGxvb2thaGVhZCB0byBmaW5kIHRoZSBlbmQgYW5jaG9yIG5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBpc0ZyYWdtZW50U3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjMzc4N1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbXBvbmVudCBpcyBhc3luYywgaXQgbWF5IGdldCBtb3ZlZCAvIHVubW91bnRlZCBiZWZvcmUgaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5uZXIgY29tcG9uZW50IGlzIGxvYWRlZCwgc28gd2UgbmVlZCB0byBnaXZlIGl0IGEgcGxhY2Vob2xkZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSB0aGF0IG1hdGNoZXMgaXRzIGFkb3B0ZWQgRE9NLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKCcnKSA6IGNyZWF0ZVZOb2RlKCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUgPSBzdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSG9zdFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyBza2lwIHByb3BzICYgY2hpbGRyZW4gaWYgdGhpcyBpcyBob2lzdGVkIHN0YXRpYyBub2Rlc1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgIT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW1pemVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmIGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25DbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgY2xpY2sgbGlzdGVuZXJzICh3aGljaCBpcyBtb3N0IG9mdGVuKSB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGluZyB0aHJvdWdoIHByb3BzLlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwgJ29uQ2xpY2snLCBudWxsLCBwcm9wcy5vbkNsaWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2bm9kZSAvIGRpcmVjdGl2ZSBob29rc1xyXG4gICAgICAgICAgICBsZXQgdm5vZGVIb29rcztcclxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hpbGRyZW5cclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovICYmXHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XHJcbiAgICAgICAgICAgICAgICAhKHByb3BzICYmIChwcm9wcy5pbm5lckhUTUwgfHwgcHJvcHMudGV4dENvbnRlbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oZWwuZmlyc3RDaGlsZCwgdm5vZGUsIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgU1NSZWQgRE9NIGNvbnRhaW5zIG1vcmUgbm9kZXMgdGhhbiBpdCBzaG91bGQuIFJlbW92ZSB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjpcXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIFNlcnZlcjogJHt2bm9kZS5jaGlsZHJlbn1gKTtcclxuICAgICAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbC5uZXh0U2libGluZztcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbltpXVxyXG4gICAgICAgICAgICAgICAgOiAoY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke2NvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgU1NSZWQgRE9NIGRpZG4ndCBjb250YWluIGVub3VnaCBub2Rlcy4gTW91bnQgdGhlIG1pc3Npbmcgb25lcy5cclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xyXG4gICAgICAgICAgICAgICAgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKVxyXG4gICAgICAgICAgICAgICAgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZygodm5vZGUuYW5jaG9yID0gbmV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnJhZ21lbnQgZGlkbid0IGh5ZHJhdGUgc3VjY2Vzc2Z1bGx5LCBzaW5jZSB3ZSBkaWRuJ3QgZ2V0IGEgZW5kIGFuY2hvclxyXG4gICAgICAgICAgICAvLyBiYWNrLiBUaGlzIHNob3VsZCBoYXZlIGxlZCB0byBub2RlL2NoaWxkcmVuIG1pc21hdGNoIHdhcm5pbmdzLlxyXG4gICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBhbmNob3IgaXMgbWlzc2luZywgd2UgbmVlZCB0byBjcmVhdGUgb25lIGFuZCBpbnNlcnQgaXRcclxuICAgICAgICAgICAgaW5zZXJ0KCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCkpLCBjb250YWluZXIsIG5leHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xyXG4gICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XFxuLSBDbGllbnQgdm5vZGU6YCwgdm5vZGUudHlwZSwgYFxcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLCBub2RlLCBub2RlLm5vZGVUeXBlID09PSAzIC8qIFRFWFQgKi9cclxuICAgICAgICAgICAgICAgID8gYCh0ZXh0KWBcclxuICAgICAgICAgICAgICAgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWBcclxuICAgICAgICAgICAgICAgICAgICA6IGBgKTtcclxuICAgICAgICB2bm9kZS5lbCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGlzRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4Y2Vzc2l2ZSBmcmFnbWVudCBub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICByZW1vdmUobm9kZSk7XHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbmV4dCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3IgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICdbJylcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xyXG59XG5cbmxldCBzdXBwb3J0ZWQ7XHJcbmxldCBwZXJmO1xyXG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIHN1cHBvcnRlZCA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XHJcbiAgICAgICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XHJcbiAgICAgICAgcGVyZi5tYXJrKGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5tZWFzdXJlKGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIHN1cHBvcnRlZCA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcclxuICAgIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbiAgICB9XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcclxuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG59XG5cbi8qKlxyXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIGluIGVzbS1idW5kbGVyIGJ1aWxkcy5cclxuICogSXQgaXMgY2FsbGVkIHdoZW4gYSByZW5kZXJlciBpcyBjcmVhdGVkLCBpbiBgYmFzZUNyZWF0ZVJlbmRlcmVyYCBzbyB0aGF0XHJcbiAqIGltcG9ydGluZyBydW50aW1lLWNvcmUgaXMgc2lkZS1lZmZlY3RzIGZyZWUuXHJcbiAqXHJcbiAqIGlzdGFuYnVsLWlnbm9yZS1uZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xyXG4gICAgbGV0IG5lZWRXYXJuID0gZmFsc2U7XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIG5lZWRXYXJuID0gdHJ1ZTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgbmVlZFdhcm4gPSB0cnVlO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLiBJdCBpcyByZWNvbW1lbmRlZCB0byBgICtcclxuICAgICAgICAgICAgYGNvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gZXhwbGljaXRseSByZXBsYWNlIGZlYXR1cmUgZmxhZyBnbG9iYWxzIGAgK1xyXG4gICAgICAgICAgICBgd2l0aCBib29sZWFuIGxpdGVyYWxzIHRvIGdldCBwcm9wZXIgdHJlZS1zaGFraW5nIGluIHRoZSBmaW5hbCBidW5kbGUuIGAgK1xyXG4gICAgICAgICAgICBgU2VlIGh0dHA6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzIGZvciBtb3JlIGRldGFpbHMuYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgcHJvZEVmZmVjdE9wdGlvbnMgPSB7XHJcbiAgICBzY2hlZHVsZXI6IHF1ZXVlSm9iLFxyXG4gICAgLy8gIzE4MDEsICMyMDQzIGNvbXBvbmVudCByZW5kZXIgZWZmZWN0cyBzaG91bGQgYWxsb3cgcmVjdXJzaXZlIHVwZGF0ZXNcclxuICAgIGFsbG93UmVjdXJzZTogdHJ1ZVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZFZmZlY3RPcHRpb25zKGluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNjaGVkdWxlcjogcXVldWVKb2IsXHJcbiAgICAgICAgYWxsb3dSZWN1cnNlOiB0cnVlLFxyXG4gICAgICAgIG9uVHJhY2s6IGluc3RhbmNlLnJ0YyA/IGUgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRjLCBlKSA6IHZvaWQgMCxcclxuICAgICAgICBvblRyaWdnZXI6IGluc3RhbmNlLnJ0ZyA/IGUgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRnLCBlKSA6IHZvaWQgMFxyXG4gICAgfTtcclxufVxyXG5jb25zdCBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QgPSBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZVxyXG4gICAgO1xyXG5jb25zdCBzZXRSZWYgPSAocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpID0+IHtcclxuICAgIGlmIChpc0FycmF5KHJhd1JlZikpIHtcclxuICAgICAgICByYXdSZWYuZm9yRWFjaCgociwgaSkgPT4gc2V0UmVmKHIsIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcclxuICAgICAgICAvLyB3aGVuIG1vdW50aW5nIGFzeW5jIGNvbXBvbmVudHMsIG5vdGhpbmcgbmVlZHMgdG8gYmUgZG9uZSxcclxuICAgICAgICAvLyBiZWNhdXNlIHRoZSB0ZW1wbGF0ZSByZWYgaXMgZm9yd2FyZGVkIHRvIGlubmVyIGNvbXBvbmVudFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi9cclxuICAgICAgICA/IHZub2RlLmNvbXBvbmVudC5leHBvc2VkIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eVxyXG4gICAgICAgIDogdm5vZGUuZWw7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcclxuICAgIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhb3duZXIpIHtcclxuICAgICAgICB3YXJuKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xyXG4gICAgICAgICAgICBgQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xyXG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcclxuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xyXG4gICAgLy8gZHluYW1pYyByZWYgY2hhbmdlZC4gdW5zZXQgb2xkIHJlZlxyXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdHJpbmcocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcclxuICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyAjMTc4OTogZm9yIG5vbi1udWxsIHZhbHVlcywgc2V0IHRoZW0gYWZ0ZXIgcmVuZGVyXHJcbiAgICAgICAgLy8gbnVsbCB2YWx1ZXMgbWVhbnMgdGhpcyBpcyB1bm1vdW50IGFuZCBpdCBzaG91bGQgbm90IG92ZXJ3cml0ZSBhbm90aGVyXHJcbiAgICAgICAgLy8gcmVmIHdpdGggdGhlIHNhbWUga2V5XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRvU2V0LmlkID0gLTE7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9TZXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlZihyZWYpKSB7XHJcbiAgICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRvU2V0LmlkID0gLTE7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9TZXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIgLyogRlVOQ1RJT05fUkVGICovLCBbdmFsdWUsIHJlZnNdKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6JywgdmFsdWUsIGAoJHt0eXBlb2YgdmFsdWV9KWApO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogVGhlIGNyZWF0ZVJlbmRlcmVyIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGdlbmVyaWMgYXJndW1lbnRzOlxyXG4gKiBIb3N0Tm9kZSBhbmQgSG9zdEVsZW1lbnQsIGNvcnJlc3BvbmRpbmcgdG8gTm9kZSBhbmQgRWxlbWVudCB0eXBlcyBpbiB0aGVcclxuICogaG9zdCBlbnZpcm9ubWVudC4gRm9yIGV4YW1wbGUsIGZvciBydW50aW1lLWRvbSwgSG9zdE5vZGUgd291bGQgYmUgdGhlIERPTVxyXG4gKiBgTm9kZWAgaW50ZXJmYWNlIGFuZCBIb3N0RWxlbWVudCB3b3VsZCBiZSB0aGUgRE9NIGBFbGVtZW50YCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEN1c3RvbSByZW5kZXJlcnMgY2FuIHBhc3MgaW4gdGhlIHBsYXRmb3JtIHNwZWNpZmljIHR5cGVzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgIGpzXHJcbiAqIGNvbnN0IHsgcmVuZGVyLCBjcmVhdGVBcHAgfSA9IGNyZWF0ZVJlbmRlcmVyPE5vZGUsIEVsZW1lbnQ+KHtcclxuICogICBwYXRjaFByb3AsXHJcbiAqICAgLi4ubm9kZU9wc1xyXG4gKiB9KVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XHJcbn1cclxuLy8gU2VwYXJhdGUgQVBJIGZvciBjcmVhdGluZyBoeWRyYXRpb24tZW5hYmxlZCByZW5kZXJlci5cclxuLy8gSHlkcmF0aW9uIGxvZ2ljIGlzIG9ubHkgdXNlZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgbWFraW5nIGl0XHJcbi8vIHRyZWUtc2hha2FibGUuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAgICAvLyBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyBjaGVja1xyXG4gICAge1xyXG4gICAgICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xyXG4gICAgICAgIHRhcmdldC5fX1ZVRV9fID0gdHJ1ZTtcclxuICAgICAgICBzZXREZXZ0b29sc0hvb2sodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBpbnNlcnQ6IGhvc3RJbnNlcnQsIHJlbW92ZTogaG9zdFJlbW92ZSwgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLCBmb3JjZVBhdGNoUHJvcDogaG9zdEZvcmNlUGF0Y2hQcm9wLCBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCwgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LCBzZXRUZXh0OiBob3N0U2V0VGV4dCwgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCwgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCwgY2xvbmVOb2RlOiBob3N0Q2xvbmVOb2RlLCBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudCB9ID0gb3B0aW9ucztcclxuICAgIC8vIE5vdGU6IGZ1bmN0aW9ucyBpbnNpZGUgdGhpcyBjbG9zdXJlIHNob3VsZCB1c2UgYGNvbnN0IHh4eCA9ICgpID0+IHt9YFxyXG4gICAgLy8gc3R5bGUgaW4gb3JkZXIgdG8gcHJldmVudCBiZWluZyBpbmxpbmVkIGJ5IG1pbmlmaWVycy5cclxuICAgIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIGlzU1ZHID0gZmFsc2UsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgLy8gcGF0Y2hpbmcgJiBub3Qgc2FtZSB0eXBlLCB1bm1vdW50IG9sZCB0cmVlXHJcbiAgICAgICAgaWYgKG4xICYmICFpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xyXG4gICAgICAgICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgbjEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMiAvKiBCQUlMICovKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50JDE6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzRnJhZ21lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHJlZlxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCAnJykpLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIHN1cHBvcnQgZm9yIGR5bmFtaWMgY29tbWVudHNcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpID0+IHtcclxuICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERldiAvIEhNUiBvbmx5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcclxuICAgICAgICAvLyBzdGF0aWMgbm9kZXMgYXJlIG9ubHkgcGF0Y2hlZCBkdXJpbmcgZGV2IGZvciBITVJcclxuICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcclxuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XHJcbiAgICAgICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgICAgICAgICAgZWwgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgZWwgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBuMi50eXBlID09PSAnc3ZnJztcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudEVsZW1lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2hFbGVtZW50KG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGVsO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBwYXRjaEZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHZub2RlLmVsICYmXHJcbiAgICAgICAgICAgIGhvc3RDbG9uZU5vZGUgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgLy8gSWYgYSB2bm9kZSBoYXMgbm9uLW51bGwgZWwsIGl0IG1lYW5zIGl0J3MgYmVpbmcgcmV1c2VkLlxyXG4gICAgICAgICAgICAvLyBPbmx5IHN0YXRpYyB2bm9kZXMgY2FuIGJlIHJldXNlZCwgc28gaXRzIG1vdW50ZWQgRE9NIG5vZGVzIHNob3VsZCBiZVxyXG4gICAgICAgICAgICAvLyBleGFjdGx5IHRoZSBzYW1lLCBhbmQgd2UgY2FuIHNpbXBseSBkbyBhIGNsb25lIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpbiBwcm9kdWN0aW9uIHNpbmNlIGNsb25lZCB0cmVlcyBjYW5ub3QgYmUgSE1SIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q2xvbmVOb2RlKHZub2RlLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudCh2bm9kZS50eXBlLCBpc1NWRywgcHJvcHMgJiYgcHJvcHMuaXMsIHByb3BzKTtcclxuICAgICAgICAgICAgLy8gbW91bnQgY2hpbGRyZW4gZmlyc3QsIHNpbmNlIHNvbWUgcHJvcHMgbWF5IHJlbHkgb24gY2hpbGQgY29udGVudFxyXG4gICAgICAgICAgICAvLyBiZWluZyBhbHJlYWR5IHJlbmRlcmVkLCBlLmcuIGA8c2VsZWN0IHZhbHVlPmBcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCB2bm9kZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4odm5vZGUuY2hpbGRyZW4sIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyAmJiB0eXBlICE9PSAnZm9yZWlnbk9iamVjdCcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2NvcGVJZFxyXG4gICAgICAgICAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Zub2RlJywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZub2RlLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdnVlUGFyZW50Q29tcG9uZW50Jywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAjMTU4MyBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2Ugbm90IHJlc29sdmVkIGNhc2UsIGVudGVyIGhvb2sgc2hvdWxkIGNhbGwgd2hlbiBzdXNwZW5zZSByZXNvbHZlZFxyXG4gICAgICAgIC8vICMxNjg5IEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSByZXNvbHZlZCBjYXNlLCBqdXN0IGNhbGwgaXRcclxuICAgICAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9ICghcGFyZW50U3VzcGVuc2UgfHwgKHBhcmVudFN1c3BlbnNlICYmICFwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSkgJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XHJcbiAgICAgICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHxcclxuICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHxcclxuICAgICAgICAgICAgZGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcclxuICAgICAgICBpZiAoc2NvcGVJZCkge1xyXG4gICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgbGV0IHN1YlRyZWUgPSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlLnBhdGNoRmxhZyAmIDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xyXG4gICAgICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgcGFyZW50Vk5vZGUsIHBhcmVudFZOb2RlLnNjb3BlSWQsIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50LnBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIGNoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xyXG4gICAgICAgIC8vICMxNDI2IHRha2UgdGhlIG9sZCB2bm9kZSdzIHBhdGNoIGZsYWcgaW50byBhY2NvdW50IHNpbmNlIHVzZXIgbWF5IGNsb25lIGFcclxuICAgICAgICAvLyBjb21waWxlci1nZW5lcmF0ZWQgdm5vZGUsIHdoaWNoIGRlLW9wdHMgdG8gRlVMTF9QUk9QU1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovO1xyXG4gICAgICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSkge1xyXG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVcGRhdGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBwcmVzZW5jZSBvZiBhIHBhdGNoRmxhZyBtZWFucyB0aGlzIGVsZW1lbnQncyByZW5kZXIgY29kZSB3YXNcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBhbmQgY2FuIHRha2UgdGhlIGZhc3QgcGF0aC5cclxuICAgICAgICAgICAgLy8gaW4gdGhpcyBwYXRoIG9sZCBub2RlIGFuZCBuZXcgbm9kZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXHJcbiAgICAgICAgICAgIC8vIChpLmUuIGF0IHRoZSBleGFjdCBzYW1lIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgdGVtcGxhdGUpXHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHByb3BzIGNvbnRhaW4gZHluYW1pYyBrZXlzLCBmdWxsIGRpZmYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGFzc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBjbGFzcyBiaW5kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAyIC8qIENMQVNTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnY2xhc3MnLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHN0eWxlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHN0eWxlIGJpbmRpbmdzXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCAvKiBTVFlMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdzdHlsZScsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgcHJvcC9hdHRyIGJpbmRpbmdzXHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0aGFuIGNsYXNzIGFuZCBzdHlsZS4gVGhlIGtleXMgb2YgZHluYW1pYyBwcm9wL2F0dHJzIGFyZSBzYXZlZCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGZhc3RlciBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIGR5bmFtaWMga2V5cyBsaWtlIDpbZm9vXT1cImJhclwiIHdpbGwgY2F1c2UgdGhpcyBvcHRpbWl6YXRpb24gdG9cclxuICAgICAgICAgICAgICAgIC8vIGJhaWwgb3V0IGFuZCBnbyB0aHJvdWdoIGEgZnVsbCBkaWZmIGJlY2F1c2Ugd2UgbmVlZCB0byB1bnNldCB0aGUgb2xkIGtleVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmxhZyBpcyBwcmVzZW50IHRoZW4gZHluYW1pY1Byb3BzIG11c3QgYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaG9zdEZvcmNlUGF0Y2hQcm9wICYmIGhvc3RGb3JjZVBhdGNoUHJvcChlbCwga2V5KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIG4xLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRleHRcclxuICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgb25seSBkeW5hbWljIHRleHQgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHVub3B0aW1pemVkLCBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhcmVDaGlsZHJlblNWRyA9IGlzU1ZHICYmIG4yLnR5cGUgIT09ICdmb3JlaWduT2JqZWN0JztcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xyXG4gICAgICAgICAgICAvLyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XHJcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICd1cGRhdGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhlIGZhc3QgcGF0aCBmb3IgYmxvY2tzLlxyXG4gICAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY29udGFpbmVyIChwYXJlbnQgZWxlbWVudCkgZm9yIHRoZSBwYXRjaC5cclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gXHJcbiAgICAgICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxyXG4gICAgICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XHJcbiAgICAgICAgICAgIG9sZFZOb2RlLmVsICYmXHJcbiAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLylcclxuICAgICAgICAgICAgICAgID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpXHJcbiAgICAgICAgICAgICAgICA6IC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lcjtcclxuICAgICAgICAgICAgcGF0Y2gob2xkVk5vZGUsIG5ld1ZOb2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCB2bm9kZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBub3QgdmFsaWQgcHJvcFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHxcclxuICAgICAgICAgICAgICAgICAgICAoaG9zdEZvcmNlUGF0Y2hQcm9wICYmIGhvc3RGb3JjZVBhdGNoUHJvcChlbCwga2V5KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgb2xkUHJvcHNba2V5XSwgbnVsbCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IChuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgc2xvdCBmcmFnbWVudCB3aXRoIDpzbG90dGVkIHNjb3BlIGlkc1xyXG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHNcclxuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcclxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAvLyBhIGZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYXJyYXkgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxyXG4gICAgICAgICAgICAvLyBmcm9tIGFycmF5cy5cclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBmcmFnbWVudEVuZEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIHN0YWJsZSBmcmFnbWVudCAodGVtcGxhdGUgcm9vdCBvciA8dGVtcGxhdGUgdi1mb3I+KSBkb2Vzbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGNoaWxkcmVuIG9yZGVyLCBidXQgaXQgbWF5IGNvbnRhaW4gZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XHJcbiAgICAgICAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxyXG4gICAgICAgICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxyXG4gICAgICAgICAgICAgICAgbjIua2V5ICE9IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSAvKiBzaGFsbG93ICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGtleWVkIC8gdW5rZXllZCwgb3IgbWFudWFsIGZyYWdtZW50cy5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBrZXllZCAmIHVua2V5ZWQsIHNpbmNlIHRoZXkgYXJlIGNvbXBpbGVyIGdlbmVyYXRlZCBmcm9tIHYtZm9yLFxyXG4gICAgICAgICAgICAgICAgLy8gZWFjaCBjaGlsZCBpcyBndWFyYW50ZWVkIHRvIGJlIGEgYmxvY2sgc28gdGhlIGZyYWdtZW50IHdpbGwgbmV2ZXJcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShpbml0aWFsVk5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCByZW5kZXJlciBpbnRlcm5hbHMgZm9yIGtlZXBBbGl2ZVxyXG4gICAgICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzb2x2ZSBwcm9wcyBhbmQgc2xvdHMgZm9yIHNldHVwIGNvbnRleHRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0dXAoKSBpcyBhc3luYy4gVGhpcyBjb21wb25lbnQgcmVsaWVzIG9uIGFzeW5jIGxvZ2ljIHRvIGJlIHJlc29sdmVkXHJcbiAgICAgICAgLy8gYmVmb3JlIHByb2NlZWRpbmdcclxuICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KTtcclxuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIHBsYWNlaG9sZGVyIGlmIHRoaXMgaXMgbm90IGh5ZHJhdGlvblxyXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBzZWxmLWRlZmluZWQgZmFsbGJhY2tcclxuICAgICAgICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50JDEpKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jICYgc3RpbGwgcGVuZGluZyAtIGp1c3QgdXBkYXRlIHByb3BzIGFuZCBzbG90c1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgY29tcG9uZW50IGlzIGFsc28gcXVldWVkLCByZW1vdmUgaXQgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZSB1cGRhdGluZyB0aGUgc2FtZSBjaGlsZCBjb21wb25lbnQgaW4gdGhlIHNhbWUgZmx1c2guXHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS51cGRhdGUgaXMgdGhlIHJlYWN0aXZlIGVmZmVjdCBydW5uZXIuXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gdXBkYXRlIG5lZWRlZC4ganVzdCBjb3B5IG92ZXIgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIC8vIGNyZWF0ZSByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlcmluZ1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSA9IGVmZmVjdChmdW5jdGlvbiBjb21wb25lbnRFZmZlY3QoKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVNb3VudCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlTW91bnRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIGhhcyBhZG9wdGVkIGhvc3Qgbm9kZSAtIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHlkcmF0ZVN1YlRyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlTm9kZShlbCwgaW5zdGFuY2Uuc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLnR5cGUuX19hc3luY0xvYWRlcigpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGFyZSBtb3ZpbmcgdGhlIHJlbmRlciBjYWxsIGludG8gYW4gYXN5bmMgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IHdvbid0IHRyYWNrIGRlcGVuZGVuY2llcyAtIGJ1dCBpdCdzIG9rIGJlY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBzZXJ2ZXItcmVuZGVyZWQgYXN5bmMgd3JhcHBlciBpcyBhbHJlYWR5IGluIHJlc29sdmVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCB3aWxsIG5ldmVyIG5lZWQgdG8gY2hhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiAhaW5zdGFuY2UuaXNVbm1vdW50ZWQgJiYgaHlkcmF0ZVN1YlRyZWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBzdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZU1vdW50ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFjdGl2YXRlZCBob29rIGZvciBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gIzE3NDIgYWN0aXZhdGVkIGhvb2sgbXVzdCBiZSBhY2Nlc3NlZCBhZnRlciBmaXJzdCByZW5kZXJcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBob29rIG1heSBiZSBpbmplY3RlZCBieSBhIGNoaWxkIGtlZXAtYWxpdmVcclxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gIzI0NTg6IGRlZmVyZW5jZSBtb3VudC1vbmx5IG9iamVjdCBwYXJhbWV0ZXJzIHRvIHByZXZlbnQgbWVtbGVha3NcclxuICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVDb21wb25lbnRcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdHJpZ2dlcmVkIGJ5IG11dGF0aW9uIG9mIGNvbXBvbmVudCdzIG93biBzdGF0ZSAobmV4dDogbnVsbClcclxuICAgICAgICAgICAgICAgIC8vIE9SIHBhcmVudCBjYWxsaW5nIHByb2Nlc3NDb21wb25lbnQgKG5leHQ6IFZOb2RlKVxyXG4gICAgICAgICAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVVcGRhdGUgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZVVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdGNoKHByZXZUcmVlLCBuZXh0VHJlZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcclxuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSwgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxmLXRyaWdnZXJlZCB1cGRhdGUuIEluIGNhc2Ugb2YgSE9DLCB1cGRhdGUgcGFyZW50IGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIGVsLiBIT0MgaXMgaW5kaWNhdGVkIGJ5IHBhcmVudCBpbnN0YW5jZSdzIHN1YlRyZWUgcG9pbnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBjaGlsZCBjb21wb25lbnQncyB2bm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAodSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlVXBkYXRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZVVwZGF0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZURldkVmZmVjdE9wdGlvbnMoaW5zdGFuY2UpIDogcHJvZEVmZmVjdE9wdGlvbnMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUub3duZXJJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xyXG4gICAgICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xyXG4gICAgICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xyXG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHVwZGF0ZVByb3BzKGluc3RhbmNlLCBuZXh0Vk5vZGUucHJvcHMsIHByZXZQcm9wcywgb3B0aW1pemVkKTtcclxuICAgICAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAvLyBwcm9wcyB1cGRhdGUgbWF5IGhhdmUgdHJpZ2dlcmVkIHByZS1mbHVzaCB3YXRjaGVycy5cclxuICAgICAgICAvLyBmbHVzaCB0aGVtIGJlZm9yZSB0aGUgcmVuZGVyIHVwZGF0ZS5cclxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKHVuZGVmaW5lZCwgaW5zdGFuY2UudXBkYXRlKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcclxuICAgICAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aFxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgZWl0aGVyIGZ1bGx5LWtleWVkIG9yIG1peGVkIChzb21lIGtleWVkIHNvbWUgbm90KVxyXG4gICAgICAgICAgICAgICAgLy8gcHJlc2VuY2Ugb2YgcGF0Y2hGbGFnIG1lYW5zIGNoaWxkcmVuIGFyZSBndWFyYW50ZWVkIHRvIGJlIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHVua2V5ZWRcclxuICAgICAgICAgICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hpbGRyZW4gaGFzIDMgcG9zc2liaWxpdGllczogdGV4dCwgYXJyYXkgb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAvLyB0ZXh0IGNoaWxkcmVuIGZhc3QgcGF0aFxyXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gYzEpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR3byBhcnJheXMsIGNhbm5vdCBhc3N1bWUgYW55dGhpbmcsIGRvIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkcmVuLCBqdXN0IHVubW91bnQgb2xkXHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIHRleHQgT1IgbnVsbFxyXG4gICAgICAgICAgICAgICAgLy8gbmV3IGNoaWxkcmVuIGlzIGFycmF5IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3IGlmIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChjMVtpXSwgbmV4dENoaWxkLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZFxyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsIGZhbHNlLCBjb21tb25MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbW91bnQgbmV3XHJcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGNvbW1vbkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBhbGwta2V5ZWQgb3IgbWl4ZWRcclxuICAgIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTsgLy8gcHJldiBlbmRpbmcgaW5kZXhcclxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgLy8gMS4gc3luYyBmcm9tIHN0YXJ0XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpIGQgZVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtpXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDIuIHN5bmMgZnJvbSBlbmRcclxuICAgICAgICAvLyBhIChiIGMpXHJcbiAgICAgICAgLy8gZCBlIChiIGMpXHJcbiAgICAgICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xyXG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2UxXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbZTJdID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlMS0tO1xyXG4gICAgICAgICAgICBlMi0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLiBjb21tb24gc2VxdWVuY2UgKyBtb3VudFxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDEsIGUyID0gMlxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gYyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IC0xLCBlMiA9IDBcclxuICAgICAgICBpZiAoaSA+IGUxKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSksIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA0LiBjb21tb24gc2VxdWVuY2UgKyB1bm1vdW50XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gMiwgZTIgPSAxXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIChiIGMpXHJcbiAgICAgICAgLy8gaSA9IDAsIGUxID0gMCwgZTIgPSAtMVxyXG4gICAgICAgIGVsc2UgaWYgKGkgPiBlMikge1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8PSBlMSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjMVtpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNS4gdW5rbm93biBzZXF1ZW5jZVxyXG4gICAgICAgIC8vIFtpIC4uLiBlMSArIDFdOiBhIGIgW2MgZCBlXSBmIGdcclxuICAgICAgICAvLyBbaSAuLi4gZTIgKyAxXTogYSBiIFtlIGQgYyBoXSBmIGdcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSA0LCBlMiA9IDVcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgczEgPSBpOyAvLyBwcmV2IHN0YXJ0aW5nIGluZGV4XHJcbiAgICAgICAgICAgIGNvbnN0IHMyID0gaTsgLy8gbmV4dCBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICAvLyA1LjEgYnVpbGQga2V5OmluZGV4IG1hcCBmb3IgbmV3Q2hpbGRyZW5cclxuICAgICAgICAgICAgY29uc3Qga2V5VG9OZXdJbmRleE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLCBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gNS4yIGxvb3AgdGhyb3VnaCBvbGQgY2hpbGRyZW4gbGVmdCB0byBiZSBwYXRjaGVkIGFuZCB0cnkgdG8gcGF0Y2hcclxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgbm9kZXMgJiByZW1vdmUgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnRcclxuICAgICAgICAgICAgbGV0IGo7XHJcbiAgICAgICAgICAgIGxldCBwYXRjaGVkID0gMDtcclxuICAgICAgICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcclxuICAgICAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIHVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnkgbm9kZSBoYXMgbW92ZWRcclxuICAgICAgICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xyXG4gICAgICAgICAgICAvLyB3b3JrcyBhcyBNYXA8bmV3SW5kZXgsIG9sZEluZGV4PlxyXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb2xkSW5kZXggaXMgb2Zmc2V0IGJ5ICsxXHJcbiAgICAgICAgICAgIC8vIGFuZCBvbGRJbmRleCA9IDAgaXMgYSBzcGVjaWFsIHZhbHVlIGluZGljYXRpbmcgdGhlIG5ldyBub2RlIGhhc1xyXG4gICAgICAgICAgICAvLyBubyBjb3JyZXNwb25kaW5nIG9sZCBub2RlLlxyXG4gICAgICAgICAgICAvLyB1c2VkIGZvciBkZXRlcm1pbmluZyBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZVxyXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9CZVBhdGNoZWQ7IGkrKylcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IGMxW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbmV3IGNoaWxkcmVuIGhhdmUgYmVlbiBwYXRjaGVkIHNvIHRoaXMgY2FuIG9ubHkgYmUgYSByZW1vdmFsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0luZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBrZXktbGVzcyBub2RlLCB0cnkgdG8gbG9jYXRlIGEga2V5LWxlc3Mgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gczI7IGogPD0gZTI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gocHJldkNoaWxkLCBjMltuZXdJbmRleF0sIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gNS4zIG1vdmUgYW5kIG1vdW50XHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlIG9ubHkgd2hlbiBub2RlcyBoYXZlIG1vdmVkXHJcbiAgICAgICAgICAgIGNvbnN0IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlID0gbW92ZWRcclxuICAgICAgICAgICAgICAgID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKVxyXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9BUlI7XHJcbiAgICAgICAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAvLyBsb29waW5nIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiB1c2UgbGFzdCBwYXRjaGVkIG5vZGUgYXMgYW5jaG9yXHJcbiAgICAgICAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHMyICsgaTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXdcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGlmOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHN0YWJsZSBzdWJzZXF1ZW5jZSAoZS5nLiBhIHJldmVyc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT1IgY3VycmVudCBub2RlIGlzIG5vdCBhbW9uZyB0aGUgc3RhYmxlIHNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMiAvKiBSRU9SREVSICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW92ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwpID0+IHtcclxuICAgICAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgdHlwZS5tb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICBtb3ZlU3RhdGljTm9kZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNpbmdsZSBub2Rlc1xyXG4gICAgICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uID0gbW92ZVR5cGUgIT09IDIgLyogUkVPUkRFUiAqLyAmJlxyXG4gICAgICAgICAgICBzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjtcclxuICAgICAgICBpZiAobmVlZFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG1vdmVUeXBlID09PSAwIC8qIEVOVEVSICovKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB0cmFuc2l0aW9uLmVudGVyKGVsKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShlbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHJlZiwgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIC8vIHVuc2V0IHJlZlxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgZGlycztcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XHJcbiAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZVVubW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIGludGVybmFscywgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXHJcbiAgICAgICAgICAgICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIGZvciBibG9jayBub2Rlczogb25seSBuZWVkIHRvIHVubW91bnQgZHluYW1pYyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihkeW5hbWljQ2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gRnJhZ21lbnQgJiZcclxuICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLykpIHx8XHJcbiAgICAgICAgICAgICAgICAoIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUodm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkgfHwgc2hvdWxkSW52b2tlRGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ3VubW91bnRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZSA9IHZub2RlID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoZWwpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQgJiYgdHJhbnNpdGlvbi5hZnRlckxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlIH0gPSB0cmFuc2l0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxheUxlYXZlKHZub2RlLmVsLCBwZXJmb3JtUmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBlcmZvcm1SZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcclxuICAgICAgICAvLyBGb3IgZnJhZ21lbnRzLCBkaXJlY3RseSByZW1vdmUgYWxsIGNvbnRhaW5lZCBET00gbm9kZXMuXHJcbiAgICAgICAgLy8gKGZyYWdtZW50IGNoaWxkIG5vZGVzIGNhbm5vdCBoYXZlIHRyYW5zaXRpb24pXHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGN1ciAhPT0gZW5kKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoY3VyKTtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShjdXIpO1xyXG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0UmVtb3ZlKGVuZCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudENvbXBvbmVudCA9IChpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgdW5yZWdpc3RlckhNUihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgYnVtLCBlZmZlY3RzLCB1cGRhdGUsIHN1YlRyZWUsIHVtIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBiZWZvcmVVbm1vdW50IGhvb2tcclxuICAgICAgICBpZiAoYnVtKSB7XHJcbiAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlZmZlY3RzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3RvcChlZmZlY3RzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGUgbWF5IGJlIG51bGwgaWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBpdHMgYXN5bmNcclxuICAgICAgICAvLyBzZXR1cCBoYXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICBzdG9wKHVwZGF0ZSk7XHJcbiAgICAgICAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVubW91bnRlZCBob29rXHJcbiAgICAgICAgaWYgKHVtKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1bSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIC8vIEEgY29tcG9uZW50IHdpdGggYXN5bmMgZGVwIGluc2lkZSBhIHBlbmRpbmcgc3VzcGVuc2UgaXMgdW5tb3VudGVkIGJlZm9yZVxyXG4gICAgICAgIC8vIGl0cyBhc3luYyBkZXAgcmVzb2x2ZXMuIFRoaXMgc2hvdWxkIHJlbW92ZSB0aGUgZGVwIGZyb20gdGhlIHN1c3BlbnNlLCBhbmRcclxuICAgICAgICAvLyBjYXVzZSB0aGUgc3VzcGVuc2UgdG8gcmVzb2x2ZSBpbW1lZGlhdGVseSBpZiB0aGF0IHdhcyB0aGUgbGFzdCBkZXAuXHJcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmXHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiZcclxuICAgICAgICAgICAgIXBhcmVudFN1c3BlbnNlLmlzVW5tb3VudGVkICYmXHJcbiAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwICYmXHJcbiAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGdldE5leHRIb3N0Tm9kZSA9IHZub2RlID0+IHtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZub2RlLnN1c3BlbnNlLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhvc3ROZXh0U2libGluZygodm5vZGUuYW5jaG9yIHx8IHZub2RlLmVsKSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5fdm5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoKGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgbnVsbCwgbnVsbCwgaXNTVkcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBpbnRlcm5hbHMgPSB7XHJcbiAgICAgICAgcDogcGF0Y2gsXHJcbiAgICAgICAgdW06IHVubW91bnQsXHJcbiAgICAgICAgbTogbW92ZSxcclxuICAgICAgICByOiByZW1vdmUsXHJcbiAgICAgICAgbXQ6IG1vdW50Q29tcG9uZW50LFxyXG4gICAgICAgIG1jOiBtb3VudENoaWxkcmVuLFxyXG4gICAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxyXG4gICAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxyXG4gICAgICAgIG46IGdldE5leHRIb3N0Tm9kZSxcclxuICAgICAgICBvOiBvcHRpb25zXHJcbiAgICB9O1xyXG4gICAgbGV0IGh5ZHJhdGU7XHJcbiAgICBsZXQgaHlkcmF0ZU5vZGU7XHJcbiAgICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAgICAgICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhpbnRlcm5hbHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW5kZXIsXHJcbiAgICAgICAgaHlkcmF0ZSxcclxuICAgICAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcclxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3IC8qIFZOT0RFX0hPT0sgKi8sIFtcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBwcmV2Vk5vZGVcclxuICAgIF0pO1xyXG59XHJcbi8qKlxyXG4gKiAjMTE1NlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIEhNUi1lbmFibGVkLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBzdGF0aWMgbm9kZXNcclxuICogaW5zaWRlIGEgYmxvY2sgYWxzbyBpbmhlcml0IHRoZSBET00gZWxlbWVudCBmcm9tIHRoZSBwcmV2aW91cyB0cmVlIHNvIHRoYXRcclxuICogSE1SIHVwZGF0ZXMgKHdoaWNoIGFyZSBmdWxsIHVwZGF0ZXMpIGNhbiByZXRyaWV2ZSB0aGUgZWxlbWVudCBmb3IgcGF0Y2hpbmcuXHJcbiAqXHJcbiAqICMyMDgwXHJcbiAqIEluc2lkZSBrZXllZCBgdGVtcGxhdGVgIGZyYWdtZW50IHN0YXRpYyBjaGlsZHJlbiwgaWYgYSBmcmFnbWVudCBpcyBtb3ZlZCxcclxuICogdGhlIGNoaWxkcmVuIHdpbGwgYWx3YXlzIG1vdmVkIHNvIHRoYXQgbmVlZCBpbmhlcml0IGVsIGZvcm0gcHJldmlvdXMgbm9kZXNcclxuICogdG8gZW5zdXJlIGNvcnJlY3QgbW92ZWQgcG9zaXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgY2FsbGVkIGluIHRoZSBvcHRpbWl6ZWQgcGF0aCBzbyBhcnJheSBjaGlsZHJlbiBhcmVcclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlZCB0byBiZSB2bm9kZXNcclxuICAgICAgICAgICAgY29uc3QgYzEgPSBjaDFbaV07XHJcbiAgICAgICAgICAgIGxldCBjMiA9IGNoMltpXTtcclxuICAgICAgICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93KVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIGluaGVyaXQgZm9yIGNvbW1lbnQgbm9kZXMsIGJ1dCBub3QgcGxhY2Vob2xkZXJzIChlLmcuIHYtaWYgd2hpY2hcclxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSByZWNlaXZlZCAuZWwgZHVyaW5nIGJsb2NrIHBhdGNoKVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGMyLnR5cGUgPT09IENvbW1lbnQkMSAmJiAhYzIuZWwpIHtcclxuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXHJcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xyXG4gICAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xyXG4gICAgbGV0IGksIGosIHUsIHYsIGM7XHJcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJySSA9IGFycltpXTtcclxuICAgICAgICBpZiAoYXJySSAhPT0gMCkge1xyXG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgIHBbaV0gPSBqO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1ID0gMDtcclxuICAgICAgICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAodSA8IHYpIHtcclxuICAgICAgICAgICAgICAgIGMgPSAoKHUgKyB2KSAvIDIpIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gYyArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdFt1XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1ID0gcmVzdWx0Lmxlbmd0aDtcclxuICAgIHYgPSByZXN1bHRbdSAtIDFdO1xyXG4gICAgd2hpbGUgKHUtLSA+IDApIHtcclxuICAgICAgICByZXN1bHRbdV0gPSB2O1xyXG4gICAgICAgIHYgPSBwW3ZdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xyXG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gJycpO1xyXG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xyXG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XHJcbiAgICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XHJcbiAgICAgICAgaWYgKCFzZWxlY3QpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcclxuICAgIF9faXNUZWxlcG9ydDogdHJ1ZSxcclxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcclxuICAgICAgICBjb25zdCB7IG1jOiBtb3VudENoaWxkcmVuLCBwYzogcGF0Y2hDaGlsZHJlbiwgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sIG86IHsgaW5zZXJ0LCBxdWVyeVNlbGVjdG9yLCBjcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50IH0gfSA9IGludGVybmFscztcclxuICAgICAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMi5wcm9wcyk7XHJcbiAgICAgICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcclxuICAgICAgICAvLyAjMzMwMlxyXG4gICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIGluc2VydCBhbmNob3JzIGluIHRoZSBtYWluIHZpZXdcclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAobjIuZWwgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tbWVudCgndGVsZXBvcnQgc3RhcnQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IGVuZCcpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjY1MiB3ZSBjb3VsZCBiZSB0ZWxlcG9ydGluZyBmcm9tIGEgbm9uLVNWRyB0cmVlIGludG8gYW4gU1ZHIHRyZWVcclxuICAgICAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgKmFsd2F5cyogaGFzIEFycmF5IGNoaWxkcmVuLiBUaGlzIGlzIGVuZm9yY2VkIGluIGJvdGggdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlciBhbmQgdm5vZGUgY2hpbGRyZW4gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gbjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IG4xLnRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcclxuICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggd2hlbiB0aGUgdGVsZXBvcnQgaGFwcGVucyB0byBiZSBhIGJsb2NrIHJvb3RcclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY3VycmVudENvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGluIGJsb2NrIHRyZWUgbW9kZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgcm9vdC1sZXZlbCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHRlbGVwb3J0IGluaGVyaXQgcHJldmlvdXMgRE9NIHJlZmVyZW5jZXMgc28gdGhhdCB0aGV5IGNhblxyXG4gICAgICAgICAgICAgICAgLy8gYmUgbW92ZWQgaW4gZnV0dXJlIHBhdGNoZXMuXHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGN1cnJlbnRDb250YWluZXIsIGN1cnJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGVkIC0+IGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpbnRvIG1haW4gY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCBjb250YWluZXIsIG1haW5BbmNob3IsIGludGVybmFscywgMSAvKiBUT0dHTEUgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGNoYW5nZWRcclxuICAgICAgICAgICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IChuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCBuZXh0VGFyZ2V0LCBudWxsLCBpbnRlcm5hbHMsIDAgLyogVEFSR0VUX0NIQU5HRSAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiB1cGRhdGU6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCAtPiBlbmFibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpbnRvIHRlbGVwb3J0IHRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgdGFyZ2V0LCB0YXJnZXRBbmNob3IsIGludGVybmFscywgMSAvKiBUT0dHTEUgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBhbmNob3IsIHRhcmdldEFuY2hvciwgdGFyZ2V0LCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKHRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFuIHVubW91bnRlZCB0ZWxlcG9ydCBzaG91bGQgYWx3YXlzIHJlbW92ZSBpdHMgY2hpbGRyZW4gaWYgbm90IGRpc2FibGVkXHJcbiAgICAgICAgaWYgKGRvUmVtb3ZlIHx8ICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlLCAhIWNoaWxkLmR5bmFtaWNDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW92ZTogbW92ZVRlbGVwb3J0LFxyXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVRlbGVwb3J0XHJcbn07XHJcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIgLyogUkVPUkRFUiAqLykge1xyXG4gICAgLy8gbW92ZSB0YXJnZXQgYW5jaG9yIGlmIHRoaXMgaXMgYSB0YXJnZXQgY2hhbmdlLlxyXG4gICAgaWYgKG1vdmVUeXBlID09PSAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pIHtcclxuICAgICAgICBpbnNlcnQodm5vZGUudGFyZ2V0QW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcclxuICAgIGNvbnN0IGlzUmVvcmRlciA9IG1vdmVUeXBlID09PSAyIC8qIFJFT1JERVIgKi87XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdGhpcyBpcyBhIHJlLW9yZGVyIGFuZCB0ZWxlcG9ydCBpcyBlbmFibGVkIChjb250ZW50IGlzIGluIHRhcmdldClcclxuICAgIC8vIGRvIG5vdCBtb3ZlIGNoaWxkcmVuLiBTbyB0aGUgb3Bwb3NpdGUgaXM6IG9ubHkgbW92ZSBjaGlsZHJlbiBpZiB0aGlzXHJcbiAgICAvLyBpcyBub3QgYSByZW9yZGVyLCBvciB0aGUgdGVsZXBvcnQgaXMgZGlzYWJsZWRcclxuICAgIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcclxuICAgICAgICAvLyBUZWxlcG9ydCBoYXMgZWl0aGVyIEFycmF5IGNoaWxkcmVuIG9yIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgMiAvKiBSRU9SREVSICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXHJcbiAgICBpZiAoaXNSZW9yZGVyKSB7XHJcbiAgICAgICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciB9IH0sIGh5ZHJhdGVDaGlsZHJlbikge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gKHZub2RlLnRhcmdldCA9IHJlc29sdmVUYXJnZXQodm5vZGUucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZSB0ZWxlcG9ydHMgcmVuZGVyZWQgdG8gdGhlIHNhbWUgdGFyZ2V0IGVsZW1lbnQsIHdlIG5lZWQgdG9cclxuICAgICAgICAvLyBwaWNrIHVwIGZyb20gd2hlcmUgdGhlIGxhc3QgdGVsZXBvcnQgZmluaXNoZWQgaW5zdGVhZCBvZiB0aGUgZmlyc3Qgbm9kZVxyXG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgaWYgKGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIHBhcmVudE5vZGUobm9kZSksIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbih0YXJnZXROb2RlLCB2bm9kZSwgdGFyZ2V0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPVxyXG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLnRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xyXG59XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuXG5jb25zdCBDT01QT05FTlRTID0gJ2NvbXBvbmVudHMnO1xyXG5jb25zdCBESVJFQ1RJVkVTID0gJ2RpcmVjdGl2ZXMnO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcclxufVxyXG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKCk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaW52YWxpZCB0eXBlcyB3aWxsIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZVZOb2RlIGFuZCByYWlzZSB3YXJuaW5nXHJcbiAgICAgICAgcmV0dXJuIChjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgLy8gZXhwbGljaXQgc2VsZiBuYW1lIGhhcyBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChzZWxmTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgKHNlbGZOYW1lID09PSBuYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBcclxuICAgICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcclxuICAgICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHxcclxuICAgICAgICAgICAgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpO1xyXG4gICAgICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZVxyXG4gICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBgICtcclxuICAgICAgICAgICAgYGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKHJlZ2lzdHJ5ICYmXHJcbiAgICAgICAgKHJlZ2lzdHJ5W25hbWVdIHx8XHJcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pKTtcclxufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnRnJhZ21lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgVGV4dCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnVGV4dCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBDb21tZW50JDEgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0NvbW1lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgU3RhdGljID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdTdGF0aWMnIDogdW5kZWZpbmVkKTtcclxuLy8gU2luY2Ugdi1pZiBhbmQgdi1mb3IgYXJlIHRoZSB0d28gcG9zc2libGUgd2F5cyBub2RlIHN0cnVjdHVyZSBjYW4gZHluYW1pY2FsbHlcclxuLy8gY2hhbmdlLCBvbmNlIHdlIGNvbnNpZGVyIHYtaWYgYnJhbmNoZXMgYW5kIGVhY2ggdi1mb3IgZnJhZ21lbnQgYSBibG9jaywgd2VcclxuLy8gY2FuIGRpdmlkZSBhIHRlbXBsYXRlIGludG8gbmVzdGVkIGJsb2NrcywgYW5kIHdpdGhpbiBlYWNoIGJsb2NrIHRoZSBub2RlXHJcbi8vIHN0cnVjdHVyZSB3b3VsZCBiZSBzdGFibGUuIFRoaXMgYWxsb3dzIHVzIHRvIHNraXAgbW9zdCBjaGlsZHJlbiBkaWZmaW5nXHJcbi8vIGFuZCBvbmx5IHdvcnJ5IGFib3V0IHRoZSBkeW5hbWljIG5vZGVzIChpbmRpY2F0ZWQgYnkgcGF0Y2ggZmxhZ3MpLlxyXG5jb25zdCBibG9ja1N0YWNrID0gW107XHJcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xyXG4vKipcclxuICogT3BlbiBhIGJsb2NrLlxyXG4gKiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgLiBJdCBjYW5ub3QgYmUgcGFydCBvZiBgY3JlYXRlQmxvY2tgXHJcbiAqIGJlY2F1c2UgdGhlIGNoaWxkcmVuIG9mIHRoZSBibG9jayBhcmUgZXZhbHVhdGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgIGl0c2VsZlxyXG4gKiBpcyBjYWxsZWQuIFRoZSBnZW5lcmF0ZWQgY29kZSB0eXBpY2FsbHkgbG9va3MgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAqICAgcmV0dXJuIChvcGVuQmxvY2soKSxjcmVhdGVCbG9jaygnZGl2JywgbnVsbCwgWy4uLl0pKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBkaXNhYmxlVHJhY2tpbmcgaXMgdHJ1ZSB3aGVuIGNyZWF0aW5nIGEgdi1mb3IgZnJhZ21lbnQgYmxvY2ssIHNpbmNlIGEgdi1mb3JcclxuICogZnJhZ21lbnQgYWx3YXlzIGRpZmZzIGl0cyBjaGlsZHJlbi5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xyXG4gICAgYmxvY2tTdGFjay5wdXNoKChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pKTtcclxufVxyXG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xyXG4gICAgYmxvY2tTdGFjay5wb3AoKTtcclxuICAgIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xyXG59XHJcbi8vIFdoZXRoZXIgd2Ugc2hvdWxkIGJlIHRyYWNraW5nIGR5bmFtaWMgY2hpbGQgbm9kZXMgaW5zaWRlIGEgYmxvY2suXHJcbi8vIE9ubHkgdHJhY2tzIHdoZW4gdGhpcyB2YWx1ZSBpcyA+IDBcclxuLy8gV2UgYXJlIG5vdCB1c2luZyBhIHNpbXBsZSBib29sZWFuIGJlY2F1c2UgdGhpcyB2YWx1ZSBtYXkgbmVlZCB0byBiZVxyXG4vLyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZCBieSBuZXN0ZWQgdXNhZ2Ugb2Ygdi1vbmNlIChzZWUgYmVsb3cpXHJcbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xyXG4vKipcclxuICogQmxvY2sgdHJhY2tpbmcgc29tZXRpbWVzIG5lZWRzIHRvIGJlIGRpc2FibGVkLCBmb3IgZXhhbXBsZSBkdXJpbmcgdGhlXHJcbiAqIGNyZWF0aW9uIG9mIGEgdHJlZSB0aGF0IG5lZWRzIHRvIGJlIGNhY2hlZCBieSB2LW9uY2UuIFRoZSBjb21waWxlciBnZW5lcmF0ZXNcclxuICogY29kZSBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBfY2FjaGVbMV0gfHwgKFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoLTEpLFxyXG4gKiAgIF9jYWNoZVsxXSA9IGNyZWF0ZVZOb2RlKC4uLiksXHJcbiAqICAgc2V0QmxvY2tUcmFja2luZygxKSxcclxuICogICBfY2FjaGVbMV1cclxuICogKVxyXG4gKiBgYGBcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcclxuICAgIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgYmxvY2sgcm9vdCB2bm9kZS4gVGFrZXMgdGhlIHNhbWUgZXhhY3QgYXJndW1lbnRzIGFzIGBjcmVhdGVWTm9kZWAuXHJcbiAqIEEgYmxvY2sgcm9vdCBrZWVwcyB0cmFjayBvZiBkeW5hbWljIG5vZGVzIHdpdGhpbiB0aGUgYmxvY2sgaW4gdGhlXHJcbiAqIGBkeW5hbWljQ2hpbGRyZW5gIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCB0cnVlIC8qIGlzQmxvY2s6IHByZXZlbnQgYSBibG9jayBmcm9tIHRyYWNraW5nIGl0c2VsZiAqLyk7XHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgYmxvY2sgY2hpbGRyZW4gb24gdGhlIGJsb2NrIHZub2RlXHJcbiAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPVxyXG4gICAgICAgIGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgPyBjdXJyZW50QmxvY2sgfHwgRU1QVFlfQVJSIDogbnVsbDtcclxuICAgIC8vIGNsb3NlIGJsb2NrXHJcbiAgICBjbG9zZUJsb2NrKCk7XHJcbiAgICAvLyBhIGJsb2NrIGlzIGFsd2F5cyBnb2luZyB0byBiZSBwYXRjaGVkLCBzbyB0cmFjayBpdCBhcyBhIGNoaWxkIG9mIGl0c1xyXG4gICAgLy8gcGFyZW50IGJsb2NrXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgbjIuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiZcclxuICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG4yLnR5cGUpKSB7XHJcbiAgICAgICAgLy8gSE1SIG9ubHk6IGlmIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaG90LXVwZGF0ZWQsIGZvcmNlIGEgcmVsb2FkLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xyXG59XHJcbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcclxuLyoqXHJcbiAqIEludGVybmFsIEFQSSBmb3IgcmVnaXN0ZXJpbmcgYW4gYXJndW1lbnRzIHRyYW5zZm9ybSBmb3IgY3JlYXRlVk5vZGVcclxuICogdXNlZCBmb3IgY3JlYXRpbmcgc3R1YnMgaW4gdGhlIHRlc3QtdXRpbHNcclxuICogSXQgaXMgKmludGVybmFsKiBidXQgbmVlZHMgdG8gYmUgZXhwb3NlZCBmb3IgdGVzdC11dGlscyB0byBwaWNrIHVwIHByb3BlclxyXG4gKiB0eXBpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcclxuICAgIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XHJcbn1cclxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICByZXR1cm4gX2NyZWF0ZVZOb2RlKC4uLih2bm9kZUFyZ3NUcmFuc2Zvcm1lclxyXG4gICAgICAgID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKVxyXG4gICAgICAgIDogYXJncykpO1xyXG59O1xyXG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XHJcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XHJcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7IHJlZiB9KSA9PiB7XHJcbiAgICByZXR1cm4gKHJlZiAhPSBudWxsXHJcbiAgICAgICAgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpXHJcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiB9XHJcbiAgICAgICAgICAgIDogcmVmXHJcbiAgICAgICAgOiBudWxsKTtcclxufTtcclxuY29uc3QgY3JlYXRlVk5vZGUgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm1cclxuICAgIDogX2NyZWF0ZVZOb2RlKTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50JDE7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZVZOb2RlIHJlY2VpdmluZyBhbiBleGlzdGluZyB2bm9kZS4gVGhpcyBoYXBwZW5zIGluIGNhc2VzIGxpa2VcclxuICAgICAgICAvLyA8Y29tcG9uZW50IDppcz1cInZub2RlXCIvPlxyXG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodHlwZSwgcHJvcHMsIHRydWUgLyogbWVyZ2VSZWY6IHRydWUgKi8pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH1cclxuICAgIC8vIGNsYXNzIGNvbXBvbmVudCBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAvLyBmb3IgcmVhY3RpdmUgb3IgcHJveHkgb2JqZWN0cywgd2UgbmVlZCB0byBjbG9uZSBpdCB0byBlbmFibGUgbXV0YXRpb24uXHJcbiAgICAgICAgaWYgKGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIHByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHN0YXRlIG9iamVjdHMgbmVlZCB0byBiZSBjbG9uZWQgc2luY2UgdGhleSBhcmUgbGlrZWx5IHRvIGJlXHJcbiAgICAgICAgICAgIC8vIG11dGF0ZWRcclxuICAgICAgICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlbmNvZGUgdGhlIHZub2RlIHR5cGUgaW5mb3JtYXRpb24gaW50byBhIGJpdG1hcFxyXG4gICAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSlcclxuICAgICAgICA/IDEgLyogRUxFTUVOVCAqL1xyXG4gICAgICAgIDogaXNTdXNwZW5zZSh0eXBlKVxyXG4gICAgICAgICAgICA/IDEyOCAvKiBTVVNQRU5TRSAqL1xyXG4gICAgICAgICAgICA6IGlzVGVsZXBvcnQodHlwZSlcclxuICAgICAgICAgICAgICAgID8gNjQgLyogVEVMRVBPUlQgKi9cclxuICAgICAgICAgICAgICAgIDogaXNPYmplY3QodHlwZSlcclxuICAgICAgICAgICAgICAgICAgICA/IDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMiAvKiBGVU5DVElPTkFMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmIGlzUHJveHkodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XHJcbiAgICAgICAgd2FybihgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQsIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBgICtcclxuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcclxuICAgICAgICAgICAgYGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsIGBcXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2bm9kZSA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgICAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXHJcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcclxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcclxuICAgICAgICBzc0NvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcclxuICAgICAgICBkaXJzOiBudWxsLFxyXG4gICAgICAgIHRyYW5zaXRpb246IG51bGwsXHJcbiAgICAgICAgZWw6IG51bGwsXHJcbiAgICAgICAgYW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IDAsXHJcbiAgICAgICAgc2hhcGVGbGFnLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyB2YWxpZGF0ZSBrZXlcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcclxuICAgICAgICB3YXJuKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xyXG4gICAgLy8gbm9ybWFsaXplIHN1c3BlbnNlIGNoaWxkcmVuXHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiZcclxuICAgICAgICAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcclxuICAgICAgICAhaXNCbG9ja05vZGUgJiZcclxuICAgICAgICAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcclxuICAgICAgICBjdXJyZW50QmxvY2sgJiZcclxuICAgICAgICAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xyXG4gICAgICAgIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cclxuICAgICAgICAocGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcclxuICAgICAgICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxyXG4gICAgICAgIHBhdGNoRmxhZyAhPT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IE5PVCB1c2luZyBzcHJlYWQgb3IgZXh0ZW5kIHRvIGF2b2lkIHRoZSBydW50aW1lXHJcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cclxuICAgIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xyXG4gICAgY29uc3QgY2xvbmVkID0ge1xyXG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxyXG4gICAgICAgIF9fdl9za2lwOiB0cnVlLFxyXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IG1lcmdlZFByb3BzLFxyXG4gICAgICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcclxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcclxuICAgICAgICAgICAgPyAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcclxuICAgICAgICAgICAgICAgIG1lcmdlUmVmICYmIHJlZlxyXG4gICAgICAgICAgICAgICAgICAgID8gaXNBcnJheShyZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXHJcbiAgICAgICAgICAgIDogcmVmLFxyXG4gICAgICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXHJcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8gJiYgaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXHJcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXHJcbiAgICAgICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxyXG4gICAgICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxyXG4gICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXHJcbiAgICAgICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cclxuICAgICAgICAvLyBub3RlOiBwZXJzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgLy8gZmFzdCBwYXRocyBvbmx5LlxyXG4gICAgICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudFxyXG4gICAgICAgICAgICA/IHBhdGNoRmxhZyA9PT0gLTEgLy8gaG9pc3RlZCBub2RlXHJcbiAgICAgICAgICAgICAgICA/IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgICAgIDogcGF0Y2hGbGFnIHwgMTYgLyogRlVMTF9QUk9QUyAqL1xyXG4gICAgICAgICAgICA6IHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcclxuICAgICAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxyXG4gICAgICAgIGRpcnM6IHZub2RlLmRpcnMsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogdm5vZGUudHJhbnNpdGlvbixcclxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcclxuICAgICAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcclxuICAgICAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXHJcbiAgICAgICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcclxuICAgICAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXHJcbiAgICAgICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcclxuICAgICAgICBlbDogdm5vZGUuZWwsXHJcbiAgICAgICAgYW5jaG9yOiB2bm9kZS5hbmNob3JcclxuICAgIH07XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBEZXYgb25seSwgZm9yIEhNUiBvZiBob2lzdGVkIHZub2RlcyByZXVzZWQgaW4gdi1mb3JcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy8yMDIyXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xyXG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gJyAnLCBmbGFnID0gMCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xyXG4gICAgLy8gQSBzdGF0aWMgdm5vZGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgc3RyaW5naWZpZWQgZWxlbWVudHMsIGFuZCB0aGUgbnVtYmVyXHJcbiAgICAvLyBvZiBlbGVtZW50cyBpcyBuZWNlc3NhcnkgZm9yIGh5ZHJhdGlvbi5cclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcclxuICAgIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gJycsIFxyXG4vLyB3aGVuIHVzZWQgYXMgdGhlIHYtZWxzZSBicmFuY2gsIHRoZSBjb21tZW50IG5vZGUgbXVzdCBiZSBjcmVhdGVkIGFzIGFcclxuLy8gYmxvY2sgdG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcy5cclxuYXNCbG9jayA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gYXNCbG9ja1xyXG4gICAgICAgID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50JDEsIG51bGwsIHRleHQpKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCQxLCBudWxsLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xyXG4gICAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAvLyBlbXB0eSBwbGFjZWhvbGRlclxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50JDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcclxuICAgICAgICAvLyBmcmFnbWVudFxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShGcmFnbWVudCwgbnVsbCwgXHJcbiAgICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXHJcbiAgICAgICAgY2hpbGQuc2xpY2UoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSB2bm9kZSwgdGhpcyBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHNpbmNlIGNvbXBpbGVkIHRlbXBsYXRlc1xyXG4gICAgICAgIC8vIGFsd2F5cyBwcm9kdWNlIGFsbC12bm9kZSBjaGlsZHJlbiBhcnJheXNcclxuICAgICAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3RyaW5ncyBhbmQgbnVtYmVyc1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcclxuICAgIH1cclxufVxyXG4vLyBvcHRpbWl6ZWQgbm9ybWFsaXphdGlvbiBmb3IgdGVtcGxhdGUtY29tcGlsZWQgcmVuZGVyIGZuc1xyXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcclxuICAgIGxldCB0eXBlID0gMDtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fCBzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgc2xvdCB0byBwbGFpbiBjaGlsZHJlbiBmb3IgcGxhaW4gZWxlbWVudCBhbmQgVGVsZXBvcnRcclxuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBfYyBtYXJrZXIgaXMgYWRkZWQgYnkgd2l0aEN0eCgpIGluZGljYXRpbmcgdGhpcyBpcyBhIGNvbXBpbGVkIHNsb3RcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcclxuICAgICAgICAgICAgaWYgKCFzbG90RmxhZyAmJiAhKEludGVybmFsT2JqZWN0S2V5IGluIGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAvKiBGT1JXQVJERUQgKi8gJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIGNoaWxkIGNvbXBvbmVudCByZWNlaXZlcyBmb3J3YXJkZWQgc2xvdHMgZnJvbSB0aGUgcGFyZW50LlxyXG4gICAgICAgICAgICAgICAgLy8gaXRzIHNsb3QgdHlwZSBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBwYXJlbnQncyBzbG90IHR5cGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDEgLyogU1RBQkxFICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDIgLyogRFlOQU1JQyAqLztcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xyXG4gICAgICAgIHR5cGUgPSAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcclxuICAgICAgICAvLyBmb3JjZSB0ZWxlcG9ydCBjaGlsZHJlbiB0byBhcnJheSBzbyBpdCBjYW4gYmUgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLztcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gOCAvKiBURVhUX0NISUxEUkVOICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHJldCA9IGV4dGVuZCh7fSwgYXJnc1swXSk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgIT09IGluY29taW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jb21pbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBBY3R1YWwgaW1wbGVtZW50YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtKSB7XHJcbiAgICBsZXQgcmV0O1xyXG4gICAgaWYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtpXSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShpICsgMSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgIGlmIChzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSkge1xyXG4gICAgICAgICAgICByZXQgPSBBcnJheS5mcm9tKHNvdXJjZSwgcmVuZGVySXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXQgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciBjcmVhdGluZyBkeW5hbWljIHNsb3RzIG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xyXG4gICAgICAgIC8vIGFycmF5IG9mIGR5bmFtaWMgc2xvdCBnZW5lcmF0ZWQgYnkgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgI1suLi5dPlxyXG4gICAgICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAvLyBjb25kaXRpb25hbCBzaW5nbGUgc2xvdCBnZW5lcmF0ZWQgYnkgPHRlbXBsYXRlIHYtaWY9XCIuLi5cIiAjZm9vPlxyXG4gICAgICAgICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5mbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2xvdHM7XHJcbn1cblxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgYDxzbG90Lz5gXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBcclxuLy8gdGhpcyBpcyBub3QgYSB1c2VyLWZhY2luZyBmdW5jdGlvbiwgc28gdGhlIGZhbGxiYWNrIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnlcclxuLy8gdGhlIGNvbXBpbGVyIGFuZCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5XHJcbmZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcclxuICAgIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgd2FybihgU1NSLW9wdGltaXplZCBzbG90IGZ1bmN0aW9uIGRldGVjdGVkIGluIGEgbm9uLVNTUi1vcHRpbWl6ZWQgcmVuZGVyIGAgK1xyXG4gICAgICAgICAgICBgZnVuY3Rpb24uIFlvdSBuZWVkIHRvIG1hcmsgdGhpcyBjb21wb25lbnQgd2l0aCAkZHluYW1pYy1zbG90cyBpbiB0aGUgYCArXHJcbiAgICAgICAgICAgIGBwYXJlbnQgdGVtcGxhdGUuYCk7XHJcbiAgICAgICAgc2xvdCA9ICgpID0+IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gYSBjb21waWxlZCBzbG90IGRpc2FibGVzIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHQgdG8gYXZvaWQgbWFudWFsXHJcbiAgICAvLyBpbnZvY2F0aW9uIGludGVyZmVyaW5nIHdpdGggdGVtcGxhdGUtYmFzZWQgYmxvY2sgdHJhY2tpbmcsIGJ1dCBpblxyXG4gICAgLy8gYHJlbmRlclNsb3RgIHdlIGNhbiBiZSBzdXJlIHRoYXQgaXQncyB0ZW1wbGF0ZS1iYXNlZCBzbyB3ZSBjYW4gZm9yY2VcclxuICAgIC8vIGVuYWJsZSBpdC5cclxuICAgIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcclxuICAgICAgICBzbG90Ll9kID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBvcGVuQmxvY2soKTtcclxuICAgIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xyXG4gICAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhGcmFnbWVudCwgeyBrZXk6IHByb3BzLmtleSB8fCBgXyR7bmFtZX1gIH0sIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSwgdmFsaWRTbG90Q29udGVudCAmJiBzbG90cy5fID09PSAxIC8qIFNUQUJMRSAqL1xyXG4gICAgICAgID8gNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXHJcbiAgICAgICAgOiAtMiAvKiBCQUlMICovKTtcclxuICAgIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcclxuICAgICAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArICctcyddO1xyXG4gICAgfVxyXG4gICAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xyXG4gICAgICAgIHNsb3QuX2QgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbmRlcmVkO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XHJcbiAgICByZXR1cm4gdm5vZGVzLnNvbWUoY2hpbGQgPT4ge1xyXG4gICAgICAgIGlmICghaXNWTm9kZShjaGlsZCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50JDEpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiZcclxuICAgICAgICAgICAgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KVxyXG4gICAgICAgID8gdm5vZGVzXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgcHJlZml4aW5nIGtleXMgaW4gdi1vbj1cIm9ialwiIHdpdGggXCJvblwiXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaikge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXRbdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiAjMjQzNyBJbiBWdWUgMywgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGEgcHVibGljIGluc3RhbmNlIHByb3h5IGJ1dFxyXG4gKiB0aGV5IGV4aXN0IGluIHRoZSBpbnRlcm5hbCBwYXJlbnQgY2hhaW4uIEZvciBjb2RlIHRoYXQgcmVsaWVzIG9uIHRyYXZlcnNpbmdcclxuICogcHVibGljICRwYXJlbnQgY2hhaW5zLCBza2lwIGZ1bmN0aW9uYWwgb25lcyBhbmQgZ28gdG8gdGhlIHBhcmVudCBpbnN0ZWFkLlxyXG4gKi9cclxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xyXG4gICAgaWYgKCFpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpXHJcbiAgICAgICAgcmV0dXJuIGkuZXhwb3NlZCA/IGkuZXhwb3NlZCA6IGkucHJveHk7XHJcbiAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xyXG59O1xyXG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHtcclxuICAgICQ6IGkgPT4gaSxcclxuICAgICRlbDogaSA9PiBpLnZub2RlLmVsLFxyXG4gICAgJGRhdGE6IGkgPT4gaS5kYXRhLFxyXG4gICAgJHByb3BzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzKSxcclxuICAgICRhdHRyczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyksXHJcbiAgICAkc2xvdHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMpLFxyXG4gICAgJHJlZnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzKSxcclxuICAgICRwYXJlbnQ6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxyXG4gICAgJHJvb3Q6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcclxuICAgICRlbWl0OiBpID0+IGkuZW1pdCxcclxuICAgICRvcHRpb25zOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUpLFxyXG4gICAgJGZvcmNlVXBkYXRlOiBpID0+ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSxcclxuICAgICRuZXh0VGljazogaSA9PiBuZXh0VGljay5iaW5kKGkucHJveHkpLFxyXG4gICAgJHdhdGNoOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUClcclxufSk7XHJcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcclxuICAgIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIC8vIGxldCBAdnVlL3JlYWN0aXZpdHkga25vdyBpdCBzaG91bGQgbmV2ZXIgb2JzZXJ2ZSBWdWUgcHVibGljIGluc3RhbmNlcy5cclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIgLyogU0tJUCAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZm9yIGludGVybmFsIGZvcm1hdHRlcnMgdG8ga25vdyB0aGF0IHRoaXMgaXMgYSBWdWUgaW5zdGFuY2VcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSA9PT0gJ19faXNWdWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkYXRhIC8gcHJvcHMgLyBjdHhcclxuICAgICAgICAvLyBUaGlzIGdldHRlciBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgcHJvcGVydHkgYWNjZXNzIG9uIHRoZSByZW5kZXIgY29udGV4dFxyXG4gICAgICAgIC8vIGR1cmluZyByZW5kZXIgYW5kIGlzIGEgbWFqb3IgaG90c3BvdC4gVGhlIG1vc3QgZXhwZW5zaXZlIHBhcnQgb2YgdGhpc1xyXG4gICAgICAgIC8vIGlzIHRoZSBtdWx0aXBsZSBoYXNPd24oKSBjYWxscy4gSXQncyBtdWNoIGZhc3RlciB0byBkbyBhIHNpbXBsZSBwcm9wZXJ0eVxyXG4gICAgICAgIC8vIGFjY2VzcyBvbiBhIHBsYWluIG9iamVjdCwgc28gd2UgdXNlIGFuIGFjY2Vzc0NhY2hlIG9iamVjdCAod2l0aCBudWxsXHJcbiAgICAgICAgLy8gcHJvdG90eXBlKSB0byBtZW1vaXplIHdoYXQgYWNjZXNzIHR5cGUgYSBrZXkgY29ycmVzcG9uZHMgdG8uXHJcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcclxuICAgICAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBTRVRVUCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogREFUQSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogQ09OVEVYVCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBQUk9QUyAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdDoganVzdCBmYWxsdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogU0VUVVAgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogREFUQSAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmXHJcbiAgICAgICAgICAgICAgICBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMiAvKiBQUk9QUyAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIE9USEVSICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcclxuICAgICAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xyXG4gICAgICAgIC8vIHB1YmxpYyAkeHh4IHByb3BlcnRpZXNcclxuICAgICAgICBpZiAocHVibGljR2V0dGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICckYXR0cnMnKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcclxuICAgICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmXHJcbiAgICAgICAgICAgIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNzc01vZHVsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xyXG4gICAgICAgICAgICAvLyB1c2VyIG1heSBzZXQgY3VzdG9tIHByb3BlcnRpZXMgdG8gYHRoaXNgIHRoYXQgc3RhcnQgd2l0aCBgJGBcclxuICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogQ09OVEVYVCAqLztcclxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xyXG4gICAgICAgICgoZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpLFxyXG4gICAgICAgICAgICBoYXNPd24oZ2xvYmFsUHJvcGVydGllcywga2V5KSkpIHtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmXHJcbiAgICAgICAgICAgICghaXNTdHJpbmcoa2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcclxuICAgICAgICAgICAgICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAga2V5LmluZGV4T2YoJ19fdicpICE9PSAwKSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmXHJcbiAgICAgICAgICAgICAgICAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpICYmXHJcbiAgICAgICAgICAgICAgICBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBgICtcclxuICAgICAgICAgICAgICAgICAgICBgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgaGFzKHsgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfSB9LCBrZXkpIHtcclxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xyXG4gICAgICAgIHJldHVybiAoYWNjZXNzQ2FjaGVba2V5XSAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHx8XHJcbiAgICAgICAgICAgICgobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICBoYXNPd24oY3R4LCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKTtcclxuICAgIH1cclxufTtcclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UpIHtcclxuICAgIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBgICtcclxuICAgICAgICAgICAgYFRoZSBrZXlzIHdpbGwgYmUgZW1wdHkgaW4gcHJvZHVjdGlvbiBtb2RlIHRvIGF2b2lkIHBlcmZvcm1hbmNlIG92ZXJoZWFkLmApO1xyXG4gICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcclxuICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdW5zY29wYWJsZXMgd2hlbiB1c2luZyBgd2l0aGAgYmxvY2tcclxuICAgICAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcclxuICAgIH0sXHJcbiAgICBoYXMoXywga2V5KSB7XHJcbiAgICAgICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSAnXycgJiYgIWlzR2xvYmFsbHlXaGl0ZWxpc3RlZChrZXkpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcclxuICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhcztcclxuICAgIH1cclxufSk7XHJcbi8vIEluIGRldiBtb2RlLCB0aGUgcHJveHkgdGFyZ2V0IGV4cG9zZXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBzZWVuIG9uIGB0aGlzYFxyXG4vLyBmb3IgZWFzaWVyIGNvbnNvbGUgaW5zcGVjdGlvbi4gSW4gcHJvZCBtb2RlIGl0IHdpbGwgYmUgYW4gZW1wdHkgb2JqZWN0IHNvXHJcbi8vIHRoZXNlIHByb3BlcnRpZXMgZGVmaW5pdGlvbnMgY2FuIGJlIHNraXBwZWQuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xyXG4gICAgLy8gZXhwb3NlIGludGVybmFsIGluc3RhbmNlIGZvciBwcm94eSBoYW5kbGVyc1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2VcclxuICAgIH0pO1xyXG4gICAgLy8gZXhwb3NlIHB1YmxpYyBwcm9wZXJ0aWVzXHJcbiAgICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcclxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxyXG4gICAgICAgICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xyXG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpIHtcclxuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgYCArXHJcbiAgICAgICAgICAgICAgICBgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxubGV0IHVpZCQxID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xyXG4gICAgLy8gaW5oZXJpdCBwYXJlbnQgYXBwIGNvbnRleHQgLSBvciAtIGlmIHJvb3QsIGFkb3B0IGZyb20gcm9vdCB2bm9kZVxyXG4gICAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcclxuICAgIGNvbnN0IGluc3RhbmNlID0ge1xyXG4gICAgICAgIHVpZDogdWlkJDErKyxcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBhcHBDb250ZXh0LFxyXG4gICAgICAgIHJvb3Q6IG51bGwsXHJcbiAgICAgICAgbmV4dDogbnVsbCxcclxuICAgICAgICBzdWJUcmVlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZTogbnVsbCxcclxuICAgICAgICByZW5kZXI6IG51bGwsXHJcbiAgICAgICAgcHJveHk6IG51bGwsXHJcbiAgICAgICAgZXhwb3NlZDogbnVsbCxcclxuICAgICAgICB3aXRoUHJveHk6IG51bGwsXHJcbiAgICAgICAgZWZmZWN0czogbnVsbCxcclxuICAgICAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcclxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcclxuICAgICAgICByZW5kZXJDYWNoZTogW10sXHJcbiAgICAgICAgLy8gbG9jYWwgcmVzb3ZsZWQgYXNzZXRzXHJcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcclxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxyXG4gICAgICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXHJcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgLy8gZW1pdFxyXG4gICAgICAgIGVtaXQ6IG51bGwsXHJcbiAgICAgICAgZW1pdHRlZDogbnVsbCxcclxuICAgICAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxyXG4gICAgICAgIC8vIGluaGVyaXRBdHRyc1xyXG4gICAgICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXHJcbiAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICBjdHg6IEVNUFRZX09CSixcclxuICAgICAgICBkYXRhOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcHJvcHM6IEVNUFRZX09CSixcclxuICAgICAgICBhdHRyczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNsb3RzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcmVmczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcclxuICAgICAgICBzZXR1cENvbnRleHQ6IG51bGwsXHJcbiAgICAgICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxyXG4gICAgICAgIHN1c3BlbnNlLFxyXG4gICAgICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcclxuICAgICAgICBhc3luY0RlcDogbnVsbCxcclxuICAgICAgICBhc3luY1Jlc29sdmVkOiBmYWxzZSxcclxuICAgICAgICAvLyBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGJjOiBudWxsLFxyXG4gICAgICAgIGM6IG51bGwsXHJcbiAgICAgICAgYm06IG51bGwsXHJcbiAgICAgICAgbTogbnVsbCxcclxuICAgICAgICBidTogbnVsbCxcclxuICAgICAgICB1OiBudWxsLFxyXG4gICAgICAgIHVtOiBudWxsLFxyXG4gICAgICAgIGJ1bTogbnVsbCxcclxuICAgICAgICBkYTogbnVsbCxcclxuICAgICAgICBhOiBudWxsLFxyXG4gICAgICAgIHJ0ZzogbnVsbCxcclxuICAgICAgICBydGM6IG51bGwsXHJcbiAgICAgICAgZWM6IG51bGwsXHJcbiAgICAgICAgc3A6IG51bGxcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcclxuICAgIGluc3RhbmNlLmVtaXQgPSBlbWl0LmJpbmQobnVsbCwgaW5zdGFuY2UpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG59XHJcbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG5jb25zdCBnZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcclxuICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG59O1xyXG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb25maWcpIHtcclxuICAgIGNvbnN0IGFwcElzTmF0aXZlVGFnID0gY29uZmlnLmlzTmF0aXZlVGFnIHx8IE5PO1xyXG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi87XHJcbn1cclxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XHJcbiAgICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XHJcbiAgICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XHJcbiAgICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bFxyXG4gICAgICAgID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuICAgIHJldHVybiBzZXR1cFJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBgICtcclxuICAgICAgICAgICAgICAgIGBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDAuIGNyZWF0ZSByZW5kZXIgcHJveHkgcHJvcGVydHkgYWNjZXNzIGNhY2hlXHJcbiAgICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAvLyAxLiBjcmVhdGUgcHVibGljIGluc3RhbmNlIC8gcmVuZGVyIHByb3h5XHJcbiAgICAvLyBhbHNvIG1hcmsgaXQgcmF3IHNvIGl0J3MgbmV2ZXIgb2JzZXJ2ZWRcclxuICAgIGluc3RhbmNlLnByb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLiBjYWxsIHNldHVwKClcclxuICAgIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcclxuICAgIGlmIChzZXR1cCkge1xyXG4gICAgICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IChpbnN0YW5jZS5zZXR1cENvbnRleHQgPVxyXG4gICAgICAgICAgICBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGwpO1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzZXR1cCwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8sIFsocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsIHNldHVwQ29udGV4dF0pO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChpc1Byb21pc2Uoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1NTUikge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlIHNvIHNlcnZlci1yZW5kZXJlciBjYW4gd2FpdCBvbiBpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIHNldHVwIHJldHVybmVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGhlcmUgYW5kIHdhaXQgZm9yIHJlLWVudHJ5LlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBhbiBpbmxpbmUgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzVk5vZGUoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gYCArXHJcbiAgICAgICAgICAgICAgICBgcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGJpbmRpbmdzLlxyXG4gICAgICAgIC8vIGFzc3VtaW5nIGEgcmVuZGVyIGZ1bmN0aW9uIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaXMgcHJlc2VudC5cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0fWApO1xyXG4gICAgfVxyXG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxufVxyXG5sZXQgY29tcGlsZTtcclxuLy8gZGV2IG9ubHlcclxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xyXG4vKipcclxuICogRm9yIHJ1bnRpbWUtZG9tIHRvIHJlZ2lzdGVyIHRoZSBjb21waWxlci5cclxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xyXG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXHJcbiAgICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xyXG4gICAgICAgIC8vIGNvdWxkIGJlIHNldCBmcm9tIHNldHVwKClcclxuICAgICAgICBpZiAoY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChleHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgICAgICB9LCBjb21waWxlck9wdGlvbnMpLCBjb21wb25lbnRDb21waWxlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xyXG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXHJcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX3JjKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLndpdGhQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc3VwcG9ydCBmb3IgMi54IG9wdGlvbnNcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICEoZmFsc2UgKSkge1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gd2FybiBtaXNzaW5nIHRlbXBsYXRlL3JlbmRlclxyXG4gICAgLy8gdGhlIHJ1bnRpbWUgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgaW4gU1NSIGlzIGRvbmUgYnkgc2VydmVyLXJlbmRlclxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXHJcbiAgICAgICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGF0dHJIYW5kbGVycyA9IHtcclxuICAgIGdldDogKHRhcmdldCwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICB9LFxyXG4gICAgc2V0OiAoKSA9PiB7XHJcbiAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgZXhwb3NlID0gZXhwb3NlZCA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gcHJveHlSZWZzKGV4cG9zZWQpO1xyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAvLyBXZSB1c2UgZ2V0dGVycyBpbiBkZXYgaW4gY2FzZSBsaWJzIGxpa2UgdGVzdC11dGlscyBvdmVyd3JpdGUgaW5zdGFuY2VcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIChvdmVyd3JpdGVzIHNob3VsZCBub3QgYmUgZG9uZSBpbiBwcm9kKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0ckhhbmRsZXJzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IHNsb3RzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5zbG90cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBlbWl0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXR0cnM6IGluc3RhbmNlLmF0dHJzLFxyXG4gICAgICAgICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXHJcbiAgICAgICAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLy8gcmVjb3JkIGVmZmVjdHMgY3JlYXRlZCBkdXJpbmcgYSBjb21wb25lbnQncyBzZXR1cCgpIHNvIHRoYXQgdGhleSBjYW4gYmVcclxuLy8gc3RvcHBlZCB3aGVuIHRoZSBjb21wb25lbnQgdW5tb3VudHNcclxuZnVuY3Rpb24gcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChlZmZlY3QsIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAoaW5zdGFuY2UuZWZmZWN0cyB8fCAoaW5zdGFuY2UuZWZmZWN0cyA9IFtdKSkucHVzaChlZmZlY3QpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XHJcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KVxyXG4gICAgICAgID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lXHJcbiAgICAgICAgOiBDb21wb25lbnQubmFtZTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcclxuICAgIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSBuYW1lIGJhc2VkIG9uIHJldmVyc2UgcmVzb2x1dGlvblxyXG4gICAgICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbmFtZSA9XHJcbiAgICAgICAgICAgIGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmNvbXBvbmVudHMgfHxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHMpIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcclxufVxyXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgJ19fdmNjT3B0cycgaW4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XHJcbiAgICBjb25zdCBjID0gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMpO1xyXG4gICAgcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChjLmVmZmVjdCk7XHJcbiAgICByZXR1cm4gYztcclxufVxuXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBkZWZpbmVQcm9wcygpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYCArXHJcbiAgICAgICAgICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXHJcbiAgICAgICAgICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZUVtaXQoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgZGVmaW5lRW1pdCgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYCArXHJcbiAgICAgICAgICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXHJcbiAgICAgICAgICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHVzZUNvbnRleHQoKSB7XHJcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpKSB7XHJcbiAgICAgICAgd2FybihgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xyXG59XG5cbi8vIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgaWYgKGwgPT09IDIpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2bm9kZSB3aXRob3V0IHByb3BzXHJcbiAgICAgICAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHMgd2l0aG91dCBjaGlsZHJlblxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG9taXQgcHJvcHNcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGwgPiAzKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzc3JDb250ZXh0YCA6IGBgKTtcclxuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcclxuICAgIHtcclxuICAgICAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XHJcbiAgICAgICAgaWYgKCFjdHgpIHtcclxuICAgICAgICAgICAgd2FybihgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCBgICtcclxuICAgICAgICAgICAgICAgIGB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3R4O1xyXG4gICAgfVxyXG59O1xuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMzYmE3NzYnIH07XHJcbiAgICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojMGIxYmM5JyB9O1xyXG4gICAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6I2I2MmUyNCcgfTtcclxuICAgIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojOWQyODhjJyB9O1xyXG4gICAgLy8gY3VzdG9tIGZvcm1hdHRlciBmb3IgQ2hyb21lXHJcbiAgICAvLyBodHRwczovL3d3dy5tYXR0emV1bmVydC5jb20vMjAxNi8wMi8xOS9jdXN0b20tY2hyb21lLWRldnRvb2xzLW9iamVjdC1mb3JtYXR0ZXJzLmh0bWxcclxuICAgIGNvbnN0IGZvcm1hdHRlciA9IHtcclxuICAgICAgICBoZWFkZXIob2JqKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gYWxzbyBmb3JtYXQgQ29tcG9uZW50UHVibGljSW5zdGFuY2UgJiBjdHguc2xvdHMvYXR0cnMgaW4gc2V0dXBcclxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZihvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsICdSZWFjdGl2ZSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsICdSZWFkb25seSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgICc+J1xyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0JvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5KG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3Byb3BzJywgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnc2V0dXAnLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnZGF0YScsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdjb21wdXRlZCcpO1xyXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdjb21wdXRlZCcsIGNvbXB1dGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdpbmplY3QnKTtcclxuICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnaW5qZWN0ZWQnLCBpbmplY3RlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBibG9ja3MucHVzaChbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyAnO29wYWNpdHk6MC42NidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnJCAoaW50ZXJuYWwpOiAnXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsnb2JqZWN0JywgeyBvYmplY3Q6IGluc3RhbmNlIH1dXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xyXG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHt9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHsgc3R5bGU6ICdsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbScgfSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdjb2xvcjojNDc2NTgyJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdwYWRkaW5nLWxlZnQ6MS4yNWVtJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIGtleSArICc6ICddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgbnVtYmVyU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIGtleXdvcmRTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ29iamVjdCcsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRba2V5XSA9IGluc3RhbmNlLmN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcclxuICAgICAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcclxuICAgICAgICBpZiAoKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpKSB8fFxyXG4gICAgICAgICAgICAoaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUobSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcclxuICAgICAgICBpZiAodi5fc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodi5lZmZlY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgUmVmYDtcclxuICAgIH1cclxuICAgIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XHJcbiAgICB9XHJcbn1cblxuLy8gQ29yZSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmNvbnN0IHZlcnNpb24gPSBcIjMuMS4xXCI7XHJcbi8qKlxyXG4gKiBTU1IgdXRpbHMgZm9yIFxcQHZ1ZS9zZXJ2ZXItcmVuZGVyZXIuIE9ubHkgZXhwb3NlZCBpbiBjanMgYnVpbGRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHNzclV0aWxzID0gKG51bGwpO1xyXG4vKipcclxuICogQGludGVybmFsIG9ubHkgZXhwb3NlZCBpbiBjb21wYXQgYnVpbGRzXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkcy5cclxuICovXHJcbmNvbnN0IGNvbXBhdFV0aWxzID0gKG51bGwpO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQ29tbWVudCQxIGFzIENvbW1lbnQsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0LCBkZWZpbmVQcm9wcywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBoLCBoYW5kbGVFcnJvciwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VDb250ZXh0LCB1c2VTU1JDb250ZXh0LCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2l0aEN0eCwgd2l0aERpcmVjdGl2ZXMsIHdpdGhTY29wZUlkIH07XG4iLCJpbXBvcnQgeyBjYW1lbGl6ZSwgd2FybiwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGdldEN1cnJlbnRJbnN0YW5jZSwgb25Nb3VudGVkLCB3YXRjaEVmZmVjdCwgb25VcGRhdGVkLCBGcmFnbWVudCwgaCwgQmFzZVRyYW5zaXRpb24sIHVzZVRyYW5zaXRpb25TdGF0ZSwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBjcmVhdGVWTm9kZSwgY3JlYXRlUmVuZGVyZXIsIGlzUnVudGltZU9ubHksIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzQXJyYXksIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgaXNGdW5jdGlvbiwgRU1QVFlfT0JKLCBleHRlbmQsIGlzT2JqZWN0LCB0b051bWJlciwgaW52b2tlQXJyYXlGbnMsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGlzSFRNTFRhZywgaXNTVkdUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuY29uc3QgZG9jID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGwpO1xyXG5sZXQgdGVtcENvbnRhaW5lcjtcclxubGV0IHRlbXBTVkdDb250YWluZXI7XHJcbmNvbnN0IG5vZGVPcHMgPSB7XHJcbiAgICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBjaGlsZCA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIGlzU1ZHLCBpcywgcHJvcHMpID0+IHtcclxuICAgICAgICBjb25zdCBlbCA9IGlzU1ZHXHJcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKVxyXG4gICAgICAgICAgICA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgaXMgPyB7IGlzIH0gOiB1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdzZWxlY3QnICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsIHByb3BzLm11bHRpcGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVRleHQ6IHRleHQgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpLFxyXG4gICAgY3JlYXRlQ29tbWVudDogdGV4dCA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcclxuICAgIHNldFRleHQ6IChub2RlLCB0ZXh0KSA9PiB7XHJcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xyXG4gICAgfSxcclxuICAgIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcclxuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgcGFyZW50Tm9kZTogbm9kZSA9PiBub2RlLnBhcmVudE5vZGUsXHJcbiAgICBuZXh0U2libGluZzogbm9kZSA9PiBub2RlLm5leHRTaWJsaW5nLFxyXG4gICAgcXVlcnlTZWxlY3Rvcjogc2VsZWN0b3IgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxyXG4gICAgc2V0U2NvcGVJZChlbCwgaWQpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsICcnKTtcclxuICAgIH0sXHJcbiAgICBjbG9uZU5vZGUoZWwpIHtcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgLy8gIzMwNzJcclxuICAgICAgICAvLyAtIGluIGBwYXRjaERPTVByb3BgLCB3ZSBzdG9yZSB0aGUgYWN0dWFsIHZhbHVlIGluIHRoZSBgZWwuX3ZhbHVlYCBwcm9wZXJ0eS5cclxuICAgICAgICAvLyAtIG5vcm1hbGx5LCBlbGVtZW50cyB1c2luZyBgOnZhbHVlYCBiaW5kaW5ncyB3aWxsIG5vdCBiZSBob2lzdGVkLCBidXQgaWZcclxuICAgICAgICAvLyAgIHRoZSBib3VuZCB2YWx1ZSBpcyBhIGNvbnN0YW50LCBlLmcuIGA6dmFsdWU9XCJ0cnVlXCJgIC0gdGhleSBkbyBnZXRcclxuICAgICAgICAvLyAgIGhvaXN0ZWQuXHJcbiAgICAgICAgLy8gLSBpbiBwcm9kdWN0aW9uLCBob2lzdGVkIG5vZGVzIGFyZSBjbG9uZWQgd2hlbiBzdWJzZXF1ZW50IGluc2VydHMsIGJ1dFxyXG4gICAgICAgIC8vICAgY2xvbmVOb2RlKCkgZG9lcyBub3QgY29weSB0aGUgY3VzdG9tIHByb3BlcnR5IHdlIGF0dGFjaGVkLlxyXG4gICAgICAgIC8vIC0gVGhpcyBtYXkgbmVlZCB0byBhY2NvdW50IGZvciBvdGhlciBjdXN0b20gRE9NIHByb3BlcnRpZXMgd2UgYXR0YWNoIHRvXHJcbiAgICAgICAgLy8gICBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byBgX3ZhbHVlYCBpbiB0aGUgZnV0dXJlLlxyXG4gICAgICAgIGlmIChgX3ZhbHVlYCBpbiBlbCkge1xyXG4gICAgICAgICAgICBjbG9uZWQuX3ZhbHVlID0gZWwuX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xvbmVkO1xyXG4gICAgfSxcclxuICAgIC8vIF9fVU5TQUZFX19cclxuICAgIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxyXG4gICAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxyXG4gICAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cclxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIGlzU1ZHKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IGlzU1ZHXHJcbiAgICAgICAgICAgID8gdGVtcFNWR0NvbnRhaW5lciB8fFxyXG4gICAgICAgICAgICAgICAgKHRlbXBTVkdDb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCAnc3ZnJykpXHJcbiAgICAgICAgICAgIDogdGVtcENvbnRhaW5lciB8fCAodGVtcENvbnRhaW5lciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XHJcbiAgICAgICAgdGVtcC5pbm5lckhUTUwgPSBjb250ZW50O1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdGVtcC5maXJzdENoaWxkO1xyXG4gICAgICAgIGxldCBub2RlID0gZmlyc3Q7XHJcbiAgICAgICAgbGV0IGxhc3QgPSBub2RlO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGxhc3QgPSBub2RlO1xyXG4gICAgICAgICAgICBub2RlT3BzLmluc2VydChub2RlLCBwYXJlbnQsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIG5vZGUgPSB0ZW1wLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbZmlyc3QsIGxhc3RdO1xyXG4gICAgfVxyXG59O1xuXG4vLyBjb21waWxlciBzaG91bGQgbm9ybWFsaXplIGNsYXNzICsgOmNsYXNzIGJpbmRpbmdzIG9uIHRoZSBzYW1lIGVsZW1lbnRcclxuLy8gaW50byBhIHNpbmdsZSBiaW5kaW5nIFsnc3RhdGljQ2xhc3MnLCBkeW5hbWljXVxyXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdmFsdWUgPSAnJztcclxuICAgIH1cclxuICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkaXJlY3RseSBzZXR0aW5nIGNsYXNzTmFtZSBzaG91bGQgYmUgZmFzdGVyIHRoYW4gc2V0QXR0cmlidXRlIGluIHRoZW9yeVxyXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gZWxlbWVudCBkdXJpbmcgYSB0cmFuc2l0aW9uLCB0YWtlIHRoZSB0ZW1wb3JhcnkgdHJhbnNpdGlvblxyXG4gICAgICAgIC8vIGNsYXNzZXMgaW50byBhY2NvdW50LlxyXG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3Z0YztcclxuICAgICAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWVcclxuICAgICAgICAgICAgICAgID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc11cclxuICAgICAgICAgICAgICAgIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgaWYgKCFuZXh0KSB7XHJcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcobmV4dCkpIHtcclxuICAgICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gc3R5bGUuZGlzcGxheTtcclxuICAgICAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHRoZSBgZGlzcGxheWAgb2YgdGhlIGVsZW1lbnQgaXMgY29udHJvbGxlZCBieSBgdi1zaG93YCxcclxuICAgICAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWAgdmFsdWUsXHJcbiAgICAgICAgICAgIC8vIHRodXMgaGFuZGluZyBvdmVyIGNvbnRyb2wgdG8gYHYtc2hvd2AuXHJcbiAgICAgICAgICAgIGlmICgnX3ZvZCcgaW4gZWwpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xyXG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldiAmJiAhaXNTdHJpbmcocHJldikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XHJcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcclxuICAgICAgICB2YWwuZm9yRWFjaCh2ID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCctLScpKSB7XHJcbiAgICAgICAgICAgIC8vIGN1c3RvbSBwcm9wZXJ0eSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAhaW1wb3J0YW50XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUocHJlZml4ZWQpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcclxuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XHJcbiAgICBpZiAobmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSBpbiBzdHlsZSkge1xyXG4gICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lKTtcclxuICAgIH1cclxuICAgIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xyXG4gICAgICAgIGlmIChwcmVmaXhlZCBpbiBzdHlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByYXdOYW1lO1xyXG59XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlKSB7XHJcbiAgICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoJ3hsaW5rOicpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vdGUgd2UgYXJlIG9ubHkgY2hlY2tpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgZG9uJ3QgaGF2ZSBhXHJcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkb20gcHJvcCBvZiB0aGUgc2FtZSBuYW1lIGhlcmUuXHJcbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaXNCb29sZWFuICYmIHZhbHVlID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cclxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgPT09ICcnICYmIHR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxzZWxlY3QgbXVsdGlwbGU+IGNvbXBpbGVzIHRvIHsgbXVsdGlwbGU6ICcnIH1cclxuICAgICAgICAgICAgZWxba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxkaXYgOmlkPVwibnVsbFwiPlxyXG4gICAgICAgICAgICBlbFtrZXldID0gJyc7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGltZyA6d2lkdGg9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSAwO1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBwZXJmb3JtIHZhbHVlIHZhbGlkYXRpb24gYW5kIHRocm93XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7ZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgYHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXHJcbmxldCBfZ2V0Tm93ID0gRGF0ZS5ub3c7XHJcbmxldCBza2lwVGltZXN0YW1wQ2hlY2sgPSBmYWxzZTtcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxyXG4gICAgLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuICAgIC8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxyXG4gICAgLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxyXG4gICAgaWYgKF9nZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXHJcbiAgICAgICAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcclxuICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cclxuICAgICAgICBfZ2V0Tm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcbiAgICAvLyAjMzQ4NTogRmlyZWZveCA8PSA1MyBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzbyBzYWZlIHRvIGV4Y2x1ZGUuXHJcbiAgICBjb25zdCBmZk1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcclxuICAgIHNraXBUaW1lc3RhbXBDaGVjayA9ICEhKGZmTWF0Y2ggJiYgTnVtYmVyKGZmTWF0Y2hbMV0pIDw9IDUzKTtcclxufVxyXG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpLCB3ZSBjYWNoZVxyXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxyXG5sZXQgY2FjaGVkTm93ID0gMDtcclxuY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCByZXNldCA9ICgpID0+IHtcclxuICAgIGNhY2hlZE5vdyA9IDA7XHJcbn07XHJcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKHJlc2V0KSwgKGNhY2hlZE5vdyA9IF9nZXROb3coKSkpO1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcclxuICAgIC8vIHZlaSA9IHZ1ZSBldmVudCBpbnZva2Vyc1xyXG4gICAgY29uc3QgaW52b2tlcnMgPSBlbC5fdmVpIHx8IChlbC5fdmVpID0ge30pO1xyXG4gICAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XHJcbiAgICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgIC8vIHBhdGNoXHJcbiAgICAgICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xyXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gYWRkXHJcbiAgICAgICAgICAgIGNvbnN0IGludm9rZXIgPSAoaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgICAgICAvLyByZW1vdmVcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xyXG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xyXG4gICAgbGV0IG9wdGlvbnM7XHJcbiAgICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtoeXBoZW5hdGUobmFtZS5zbGljZSgyKSksIG9wdGlvbnNdO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XHJcbiAgICAgICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXHJcbiAgICAgICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXHJcbiAgICAgICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcclxuICAgICAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wID0gZS50aW1lU3RhbXAgfHwgX2dldE5vdygpO1xyXG4gICAgICAgIGlmIChza2lwVGltZXN0YW1wQ2hlY2sgfHwgdGltZVN0YW1wID49IGludm9rZXIuYXR0YWNoZWQgLSAxKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLCBpbnN0YW5jZSwgNSAvKiBOQVRJVkVfRVZFTlRfSEFORExFUiAqLywgW2VdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcclxuICAgIHJldHVybiBpbnZva2VyO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcclxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XHJcbiAgICAgICAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmbiA9PiAoZSkgPT4gIWUuX3N0b3BwZWQgJiYgZm4oZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5hdGl2ZU9uUkUgPSAvXm9uW2Etel0vO1xyXG5jb25zdCBmb3JjZVBhdGNoUHJvcCA9IChfLCBrZXkpID0+IGtleSA9PT0gJ3ZhbHVlJztcclxuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAvLyBzcGVjaWFsXHJcbiAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG4gICAgICAgICAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3R5bGUnOlxyXG4gICAgICAgICAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxpbnB1dCB2LW1vZGVsIHR5cGU9XCJjaGVja2JveFwiPiB3aXRoXHJcbiAgICAgICAgICAgICAgICAvLyA6dHJ1ZS12YWx1ZSAmIDpmYWxzZS12YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgZG9tIHByb3BlcnRpZXMgc2luY2Ugbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndHJ1ZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZmFsc2UtdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcclxuICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgIC8vIG1vc3Qga2V5cyBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGUgb24gc3ZnIGVsZW1lbnRzIHRvIHdvcmtcclxuICAgICAgICAvLyAuLi5leGNlcHQgaW5uZXJIVE1MXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yIG5hdGl2ZSBvbmNsaWNrIHdpdGggZnVuY3Rpb24gdmFsdWVzXHJcbiAgICAgICAgaWYgKGtleSBpbiBlbCAmJiBuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gc3BlbGxjaGVjayBhbmQgZHJhZ2dhYmxlIGFyZSBudW1lcmF0ZWQgYXR0cnMsIGhvd2V2ZXIgdGhlaXJcclxuICAgIC8vIGNvcnJlc3BvbmRpbmcgRE9NIHByb3BlcnRpZXMgYXJlIGFjdHVhbGx5IGJvb2xlYW5zIC0gdGhpcyBsZWFkcyB0b1xyXG4gICAgLy8gc2V0dGluZyBpdCB3aXRoIGEgc3RyaW5nIFwiZmFsc2VcIiB2YWx1ZSBsZWFkaW5nIGl0IHRvIGJlIGNvZXJjZWQgdG9cclxuICAgIC8vIGB0cnVlYCwgc28gd2UgbmVlZCB0byBhbHdheXMgdHJlYXQgdGhlbSBhcyBhdHRyaWJ1dGVzLlxyXG4gICAgLy8gTm90ZSB0aGF0IGBjb250ZW50RWRpdGFibGVgIGRvZXNuJ3QgaGF2ZSB0aGlzIHByb2JsZW06IGl0cyBET01cclxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gZW51bWVyYXRlZCBzdHJpbmcgdmFsdWVzLlxyXG4gICAgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snIHx8IGtleSA9PT0gJ2RyYWdnYWJsZScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTc4NywgIzI4NDAgZm9ybSBwcm9wZXJ0eSBvbiBmb3JtIGVsZW1lbnRzIGlzIHJlYWRvbmx5IGFuZCBtdXN0IGJlIHNldCBhc1xyXG4gICAgLy8gYXR0cmlidXRlLlxyXG4gICAgaWYgKGtleSA9PT0gJ2Zvcm0nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzE1MjYgPGlucHV0IGxpc3Q+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKGtleSA9PT0gJ2xpc3QnICYmIGVsLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMjc2NiA8dGV4dGFyZWEgdHlwZT4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAndHlwZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIG5hdGl2ZSBvbmNsaWNrIHdpdGggc3RyaW5nIHZhbHVlLCBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5IGluIGVsO1xyXG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gJyRzdHlsZScpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xyXG4gICAgICAgIGlmICghbW9kdWxlcykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNldFZhcnMgPSAoKSA9PiBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB3YXRjaEVmZmVjdChzZXRWYXJzLCB7IGZsdXNoOiAncG9zdCcgfSkpO1xyXG4gICAgb25VcGRhdGVkKHNldFZhcnMpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcclxuICAgICAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcclxuICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGRyaWxsIGRvd24gSE9DcyB1bnRpbCBpdCdzIGEgbm9uLWNvbXBvbmVudCB2bm9kZVxyXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICB9XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIHZub2RlLmVsKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB2bm9kZS5lbC5zdHlsZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbmNvbnN0IEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBET00gVHJhbnNpdGlvbiBpcyBhIGhpZ2hlci1vcmRlci1jb21wb25lbnQgYmFzZWQgb24gdGhlIHBsYXRmb3JtLWFnbm9zdGljXHJcbi8vIGJhc2UgVHJhbnNpdGlvbiBjb21wb25lbnQsIHdpdGggRE9NLXNwZWNpZmljIGxvZ2ljLlxyXG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XHJcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSAnVHJhbnNpdGlvbic7XHJcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBjc3M6IHtcclxuICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxyXG4gICAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nXHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAoVHJhbnNpdGlvbi5wcm9wcyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBCYXNlVHJhbnNpdGlvbi5wcm9wcywgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpO1xyXG4vKipcclxuICogIzMyMjcgSW5jb21pbmcgaG9va3MgbWF5IGJlIG1lcmdlZCBpbnRvIGFycmF5cyB3aGVuIHdyYXBwaW5nIFRyYW5zaXRpb25cclxuICogd2l0aCBjdXN0b20gSE9Dcy5cclxuICovXHJcbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xyXG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICBob29rLmZvckVhY2goaCA9PiBoKC4uLmFyZ3MpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhvb2spIHtcclxuICAgICAgICBob29rKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQ2hlY2sgaWYgYSBob29rIGV4cGVjdHMgYSBjYWxsYmFjayAoMm5kIGFyZyksIHdoaWNoIG1lYW5zIHRoZSB1c2VyXHJcbiAqIGludGVuZHMgdG8gZXhwbGljaXRseSBjb250cm9sIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcclxuICAgIHJldHVybiBob29rXHJcbiAgICAgICAgPyBpc0FycmF5KGhvb2spXHJcbiAgICAgICAgICAgID8gaG9vay5zb21lKGggPT4gaC5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgICA6IGhvb2subGVuZ3RoID4gMVxyXG4gICAgICAgIDogZmFsc2U7XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcclxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcclxuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VQcm9wcztcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbmFtZSA9ICd2JywgdHlwZSwgZHVyYXRpb24sIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLCBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLCBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2AgfSA9IHJhd1Byb3BzO1xyXG4gICAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xyXG4gICAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XHJcbiAgICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcclxuICAgIGNvbnN0IHsgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25MZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLCBvbkFwcGVhciA9IG9uRW50ZXIsIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZCB9ID0gYmFzZVByb3BzO1xyXG4gICAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xyXG4gICAgICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xyXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXHJcbiAgICAgICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXHJcbiAgICAgICAgb25MZWF2ZShlbCwgZG9uZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHNvICotbGVhdmUtZnJvbSBjbGFzc2VzIGltbWVkaWF0ZWx5IHRha2UgZWZmZWN0ICgjMjU5MylcclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBbbiwgbl07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XHJcbiAgICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uKHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXHJcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgTmFOIC0gYCArXHJcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgKGVsLl92dGMgfHxcclxuICAgICAgICAoZWwuX3Z0YyA9IG5ldyBTZXQoKSkpLmFkZChjbHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XHJcbiAgICBpZiAoX3Z0Yykge1xyXG4gICAgICAgIF92dGMuZGVsZXRlKGNscyk7XHJcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcclxuICAgICAgICAgICAgZWwuX3Z0YyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XHJcbiAgICB9KTtcclxufVxyXG5sZXQgZW5kSWQgPSAwO1xyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XHJcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcclxuICAgIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArICdlbmQnO1xyXG4gICAgbGV0IGVuZGVkID0gMDtcclxuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcclxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbiAgICAgICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQgKyAxKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuICAgIGxldCB0eXBlID0gbnVsbDtcclxuICAgIGxldCB0aW1lb3V0ID0gMDtcclxuICAgIGxldCBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxyXG4gICAgICAgIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChzdHlsZXNbVFJBTlNJVElPTiArICdQcm9wZXJ0eSddKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxyXG4vLyBudW1iZXJzIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93blxyXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxyXG4vLyBzeW5jaHJvbm91c2x5IGZvcmNlIGxheW91dCB0byBwdXQgZWxlbWVudHMgaW50byBhIGNlcnRhaW4gc3RhdGVcclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XHJcbiAgICBuYW1lOiAnVHJhbnNpdGlvbkdyb3VwJyxcclxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xyXG4gICAgICAgIHRhZzogU3RyaW5nLFxyXG4gICAgICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbiAgICB9KSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZDaGlsZHJlbjtcclxuICAgICAgICBsZXQgY2hpbGRyZW47XHJcbiAgICAgICAgb25VcGRhdGVkKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCAndid9LW1vdmVgO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShwcmV2Q2hpbGRyZW5bMF0uZWwsIGluc3RhbmNlLnZub2RlLmVsLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IChlbC5fbW92ZUNiID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XHJcbiAgICAgICAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xyXG4gICAgY29uc3QgZWwgPSBjLmVsO1xyXG4gICAgaWYgKGVsLl9tb3ZlQ2IpIHtcclxuICAgICAgICBlbC5fbW92ZUNiKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICBlbC5fZW50ZXJDYigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcclxuICAgIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcclxuICAgIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcclxuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgICBpZiAoZHggfHwgZHkpIHtcclxuICAgICAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcclxuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcclxuICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xyXG4gICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXHJcbiAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcclxuICAgIC8vIGlzIGFwcGxpZWQuXHJcbiAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xyXG4gICAgaWYgKGVsLl92dGMpIHtcclxuICAgICAgICBlbC5fdnRjLmZvckVhY2goY2xzID0+IHtcclxuICAgICAgICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAocm9vdC5ub2RlVHlwZSA9PT0gMVxyXG4gICAgICAgID8gcm9vdFxyXG4gICAgICAgIDogcm9vdC5wYXJlbnROb2RlKTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcclxuICAgIHJldHVybiBoYXNUcmFuc2Zvcm07XHJcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xyXG4gICAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1snb25VcGRhdGU6bW9kZWxWYWx1ZSddO1xyXG4gICAgcmV0dXJuIGlzQXJyYXkoZm4pID8gdmFsdWUgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xyXG59O1xyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xyXG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcclxuICAgICAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsICdpbnB1dCcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcclxuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xyXG59XHJcbi8vIFdlIGFyZSBleHBvcnRpbmcgdGhlIHYtbW9kZWwgcnVudGltZSBkaXJlY3RseSBhcyB2bm9kZSBob29rcyBzbyB0aGF0IGl0IGNhblxyXG4vLyBiZSB0cmVlLXNoYWtlbiBpbiBjYXNlIHYtbW9kZWwgaXMgbmV2ZXIgdXNlZC5cclxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJztcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gJ2NoYW5nZScgOiAnaW5wdXQnLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjYXN0VG9OdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gdG9OdW1iZXIoZG9tVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZG9tVmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGF6eSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXHJcbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxyXG4gICAgICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIC8vIGF2b2lkIGNsZWFyaW5nIHVucmVzb2x2ZWQgdGV4dC4gIzIzMDJcclxuICAgICAgICBpZiAoZWwuY29tcG9zaW5nKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJykgJiYgdG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXHJcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXJcclxuICAgICAgICAgICAgICAgIC5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgobykgPT4gbnVtYmVyID8gdG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobykpO1xyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGVsLm11bHRpcGxlXHJcbiAgICAgICAgICAgICAgICA/IGlzU2V0TW9kZWxcclxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFxyXG4gICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFswXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cclxuICAgIC8vIDxvcHRpb24+cy5cclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XHJcbiAgICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XHJcbiAgICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYCArXHJcbiAgICAgICAgICAgICAgICBgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcclxuICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XHJcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgIH1cclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgc2V0IHZpYSA6dmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcclxuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xyXG59XHJcbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBmb3IgdHJ1ZS12YWx1ZSBhbmQgZmFsc2UtdmFsdWUgc2V0IHZpYSA6dHJ1ZS12YWx1ZSBvciA6ZmFsc2UtdmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xyXG4gICAgY29uc3Qga2V5ID0gY2hlY2tlZCA/ICdfdHJ1ZVZhbHVlJyA6ICdfZmFsc2VWYWx1ZSc7XHJcbiAgICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XHJcbn1cclxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdjcmVhdGVkJyk7XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ21vdW50ZWQnKTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICd1cGRhdGVkJyk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcclxuICAgIGxldCBtb2RlbFRvVXNlO1xyXG4gICAgc3dpdGNoIChlbC50YWdOYW1lKSB7XHJcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFNlbGVjdDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxyXG4gICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsVGV4dDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgc3dpdGNoICh2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbENoZWNrYm94O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxSYWRpbztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcclxuICAgIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcclxufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXTtcclxuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XHJcbiAgICBzdG9wOiBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXHJcbiAgICBwcmV2ZW50OiBlID0+IGUucHJldmVudERlZmF1bHQoKSxcclxuICAgIHNlbGY6IGUgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcclxuICAgIGN0cmw6IGUgPT4gIWUuY3RybEtleSxcclxuICAgIHNoaWZ0OiBlID0+ICFlLnNoaWZ0S2V5LFxyXG4gICAgYWx0OiBlID0+ICFlLmFsdEtleSxcclxuICAgIG1ldGE6IGUgPT4gIWUubWV0YUtleSxcclxuICAgIGxlZnQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcclxuICAgIG1pZGRsZTogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxyXG4gICAgcmlnaHQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcclxuICAgIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZShtID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xyXG4gICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcclxuICAgICAgICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgfTtcclxufTtcclxuLy8gS2VwdCBmb3IgMi54IGNvbXBhdC5cclxuLy8gTm90ZTogSUUxMSBjb21wYXQgZm9yIGBzcGFjZWJhcmAgYW5kIGBkZWxgIGlzIHJlbW92ZWQgZm9yIG5vdy5cclxuY29uc3Qga2V5TmFtZXMgPSB7XHJcbiAgICBlc2M6ICdlc2NhcGUnLFxyXG4gICAgc3BhY2U6ICcgJyxcclxuICAgIHVwOiAnYXJyb3ctdXAnLFxyXG4gICAgbGVmdDogJ2Fycm93LWxlZnQnLFxyXG4gICAgcmlnaHQ6ICdhcnJvdy1yaWdodCcsXHJcbiAgICBkb3duOiAnYXJyb3ctZG93bicsXHJcbiAgICBkZWxldGU6ICdiYWNrc3BhY2UnXHJcbn07XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aEtleXMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xyXG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghKCdrZXknIGluIGV2ZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycy5zb21lKGsgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHZTaG93ID0ge1xyXG4gICAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBlbC5fdm9kID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xyXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX3ZvZCA6ICdub25lJztcclxufVxuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSBleHRlbmQoeyBwYXRjaFByb3AsIGZvcmNlUGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xyXG4vLyBsYXp5IGNyZWF0ZSB0aGUgcmVuZGVyZXIgLSB0aGlzIG1ha2VzIGNvcmUgcmVuZGVyZXIgbG9naWMgdHJlZS1zaGFrYWJsZVxyXG4vLyBpbiBjYXNlIHRoZSB1c2VyIG9ubHkgaW1wb3J0cyByZWFjdGl2aXR5IHV0aWxpdGllcyBmcm9tIFZ1ZS5cclxubGV0IHJlbmRlcmVyO1xyXG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcclxuICAgIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvblxyXG4gICAgICAgID8gcmVuZGVyZXJcclxuICAgICAgICA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XHJcbiAgICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJlcjtcclxufVxyXG4vLyB1c2UgZXhwbGljaXQgdHlwZSBjYXN0cyBoZXJlIHRvIGF2b2lkIGltcG9ydCgpIGNhbGxzIGluIHJvbGxlZC11cCBkLnRzXHJcbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBoeWRyYXRlID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXHJcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQnc1xyXG4gICAgICAgICAgICAvLyByZW5kZXJlZCBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNsZWFyIGNvbnRlbnQgYmVmb3JlIG1vdW50aW5nXHJcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLXYtYXBwJywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xyXG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xyXG4gICAgLy8gSW5qZWN0IGBpc05hdGl2ZVRhZ2BcclxuICAgIC8vIHRoaXMgaXMgdXNlZCBmb3IgY29tcG9uZW50IG5hbWUgdmFsaWRhdGlvbiAoZGV2IG9ubHkpXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzTmF0aXZlVGFnJywge1xyXG4gICAgICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XHJcbiAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc0N1c3RvbUVsZW1lbnQnLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBgICtcclxuICAgICAgICAgICAgYGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIGAgK1xyXG4gICAgICAgICAgICBgU2luY2UgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBjb21waWxlck9wdGlvbnNcXGAgYCArXHJcbiAgICAgICAgICAgIGBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItZG9tYDtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2NvbXBpbGVyT3B0aW9ucycsIHtcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiZcclxuICAgICAgICBjb250YWluZXIubW9kZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICB3YXJuKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG59XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGh5ZHJhdGUsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKiBJTVBPUlRBTlQ6IGFsbCBjYWxscyBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxyXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xyXG4gKiBTbyB0aGF0IHJvbGx1cCBjYW4gdHJlZS1zaGFrZSB0aGVtIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XHJcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xyXG59XG5cbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIC0+IG5hbWUgbWFwcGluZ1xyXG4gKi9cclxuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XHJcbiAgICBbMSAvKiBURVhUICovXTogYFRFWFRgLFxyXG4gICAgWzIgLyogQ0xBU1MgKi9dOiBgQ0xBU1NgLFxyXG4gICAgWzQgLyogU1RZTEUgKi9dOiBgU1RZTEVgLFxyXG4gICAgWzggLyogUFJPUFMgKi9dOiBgUFJPUFNgLFxyXG4gICAgWzE2IC8qIEZVTExfUFJPUFMgKi9dOiBgRlVMTF9QUk9QU2AsXHJcbiAgICBbMzIgLyogSFlEUkFURV9FVkVOVFMgKi9dOiBgSFlEUkFURV9FVkVOVFNgLFxyXG4gICAgWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL106IGBTVEFCTEVfRlJBR01FTlRgLFxyXG4gICAgWzEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqL106IGBLRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi9dOiBgVU5LRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbNTEyIC8qIE5FRURfUEFUQ0ggKi9dOiBgTkVFRF9QQVRDSGAsXHJcbiAgICBbMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovXTogYERZTkFNSUNfU0xPVFNgLFxyXG4gICAgWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dOiBgREVWX1JPT1RfRlJBR01FTlRgLFxyXG4gICAgWy0xIC8qIEhPSVNURUQgKi9dOiBgSE9JU1RFRGAsXHJcbiAgICBbLTIgLyogQkFJTCAqL106IGBCQUlMYFxyXG59O1xuXG4vKipcclxuICogRGV2IG9ubHlcclxuICovXHJcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XHJcbiAgICBbMSAvKiBTVEFCTEUgKi9dOiAnU1RBQkxFJyxcclxuICAgIFsyIC8qIERZTkFNSUMgKi9dOiAnRFlOQU1JQycsXHJcbiAgICBbMyAvKiBGT1JXQVJERUQgKi9dOiAnRk9SV0FSREVEJ1xyXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9ICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLCcgK1xyXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksJyArXHJcbiAgICAnT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQnO1xyXG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJyAnLnJlcGVhdChwYWQpICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKTtcclxufVxuXG4vKipcclxuICogT24gdGhlIGNsaWVudCB3ZSBvbmx5IG5lZWQgdG8gb2ZmZXIgc3BlY2lhbCBjYXNlcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXRcclxuICogaGF2ZSBkaWZmZXJlbnQgbmFtZXMgZnJvbSB0aGVpciBjb3JyZXNwb25kaW5nIGRvbSBwcm9wZXJ0aWVzOlxyXG4gKiAtIGl0ZW1zY29wZSAtPiBOL0FcclxuICogLSBhbGxvd2Z1bGxzY3JlZW4gLT4gYWxsb3dGdWxsc2NyZWVuXHJcbiAqIC0gZm9ybW5vdmFsaWRhdGUgLT4gZm9ybU5vVmFsaWRhdGVcclxuICogLSBpc21hcCAtPiBpc01hcFxyXG4gKiAtIG5vbW9kdWxlIC0+IG5vTW9kdWxlXHJcbiAqIC0gbm92YWxpZGF0ZSAtPiBub1ZhbGlkYXRlXHJcbiAqIC0gcmVhZG9ubHkgLT4gcmVhZE9ubHlcclxuICovXHJcbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcclxuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XHJcbi8qKlxyXG4gKiBUaGUgZnVsbCBsaXN0IGlzIG5lZWRlZCBkdXJpbmcgU1NSIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgaW5pdGlhbCBtYXJrdXAuXHJcbiAqL1xyXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgK1xyXG4gICAgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sYCArXHJcbiAgICBgbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxgICtcclxuICAgIGBjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XHJcbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcclxuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XHJcbiAgICBpZiAoaXNVbnNhZmUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZSk7XHJcbn1cclxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XHJcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxyXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxyXG4gICAgaHRtbEZvcjogJ2ZvcicsXHJcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xyXG59O1xyXG4vKipcclxuICogQ1NTIHByb3BlcnRpZXMgdGhhdCBhY2NlcHQgcGxhaW4gbnVtYmVyc1xyXG4gKi9cclxuY29uc3QgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LGJvcmRlci1pbWFnZS1vdXRzZXQsYm9yZGVyLWltYWdlLXNsaWNlLGAgK1xyXG4gICAgYGJvcmRlci1pbWFnZS13aWR0aCxib3gtZmxleCxib3gtZmxleC1ncm91cCxib3gtb3JkaW5hbC1ncm91cCxjb2x1bW4tY291bnQsYCArXHJcbiAgICBgY29sdW1ucyxmbGV4LGZsZXgtZ3JvdyxmbGV4LXBvc2l0aXZlLGZsZXgtc2hyaW5rLGZsZXgtbmVnYXRpdmUsZmxleC1vcmRlcixgICtcclxuICAgIGBncmlkLXJvdyxncmlkLXJvdy1lbmQsZ3JpZC1yb3ctc3BhbixncmlkLXJvdy1zdGFydCxncmlkLWNvbHVtbixgICtcclxuICAgIGBncmlkLWNvbHVtbi1lbmQsZ3JpZC1jb2x1bW4tc3BhbixncmlkLWNvbHVtbi1zdGFydCxmb250LXdlaWdodCxsaW5lLWNsYW1wLGAgK1xyXG4gICAgYGxpbmUtaGVpZ2h0LG9wYWNpdHksb3JkZXIsb3JwaGFucyx0YWItc2l6ZSx3aWRvd3Msei1pbmRleCx6b29tLGAgK1xyXG4gICAgLy8gU1ZHXHJcbiAgICBgZmlsbC1vcGFjaXR5LGZsb29kLW9wYWNpdHksc3RvcC1vcGFjaXR5LHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsYCArXHJcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoYCk7XHJcbi8qKlxyXG4gKiBLbm93biBhdHRyaWJ1dGVzLCB0aGlzIGlzIHVzZWQgZm9yIHN0cmluZ2lmaWNhdGlvbiBvZiBydW50aW1lIHN0YXRpYyBub2Rlc1xyXG4gKiBzbyB0aGF0IHdlIGRvbid0IHN0cmluZ2lmeSBiaW5kaW5ncyB0aGF0IGNhbm5vdCBiZSBzZXQgZnJvbSBIVE1MLlxyXG4gKiBEb24ndCBhbHNvIGZvcmdldCB0byBhbGxvdyBgZGF0YS0qYCBhbmQgYGFyaWEtKmAhXHJcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlc1xyXG4gKi9cclxuY29uc3QgaXNLbm93bkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcclxuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcclxuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcclxuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXHJcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXHJcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xyXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXHJcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xyXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcclxuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xyXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcclxuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xyXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcclxuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcclxuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVN0eWxlKGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IGl0ZW0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcclxuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KC4rKS87XHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xyXG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xyXG4gICAgbGV0IHJldCA9ICcnO1xyXG4gICAgaWYgKCFzdHlsZXMpIHtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcChub3JtYWxpemVkS2V5KSkpIHtcclxuICAgICAgICAgICAgLy8gb25seSByZW5kZXIgdmFsaWQgdmFsdWVzXHJcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcclxuICAgIGxldCByZXMgPSAnJztcclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMudHJpbSgpO1xyXG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxyXG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcclxuICAgICdoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xyXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xyXG4gICAgJ2RhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcclxuICAgICd0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLCcgK1xyXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcclxuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXHJcbiAgICAnb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSwnICtcclxuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290JztcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcclxuY29uc3QgU1ZHX1RBR1MgPSAnc3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLCcgK1xyXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXHJcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcclxuICAgICdmZURpc3RhbmNlTGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcclxuICAgICdmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LCcgK1xyXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXHJcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xyXG4gICAgJ21lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybiwnICtcclxuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xyXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XHJcbmNvbnN0IFZPSURfVEFHUyA9ICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicic7XHJcbmNvbnN0IGlzSFRNTFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xyXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XHJcbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzdHIgPSAnJyArIHN0cmluZztcclxuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICBsZXQgaHRtbCA9ICcnO1xyXG4gICAgbGV0IGVzY2FwZWQ7XHJcbiAgICBsZXQgaW5kZXg7XHJcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcclxuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcclxuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJnF1b3Q7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZhbXA7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyYjMzk7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZsdDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmd0Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xyXG4gICAgICAgICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcclxufVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUyL3N5bnRheC5odG1sI2NvbW1lbnRzXHJcbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xyXG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCAnJyk7XHJcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcclxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlcXVhbDtcclxufVxyXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XHJcbiAgICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRoaXMgaWYgd2lsbCBwcm9iYWJseSBuZXZlciBiZSBjYWxsZWQgKi9cclxuICAgICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGlmICgoYUhhc0tleSAmJiAhYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICghYUhhc0tleSAmJiBiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XHJcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChpdGVtID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XHJcbn1cblxuLyoqXHJcbiAqIEZvciBjb252ZXJ0aW5nIHt7IGludGVycG9sYXRpb24gfX0gdmFsdWVzIHRvIGRpc3BsYXllZCBzdHJpbmdzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXHJcbiAgICAgICAgPyAnJ1xyXG4gICAgICAgIDogaXNPYmplY3QodmFsKVxyXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXHJcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XHJcbn07XHJcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xyXG4gICAgaWYgKGlzTWFwKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgICAgICAgICAgfSwge30pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59O1xuXG4vKipcclxuICogTGlzdCBvZiBAYmFiZWwvcGFyc2VyIHBsdWdpbnMgdGhhdCBhcmUgdXNlZCBmb3IgdGVtcGxhdGUgZXhwcmVzc2lvblxyXG4gKiB0cmFuc2Zvcm1zIGFuZCBTRkMgc2NyaXB0IHRyYW5zZm9ybXMuIEJ5IGRlZmF1bHQgd2UgZW5hYmxlIHByb3Bvc2FscyBzbGF0ZWRcclxuICogZm9yIEVTMjAyMC4gVGhpcyB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZCBhcyB0aGUgc3BlYyBtb3ZlcyBmb3J3YXJkLlxyXG4gKiBGdWxsIGxpc3QgYXQgaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vbmV4dC9iYWJlbC1wYXJzZXIjcGx1Z2luc1xyXG4gKi9cclxuY29uc3QgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyA9IFtcclxuICAgICdiaWdJbnQnLFxyXG4gICAgJ29wdGlvbmFsQ2hhaW5pbmcnLFxyXG4gICAgJ251bGxpc2hDb2FsZXNjaW5nT3BlcmF0b3InXHJcbl07XHJcbmNvbnN0IEVNUFRZX09CSiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxyXG4gICAgOiB7fTtcclxuY29uc3QgRU1QVFlfQVJSID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcclxuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcclxuLyoqXHJcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xyXG5jb25zdCBvblJFID0gL15vblteYS16XS87XHJcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcclxuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJ29uVXBkYXRlOicpO1xyXG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xyXG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xyXG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcclxuICAgIGlmIChpID4gLTEpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XHJcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBNYXBdJztcclxuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgU2V0XSc7XHJcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIERhdGU7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xyXG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xyXG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnO1xyXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcclxuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xyXG59O1xyXG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgLy8gZXh0cmFjdCBcIlJhd1R5cGVcIiBmcm9tIHN0cmluZ3MgbGlrZSBcIltvYmplY3QgUmF3VHlwZV1cIlxyXG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG59O1xyXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmXHJcbiAgICBrZXkgIT09ICdOYU4nICYmXHJcbiAgICBrZXlbMF0gIT09ICctJyAmJlxyXG4gICAgJycgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xyXG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcclxuLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxyXG4nLGtleSxyZWYsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XHJcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IChzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApKTtcclxuLy8gY29tcGFyZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQsIGFjY291bnRpbmcgZm9yIE5hTi5cclxuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+IHZhbHVlICE9PSBvbGRWYWx1ZSAmJiAodmFsdWUgPT09IHZhbHVlIHx8IG9sZFZhbHVlID09PSBvbGRWYWx1ZSk7XHJcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZuc1tpXShhcmcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWVcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcclxuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xyXG59O1xyXG5sZXQgX2dsb2JhbFRoaXM7XHJcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKF9nbG9iYWxUaGlzIHx8XHJcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cclxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcclxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdsb2JhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xyXG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25BdHRyLCBpc01hcCwgaXNNb2RlbExpc3RlbmVyLCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsImltcG9ydCAqIGFzIHJ1bnRpbWVEb20gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5pbXBvcnQgeyBpbml0Q3VzdG9tRm9ybWF0dGVyLCB3YXJuLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciB9IGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5pbXBvcnQgeyBjb21waWxlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1kb20nO1xuaW1wb3J0IHsgaXNTdHJpbmcsIE5PT1AsIGV4dGVuZCwgZ2VuZXJhdGVDb2RlRnJhbWUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIGluaXREZXYoKSB7XHJcbiAgICB7XHJcbiAgICAgICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xyXG4gICAgfVxyXG59XG5cbi8vIFRoaXMgZW50cnkgaXMgdGhlIFwiZnVsbC1idWlsZFwiIHRoYXQgaW5jbHVkZXMgYm90aCB0aGUgcnVudGltZVxyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBpbml0RGV2KCk7XHJcbn1cclxuY29uc3QgY29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb24odGVtcGxhdGUsIG9wdGlvbnMpIHtcclxuICAgIGlmICghaXNTdHJpbmcodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYGludmFsaWQgdGVtcGxhdGUgb3B0aW9uOiBgLCB0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBOT09QO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGtleSA9IHRlbXBsYXRlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY29tcGlsZUNhY2hlW2tleV07XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGlmICh0ZW1wbGF0ZVswXSA9PT0gJyMnKSB7XHJcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRlbXBsYXRlKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFlbCkge1xyXG4gICAgICAgICAgICB3YXJuKGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHt0ZW1wbGF0ZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gX19VTlNBRkVfX1xyXG4gICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXHJcbiAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBtYWtlIHN1cmUgdGhlIGluLURPTSB0ZW1wbGF0ZSBpcyB0cnVzdGVkLiBJZiBpdCdzIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gYnkgdGhlIHNlcnZlciwgdGhlIHRlbXBsYXRlIHNob3VsZCBub3QgY29udGFpbiBhbnkgdXNlciBkYXRhLlxyXG4gICAgICAgIHRlbXBsYXRlID0gZWwgPyBlbC5pbm5lckhUTUwgOiBgYDtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgY29kZSB9ID0gY29tcGlsZSh0ZW1wbGF0ZSwgZXh0ZW5kKHtcclxuICAgICAgICBob2lzdFN0YXRpYzogdHJ1ZSxcclxuICAgICAgICBvbkVycm9yOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBvbkVycm9yIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIG9uV2FybjogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gZSA9PiBvbkVycm9yKGUsIHRydWUpIDogTk9PUFxyXG4gICAgfSwgb3B0aW9ucykpO1xyXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnIsIGFzV2FybmluZyA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFzV2FybmluZ1xyXG4gICAgICAgICAgICA/IGVyci5tZXNzYWdlXHJcbiAgICAgICAgICAgIDogYFRlbXBsYXRlIGNvbXBpbGF0aW9uIGVycm9yOiAke2Vyci5tZXNzYWdlfWA7XHJcbiAgICAgICAgY29uc3QgY29kZUZyYW1lID0gZXJyLmxvYyAmJlxyXG4gICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZXJyLmxvYy5zdGFydC5vZmZzZXQsIGVyci5sb2MuZW5kLm9mZnNldCk7XHJcbiAgICAgICAgd2Fybihjb2RlRnJhbWUgPyBgJHttZXNzYWdlfVxcbiR7Y29kZUZyYW1lfWAgOiBtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIC8vIFRoZSB3aWxkY2FyZCBpbXBvcnQgcmVzdWx0cyBpbiBhIGh1Z2Ugb2JqZWN0IHdpdGggZXZlcnkgZXhwb3J0XHJcbiAgICAvLyB3aXRoIGtleXMgdGhhdCBjYW5ub3QgYmUgbWFuZ2xlZCwgYW5kIGNhbiBiZSBxdWl0ZSBoZWF2eSBzaXplLXdpc2UuXHJcbiAgICAvLyBJbiB0aGUgZ2xvYmFsIGJ1aWxkIHdlIGtub3cgYFZ1ZWAgaXMgYXZhaWxhYmxlIGdsb2JhbGx5IHNvIHdlIGNhbiBhdm9pZFxyXG4gICAgLy8gdGhlIHdpbGRjYXJkIG9iamVjdC5cclxuICAgIGNvbnN0IHJlbmRlciA9IChuZXcgRnVuY3Rpb24oJ1Z1ZScsIGNvZGUpKHJ1bnRpbWVEb20pKTtcclxuICAgIHJlbmRlci5fcmMgPSB0cnVlO1xyXG4gICAgcmV0dXJuIChjb21waWxlQ2FjaGVba2V5XSA9IHJlbmRlcik7XHJcbn1cclxucmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoY29tcGlsZVRvRnVuY3Rpb24pO1xuXG5leHBvcnQgeyBjb21waWxlVG9GdW5jdGlvbiBhcyBjb21waWxlIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHtjcmVhdGVBcHB9IGZyb20gJ3Z1ZSdcblxuY29uc3QgYXBwID0gY3JlYXRlQXBwKHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2ViY2FtU3RhdHVzOiAnJyxcbiAgICAgIFRGQ0FNOiB1bmRlZmluZWQsXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYXN5bmMgc3RhcnRDYW0oKSB7XG4gICAgICBjb25zdCBzbmFwc2hvdHMgPSBbMF1cbiAgICAgIHRoaXMuVEZDQU0gPSB0aGlzLlRGQ0FNIHx8IGF3YWl0IHRmLmRhdGEud2ViY2FtKHRoaXMuJHJlZnMud2ViY2FtKVxuICAgICAgc25hcHNob3RzLm1hcChhc3luYyBfID0+IHtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGF3YWl0IHRoaXMuVEZDQU0uY2FwdHVyZSgpXG5cbiAgICAgICAgdGhpcy5pbWFnZUZyb21DYXB0dXJlKGNhcHR1cmUsIChkYXRhVXJsKSA9PiB0aGlzLnVwbG9hZERhdGFVcmwoZGF0YVVybCkpXG4gICAgICAgIC50aGVuKF8gPT4gdGhpcy53ZWJjYW1TdGF0dXMgPSAnU3RhcnRlZCcpXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBzdG9wQ2FtKCkge1xuICAgICAgaWYgKHRoaXMuVEZDQU0pIHtcbiAgICAgICAgdGhpcy5URkNBTS5zdG9wKClcbiAgICAgICAgdGhpcy5URkNBTSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIHRoaXMud2ViY2FtU3RhdHVzID0gXCJTdG9wcGVkXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2ViY2FtU3RhdHVzID0gXCJOb3Qgc3RhcnRlZFwiXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGltYWdlRnJvbUNhcHR1cmUoZGF0YSwgZm4pIHtcbiAgICAgIHJldHVybiAgdGYuYnJvd3Nlci50b1BpeGVscyhkYXRhLCB0aGlzLiRyZWZzLmhpZGRlbkNhbnZhcylcbiAgICAgIC50aGVuKGFzeW5jIF8gPT4ge1xuICAgICAgICBjb25zdCBkYXRhVXJsID0gdGhpcy4kcmVmcy5oaWRkZW5DYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKVxuICAgICAgICBmbihkYXRhVXJsKVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgdXBsb2FkRGF0YVVybChkYXRhVXJsKSB7XG4gICAgICBjb25zdCBkYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGRhdGEuYXBwZW5kKCdpbWFnZScsIGRhdGFVcmwpXG5cbiAgICAgIGZldGNoKFxuICAgICAgICAnL3VwbG9hZEltYWdlJyxcbiAgICAgICAgeyBtZXRob2Q6J1BPU1QnLCBib2R5OiBkYXRhfVxuICAgICAgKVxuICAgICAgLnRoZW4oYXN5bmMgcmVzID0+IHRoaXMud2ViY2FtU3RhdHVzID0gYXdhaXQgcmVzLnRleHQoKSlcbiAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy53ZWJjYW1TdGF0dXMgPSBlcnIpXG4gICAgfVxuICB9XG59KVxuXG5hcHAubW91bnQoJyNhcHAnKSJdLCJzb3VyY2VSb290IjoiIn0=